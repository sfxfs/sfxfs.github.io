<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>FreeRTOS 的多任务实现、调度机制与内存管理</title>
      <link href="/2025/10/01/FreeRTOS-%E7%9A%84%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0%E3%80%81%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2025/10/01/FreeRTOS-%E7%9A%84%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0%E3%80%81%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>一、整体架构概览</p><ul><li>FreeRTOS 是单核、基于固定优先级的抢占式实时内核（也支持协作式）。</li><li>任务由内核维护的任务控制块 TCB 与任务栈组成；TCB 里保存任务上下文与调度元数据。</li><li>核心数据结构是多组就绪链表、延时链表、挂起链表和事件链表；调度器按“最高优先级就绪任务先运行”的规则选择任务。</li><li>上下文切换由定时节拍中断（tick）或事件唤醒触发，在各体系结构的移植层（portable&#x2F;portmacro.h）通过汇编&#x2F;内联汇编保存与恢复寄存器。</li></ul><p>二、任务与上下文</p><ul><li>TCB 关键字段（不同端口略有差异）：<ul><li>pxTopOfStack：当前栈顶（保存寄存器的上下文帧）。</li><li>pxStack&#x2F;pxEndOfStack：任务栈起止。</li><li>uxPriority：任务优先级（0..configMAX_PRIORITIES-1）。</li><li>xStateListItem：把任务挂到就绪&#x2F;延时等链表用的节点。</li><li>xEventListItem：等待队列&#x2F;信号量等事件列表的节点。</li></ul></li><li>任务状态：Running、Ready、Blocked（延时或等待事件）、Suspended、Deleted。</li><li>任务创建：xTaskCreate&#x2F;xTaskCreateStatic，动态或静态分配 TCB 与栈；入口是任务函数（无限循环），退出一般不返回。</li></ul><p>三、调度器与就绪列表</p><ul><li>算法：固定优先级抢占。<ul><li>configUSE_PREEMPTION&#x3D;1：高优先级就绪时立即抢占。</li><li>同优先级任务可时间片轮转（configUSE_TIME_SLICING&#x3D;1）。</li><li>configUSE_PORT_OPTIMISED_TASK_SELECTION 可用位图快速找到最高优先级。</li></ul></li><li>核心链表：<ul><li>pxReadyTasksLists[]：每个优先级一个就绪链表。</li><li>xDelayedTaskList1&#x2F;xDelayedTaskList2：延时任务的两条时间轮链表（处理 tick 计数溢出）。</li><li>xSuspendedTaskList：挂起任务。</li><li>每个队列&#x2F;信号量&#x2F;事件组都有一个或多个等待任务的事件链表（按优先级有序）。</li></ul></li><li>触发调度的时机：<ul><li>周期性：tick 中断（系统心跳）。</li><li>任务主动让出或阻塞：taskYIELD、vTaskDelay、xQueueReceive 等。</li><li>中断使更高优先级任务就绪：FromISR API 设置 xHigherPriorityTaskWoken 并触发 yield。</li><li>变更优先级&#x2F;任务就绪状态：vTaskPrioritySet、xTaskResume 等。</li></ul></li></ul><p>四、上下文切换过程（以 Cortex-M 为例）</p><ul><li>时钟：通常用 SysTick 产生 tick；在中断里决定是否需要切换。</li><li>机制：<ul><li>在中断里将“需要切换”的请求转成挂起 PendSV（最低优先级的异常），避免与其他 ISR 竞争。</li><li>PendSV 入口执行保存当前任务上下文（R4-R11 等）到其任务栈，更新当前 TCB-&gt;pxTopOfStack。</li><li>选择下一个任务（最高优先级 ready 列表的链表头）。</li><li>从新任务的栈恢复上下文，退出异常返回到新任务。</li></ul></li><li>关键宏&#x2F;函数：portYIELD_FROM_ISR、portEND_SWITCHING_ISR、portSET_INTERRUPT_MASK_FROM_ISR&#x2F;portCLEAR…、vTaskSwitchContext、portSAVE_CONTEXT&#x2F;portRESTORE_CONTEXT。</li><li>临界区：taskENTER_CRITICAL&#x2F;taskEXIT_CRITICAL（Cortex-M 常用 BASEPRI 屏蔽优先级阈值）。</li></ul><p>五、阻塞与事件同步</p><ul><li>延时：vTaskDelay&#x2F;xTaskDelayUntil 将任务移入延时链表，tick 递减到期后移回就绪链表。</li><li>等待队列&#x2F;信号量&#x2F;互斥量&#x2F;事件组：<ul><li>任务进入 Blocked 并挂到对应对象的事件链表，支持超时。</li><li>释放事件时按优先级唤醒一个或多个任务。</li></ul></li><li>互斥的优先级继承：configUSE_MUTEXES&#x3D;1 且 configUSE_PRIORITY_INHERITANCE&#x3D;1 时生效，减少优先级反转。</li><li>软件定时器：单独的定时器服务任务处理回调（deferred execution）。</li></ul><p>六、时间片与低功耗</p><ul><li>同优先级时间片：tick 到来时轮转链表头到尾；使同优先级公平。</li><li>Tickless Idle：configUSE_TICKLESS_IDLE&#x3D;1，空闲时暂停节拍定时器，设定低功耗定时器在下一个唤醒点触发，醒来补偿丢失的 tick，显著降功耗。</li></ul><p>七、内存管理</p><ol><li>任务栈与 TCB</li></ol><ul><li>动态分配：xTaskCreate 使用 pvPortMalloc 为 TCB 和栈分配内存。</li><li>静态分配：xTaskCreateStatic 由用户提供 TCB 与栈缓冲（configSUPPORT_STATIC_ALLOCATION&#x3D;1）。</li><li>栈大小以“栈宽度单位”（StackType_t）指定，依端口是 4&#x2F;8 字节。</li><li>栈溢出检测：configCHECK_FOR_STACK_OVERFLOW（模式 1&#x2F;2）+ vApplicationStackOverflowHook。</li></ul><ol start="2"><li>内核对象</li></ol><ul><li>队列、信号量、事件组、定时器等均可动态或静态创建（如 xQueueCreateStatic、xSemaphoreCreateBinaryStatic）。</li><li>定时器服务任务与空闲任务可由应用提供静态内存：vApplicationGetTimerTaskMemory&#x2F;vApplicationGetIdleTaskMemory。</li></ul><ol start="3"><li>堆实现（heap_1..heap_5）</li></ol><ul><li>heap_1：仅分配不释放，最简单、无碎片，适合启动期一次性分配。</li><li>heap_2：带释放，简单空闲链表，不合并相邻空闲块，易碎片。</li><li>heap_3：封装标准库 malloc&#x2F;free，线程安全由 FreeRTOS 临界区保护，但实时性取决于 libc。</li><li>heap_4：最佳适配 + 合并相邻空闲块，通用、实时性较好，推荐默认。</li><li>heap_5：多内存区域版本的 heap_4，可配置多个不连续内存段（适合分散 RAM）。</li><li>选择方式：在 FreeRTOSConfig.h 通过包含相应的 portable&#x2F;MemMang&#x2F;heap_x.c 实现一个 pvPortMalloc&#x2F;vPortFree。</li><li>线程安全：内核通过临界区保护 pvPortMalloc&#x2F;vPortFree，使其在任务&#x2F;中断上下文安全（FromISR 不允许分配）。</li></ul><ol start="4"><li>注意与建议</li></ol><ul><li>中断上下文禁止调用会触发阻塞或动态分配的 API；ISR 使用 FromISR 变体，且不能调用 pvPortMalloc。</li><li>控制碎片：优先使用静态创建或集中在系统初始化阶段一次性动态创建；若需运行期创建&#x2F;删除，选择 heap_4&#x2F;5。</li><li>监控：启用 configUSE_MALLOC_FAILED_HOOK 与 vApplicationMallocFailedHook；配置 uxTaskGetStackHighWaterMark 监控栈余量。</li></ul><p>八、常用配置项速览</p><ul><li>configUSE_PREEMPTION、configUSE_TIME_SLICING、configTICK_RATE_HZ、configMAX_PRIORITIES</li><li>configSUPPORT_STATIC_ALLOCATION、configSUPPORT_DYNAMIC_ALLOCATION</li><li>configCHECK_FOR_STACK_OVERFLOW、configUSE_IDLE_HOOK、configUSE_TICK_HOOK、configUSE_TICKLESS_IDLE</li><li>configUSE_MUTEXES、configUSE_RECURSIVE_MUTEXES、configUSE_COUNTING_SEMAPHORES、configUSE_TASK_NOTIFICATIONS</li><li>configQUEUE_REGISTRY_SIZE（队列注册调试）、configASSERT（断言）</li><li>端口相关：configCPU_CLOCK_HZ、configPRIO_BITS、configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY、configKERNEL_INTERRUPT_PRIORITY、configMAX_SYSCALL_INTERRUPT_PRIORITY</li></ul><p>九、常见排障思路</p><ul><li>任务不切换：检查中断优先级配置（尤其 Cortex-M 的 BASEPRI）、SysTick&#x2F;PendSV 使能、portYIELD_FROM_ISR 的使用。</li><li>高优先级“饿死”低优先级：确认是否需要 time slicing 或在高优先级任务里适当阻塞&#x2F;让出。</li><li>栈溢出&#x2F;硬 Fault：开启栈溢出检测、增大疑似任务栈、检查递归&#x2F;大数组。</li><li>内存不足&#x2F;碎片：切换到 heap_4&#x2F;5，改为静态分配或对象池，合并创建&#x2F;删除路径。</li><li>优先级反转：使用互斥量而非二值信号量并开启优先级继承。</li></ul><p>如果你有目标平台（如 Cortex-M、RISC-V、Xtensa）或具体 FreeRTOS 版本&#x2F;配置，我可以结合该端口画出更具体的上下文切换序列图与关键寄存器保存&#x2F;恢复细节，并给出 FreeRTOSConfig.h 的参考配置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
            <tag> Task </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS中的SysTick、SVCall和Pend</title>
      <link href="/2025/09/30/FreeRTOS%E4%B8%AD%E7%9A%84SysTick%E3%80%81SVCall%E5%92%8CPend/"/>
      <url>/2025/09/30/FreeRTOS%E4%B8%AD%E7%9A%84SysTick%E3%80%81SVCall%E5%92%8CPend/</url>
      
        <content type="html"><![CDATA[<h2 id="1-SysTick"><a href="#1-SysTick" class="headerlink" title="1. SysTick"></a>1. <strong>SysTick</strong></h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><strong>SysTick</strong> 是 Cortex-M 系列专用的系统定时器中断。</li><li>通常用于周期性地触发中断，时间间隔可以配置（比如每 1ms）。</li><li>优先级可以设置，通常高于 PendSV。</li></ul><h3 id="在-FreeRTOS-中的用途"><a href="#在-FreeRTOS-中的用途" class="headerlink" title="在 FreeRTOS 中的用途"></a>在 FreeRTOS 中的用途</h3><ul><li><strong>系统时钟节拍</strong>（tick）：FreeRTOS 用 SysTick 定时器生成操作系统节拍（OS Tick），即系统“心跳”。</li><li>每当 SysTick 中断发生时，FreeRTOS 增加 tick 计数器，判断是否有延时任务需要唤醒，并决定是否触发任务切换（如果有高优先级任务就绪）。</li><li>主要代码位于 <code>SysTick_Handler</code>，会调用 <code>xPortSysTickHandler()</code>。</li></ul><hr><h2 id="2-SVCall"><a href="#2-SVCall" class="headerlink" title="2. SVCall"></a>2. <strong>SVCall</strong></h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul><li><strong>SVCall</strong>（Supervisor Call）是一个软件触发的中断，通过执行 SVC 指令产生。</li><li>用于实现特权级操作或系统服务调用。</li></ul><h3 id="在-FreeRTOS-中的用途-1"><a href="#在-FreeRTOS-中的用途-1" class="headerlink" title="在 FreeRTOS 中的用途"></a>在 FreeRTOS 中的用途</h3><ul><li>在一些 FreeRTOS 端口（如 ARM Cortex-M）中，SVCall 可用于进入或退出特权级模式，实现系统调用。</li><li>比如在支持 MPU（内存保护单元）的端口，FreeRTOS 通过 SVC 切换任务的权限级别。</li><li>在多数基础 FreeRTOS 用法中，SVCall用得较少，主要用于安全相关或特权切换场景。</li></ul><hr><h2 id="3-PendSV"><a href="#3-PendSV" class="headerlink" title="3. PendSV"></a>3. <strong>PendSV</strong></h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><ul><li><strong>PendSV</strong>（Pendable Service Call）是 Cortex-M 专有的、优先级最低的系统异常。</li><li>只能由软件设置挂起，不能被硬件自动触发。</li><li>设计目标：专用于 RTOS 的任务上下文切换。</li></ul><h3 id="在-FreeRTOS-中的用途-2"><a href="#在-FreeRTOS-中的用途-2" class="headerlink" title="在 FreeRTOS 中的用途"></a>在 FreeRTOS 中的用途</h3><ul><li><strong>任务切换（上下文切换）</strong>：FreeRTOS 通过挂起 PendSV （<code>SCB-&gt;ICSR |= SCB_ICSR_PENDSVSET_Msk</code>），实现任务切换的时机控制。</li><li>当需要切换任务时（如更高优先级任务就绪或主动 yield），调度器会触发 PendSV。</li><li>PendSV 的异常处理函数会保存当前任务现场、恢复下一个任务现场，完成任务切换。</li></ul><hr><h2 id="总结表格"><a href="#总结表格" class="headerlink" title="总结表格"></a>总结表格</h2><table><thead><tr><th>异常名</th><th>Cortex-M作用</th><th>FreeRTOS用途</th></tr></thead><tbody><tr><td>SysTick</td><td>周期性定时器中断</td><td>产生OS节拍，管理任务延时和唤醒</td></tr><tr><td>SVCall</td><td>软件触发的系统调用</td><td>进入&#x2F;退出特权级，安全相关</td></tr><tr><td>PendSV</td><td>挂起服务异常</td><td>任务上下文切换（切换任务）</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>array、vector、list的区别</title>
      <link href="/2025/09/30/array%E3%80%81vector%E3%80%81list%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/09/30/array%E3%80%81vector%E3%80%81list%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>下面分别介绍 C++ 标准库中的 <code>array</code>、<code>vector</code> 和 <code>list</code> 的区别：</p><hr><h3 id="array-和-vector-的区别"><a href="#array-和-vector-的区别" class="headerlink" title="array 和 vector 的区别"></a>array 和 vector 的区别</h3><table><thead><tr><th>特性</th><th>array</th><th>vector</th></tr></thead><tbody><tr><td>定义方式</td><td><code>std::array&lt;T, N&gt;</code></td><td><code>std::vector&lt;T&gt;</code></td></tr><tr><td>容量</td><td>固定（编译期已知大小）</td><td>动态（运行时可扩展）</td></tr><tr><td>内存分配</td><td>通常在栈上（连续空间）</td><td>在堆上（连续空间）</td></tr><tr><td>能否改变大小</td><td>不能，创建后大小固定</td><td>可以自动扩容&#x2F;缩小</td></tr><tr><td>性能</td><td>访问速度快（和原生数组一样）</td><td>访问速度快，扩容时有开销</td></tr><tr><td>用途</td><td>大小已知且固定的数组</td><td>需频繁增删元素的场景</td></tr></tbody></table><p><strong>举例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;     <span class="comment">// 固定长度，不能扩容</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;       <span class="comment">// 可动态扩容</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">6</span>);                             <span class="comment">// 支持动态插入</span></span><br></pre></td></tr></table></figure><hr><h3 id="vector-和-list-的区别"><a href="#vector-和-list-的区别" class="headerlink" title="vector 和 list 的区别"></a>vector 和 list 的区别</h3><table><thead><tr><th>特性</th><th>vector</th><th>list</th></tr></thead><tbody><tr><td>底层结构</td><td>数组（连续内存）</td><td>双向链表</td></tr><tr><td>访问速度</td><td>随机访问快（O(1)）</td><td>随机访问慢（O(n)）</td></tr><tr><td>插入&#x2F;删除</td><td>尾部效率高，头部&#x2F;中间慢</td><td>任意位置插入&#x2F;删除都快</td></tr><tr><td>内存使用</td><td>连续空间，内存碎片少</td><td>每个节点有额外指针开销</td></tr><tr><td>适用场景</td><td>需频繁随机访问或尾部操作</td><td>需频繁在中间插入&#x2F;删除</td></tr></tbody></table><p><strong>举例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">4</span>);   <span class="comment">// 插入效率低，可能整体搬移</span></span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; l = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = l.<span class="built_in">begin</span>();</span><br><span class="line">std::<span class="built_in">advance</span>(it, <span class="number">1</span>);          <span class="comment">// 移动到第二个元素</span></span><br><span class="line">l.<span class="built_in">insert</span>(it, <span class="number">4</span>);              <span class="comment">// 插入效率高</span></span><br></pre></td></tr></table></figure><hr><p><strong>总结：</strong></p><ul><li><code>array</code>：大小固定，适合已知长度的数组。</li><li><code>vector</code>：动态数组，适合大量随机访问和尾部插入。</li><li><code>list</code>：链表，适合频繁在任意位置插入&#x2F;删除，但不适合随机访问。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下软链接和硬链接区别</title>
      <link href="/2025/09/30/Linux%E4%B8%8B%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/09/30/Linux%E4%B8%8B%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="1-定义和原理"><a href="#1-定义和原理" class="headerlink" title="1. 定义和原理"></a>1. 定义和原理</h3><ul><li><strong>硬链接</strong>：是对文件的一个直接引用。多个硬链接指向同一个 inode（即文件的唯一标识），它们是等价的，每一个都像原始文件一样。</li><li><strong>软链接</strong>：是一个特殊的文件，内容是指向目标文件路径的字符串，相当于 Windows 下的快捷方式。</li></ul><h3 id="2-inode-和文件数据块"><a href="#2-inode-和文件数据块" class="headerlink" title="2. inode 和文件数据块"></a>2. inode 和文件数据块</h3><ul><li><strong>硬链接</strong>：与原文件共享 inode 号。删除任意一个硬链接，其他硬链接和数据仍然存在，只有所有硬链接都删除后，文件数据才会被释放。</li><li><strong>软链接</strong>：有自己独立的 inode，存储的是目标文件路径，不直接指向数据块。</li></ul><h3 id="3-跨文件系统"><a href="#3-跨文件系统" class="headerlink" title="3. 跨文件系统"></a>3. 跨文件系统</h3><ul><li><strong>硬链接</strong>：只能在同一个文件系统（分区）内创建，不能跨分区。</li><li><strong>软链接</strong>：可以跨文件系统或分区，只要路径能访问即可。</li></ul><h3 id="4-对目录的支持"><a href="#4-对目录的支持" class="headerlink" title="4. 对目录的支持"></a>4. 对目录的支持</h3><ul><li><strong>硬链接</strong>：普通用户不能对目录创建硬链接（防止循环和混乱），只有超级用户可以在特定情况下创建。</li><li><strong>软链接</strong>：可以对文件和目录都创建软链接。</li></ul><h3 id="5-断链问题"><a href="#5-断链问题" class="headerlink" title="5. 断链问题"></a>5. 断链问题</h3><ul><li><strong>硬链接</strong>：只要有一个硬链接在，文件数据就能访问。</li><li><strong>软链接</strong>：如果目标文件删除或移动，软链接就“失效”变成死链（Broken Link）。</li></ul><h3 id="6-显示方式"><a href="#6-显示方式" class="headerlink" title="6. 显示方式"></a>6. 显示方式</h3><ul><li>使用 <code>ls -l</code> 命令：<ul><li>硬链接：和普通文件一样显示。</li><li>软链接：显示为 <code>目标文件 -&gt; 源文件</code> 的形式，如 <code>link.txt -&gt; target.txt</code></li></ul></li></ul><h3 id="7-创建方式"><a href="#7-创建方式" class="headerlink" title="7. 创建方式"></a>7. 创建方式</h3><ul><li><strong>硬链接</strong>：<code>ln 源文件 硬链接文件</code></li><li><strong>软链接</strong>：<code>ln -s 源文件 软链接文件</code></li></ul><hr><h4 id="总结对比表"><a href="#总结对比表" class="headerlink" title="总结对比表"></a>总结对比表</h4><table><thead><tr><th>类型</th><th>是否跨分区</th><th>是否可对目录</th><th>inode关系</th><th>删除原文件影响</th><th>创建命令</th></tr></thead><tbody><tr><td>硬链接</td><td>否</td><td>否</td><td>相同</td><td>无影响</td><td>ln 源 目标</td></tr><tr><td>软链接</td><td>是</td><td>是</td><td>不同</td><td>链接失效</td><td>ln -s 源 目标</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> File Link </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>move和forward的区别和应用场景</title>
      <link href="/2025/09/30/move%E5%92%8Cforward%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2025/09/30/move%E5%92%8Cforward%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>在 C++ 中，<code>std::move</code> 和 <code>std::forward</code> 都涉及到“右值引用”和“资源移动”，但应用场景不同：</p><hr><h2 id="1-std-move"><a href="#1-std-move" class="headerlink" title="1. std::move"></a>1. <code>std::move</code></h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><ul><li><strong>强制把对象变成右值</strong>，用于触发移动语义（如移动构造、移动赋值）。</li><li>适用于你已经不再需要原对象，可以“搬走”其资源。</li><li>常用于容器插入、函数返回、资源转移等场景。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;std::string&gt; v;</span><br><span class="line">std::string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 s 的内容“搬”到容器里，而不是拷贝</span></span><br><span class="line">v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(s)); <span class="comment">// s 变为空</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-std-forward"><a href="#2-std-forward" class="headerlink" title="2. std::forward"></a>2. <code>std::forward</code></h2><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><ul><li>用于<strong>完美转发</strong>（perfect forwarding），保持参数的原始类型（左值&#x2F;右值）。</li><li>通常在<strong>模板函数</strong>中，将参数原样“传递”到另一个函数。</li><li>适用于写通用包装函数、工厂函数等场景。</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保持 arg 的左值/右值属性，完美转发到目标函数</span></span><br><span class="line">    <span class="built_in">target_func</span>(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 <code>wrapper(s)</code>，<code>std::forward&lt;T&gt;(arg)</code> 会是左值。</li><li>如果 <code>wrapper(std::move(s))</code>，<code>std::forward&lt;T&gt;(arg)</code> 会是右值。</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>std::move</code>：将对象变成右值，触发移动语义。<strong>适合你已经不再需要原对象的场景。</strong></li><li><code>std::forward</code>：保持参数原始属性，用于模板中的完美转发。<strong>适合泛型代码和包装&#x2F;转发调用。</strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量内存对齐</title>
      <link href="/2025/09/30/%E5%8F%98%E9%87%8F%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
      <url>/2025/09/30/%E5%8F%98%E9%87%8F%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<p>有如下C代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">char</span> c1 = <span class="number">3</span>;</span><br><span class="line"><span class="type">char</span> c2 = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a: %p\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c1:%p\n&quot;</span>,&amp;c1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c2:%p\n&quot;</span>,&amp;c2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出类似这样的地址顺序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c1: 0xaaaac23d1010</span><br><span class="line">c2: 0xaaaac23d1011</span><br><span class="line">a: 0xaaaac23d1014</span><br><span class="line">b: 0xaaaac23d1018</span><br></pre></td></tr></table></figure><p>这是为什么呢？</p><h3 id="1-变量分布与对齐"><a href="#1-变量分布与对齐" class="headerlink" title="1. 变量分布与对齐"></a>1. 变量分布与对齐</h3><ul><li><code>char c1</code>、<code>char c2</code> 连续存放，占用1字节，地址递增。</li><li><code>int a</code>、<code>int b</code> 分别占4字节（假设int为4字节），并且一般要求<strong>4字节对齐</strong>。</li><li>变量在内存中的排列顺序以及对齐方式由<strong>编译器</strong>决定，但通常遵循“定义顺序+对齐优化”。</li></ul><h3 id="2-变量排列推测（假设编译器按定义顺序分配）"><a href="#2-变量排列推测（假设编译器按定义顺序分配）" class="headerlink" title="2. 变量排列推测（假设编译器按定义顺序分配）"></a>2. 变量排列推测（假设编译器按定义顺序分配）</h3><p>假设变量以定义顺序排列在全局数据区（静态区）：</p><ol><li><code>int b</code>  </li><li><code>char c1</code>  </li><li><code>char c2</code>  </li><li><code>int a</code></li></ol><p>输出顺序说明了变量实际排列：</p><ul><li><code>c1</code> 先于 <code>c2</code>，相差1字节（0x1010→0x1011）</li><li><code>a</code> 地址比 <code>c2</code> 高3字节（0x1011→0x1014），说明<code>a</code>被<strong>4字节对齐</strong></li><li><code>b</code> 地址比 <code>a</code>高4字节（0x1014→0x1018）</li></ul><h4 id="变量内存分布（假设起始地址为0x1010）："><a href="#变量内存分布（假设起始地址为0x1010）：" class="headerlink" title="变量内存分布（假设起始地址为0x1010）："></a>变量内存分布（假设起始地址为0x1010）：</h4><table><thead><tr><th>变量</th><th>地址</th><th>占用</th></tr></thead><tbody><tr><td>c1</td><td>0x1010</td><td>1字节</td></tr><tr><td>c2</td><td>0x1011</td><td>1字节</td></tr><tr><td>[填充]</td><td>0x1012-0x1013</td><td>2字节（对齐a）</td></tr><tr><td>a</td><td>0x1014</td><td>4字节</td></tr><tr><td>b</td><td>0x1018</td><td>4字节</td></tr></tbody></table><h3 id="3-为什么要填充（Padding）"><a href="#3-为什么要填充（Padding）" class="headerlink" title="3. 为什么要填充（Padding）"></a>3. 为什么要填充（Padding）</h3><ul><li><code>int</code> 需要4字节对齐，否则CPU访问会慢甚至出错。</li><li>因此在<code>c2</code>之后，编译器自动填充2字节，使<code>a</code>地址是4的倍数（0x1014）。</li><li>同样，<code>b</code> 紧跟在<code>a</code>之后，地址为0x1018。</li></ul><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul><li><strong>变量按定义顺序排列</strong>（全局变量&#x2F;静态变量）。</li><li><strong>char类型紧挨着，int类型由于对齐要求，可能有填充字节。</strong></li><li>打印出的地址正好反映了这种内存布局和对齐。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Memory </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux和裸机程序内存布局</title>
      <link href="/2025/09/30/Linux%E5%92%8C%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
      <url>/2025/09/30/Linux%E5%92%8C%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>所谓的“进程的内存”通常指的是进程的<strong>虚拟地址空间（Virtual Address Space）</strong>，而不是直接的物理内存。</p><p>每个进程都有一个独立、私有的虚拟地址空间，操作系统（如 Linux）会将这个空间划分为几个主要区域，并进行特定的排列。</p><hr><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="进程虚拟地址空间的主要分区"><a href="#进程虚拟地址空间的主要分区" class="headerlink" title="进程虚拟地址空间的主要分区"></a>进程虚拟地址空间的主要分区</h2><p>一个进程的虚拟地址空间通常从低地址向高地址延伸，主要被划分为以下几个区域：</p><h3 id="1-代码段（Text-Segment-Code-Segment）"><a href="#1-代码段（Text-Segment-Code-Segment）" class="headerlink" title="1. 代码段（Text Segment &#x2F; Code Segment）"></a>1. <strong>代码段（Text Segment &#x2F; Code Segment）</strong></h3><ul><li><strong>内容</strong>：存放进程执行的<strong>机器指令</strong>（程序代码）。</li><li><strong>特性</strong>：通常是<strong>只读</strong>的，以防止程序意外地修改自身的指令。它可以被多个进程共享（例如多个进程运行同一个程序）。</li><li><strong>排布</strong>：位于虚拟地址空间的<strong>低端</strong>。</li></ul><h3 id="2-数据段（Data-Segment）"><a href="#2-数据段（Data-Segment）" class="headerlink" title="2. 数据段（Data Segment）"></a>2. <strong>数据段（Data Segment）</strong></h3><ul><li><strong>内容</strong>：存放<strong>已初始化</strong>的<strong>全局变量</strong>和<strong>静态变量</strong>。</li><li><strong>特性</strong>：<strong>可读写</strong>。这些变量的值在程序启动时就已经确定。</li></ul><h3 id="3-BSS-段（Block-Started-by-Symbol-Segment）"><a href="#3-BSS-段（Block-Started-by-Symbol-Segment）" class="headerlink" title="3. BSS 段（Block Started by Symbol Segment）"></a>3. <strong>BSS 段（Block Started by Symbol Segment）</strong></h3><ul><li><strong>内容</strong>：存放<strong>未初始化</strong>的<strong>全局变量</strong>和<strong>静态变量</strong>。</li><li><strong>特性</strong>：<strong>可读写</strong>。在程序加载时，操作系统会将其初始化为 <code>0</code> 或空指针。</li><li><strong>名称由来</strong>：BSS 段在程序文件中不占实际空间，只是记录了所需内存的大小，这有助于减小可执行文件体积。</li></ul><h3 id="4-堆（Heap）"><a href="#4-堆（Heap）" class="headerlink" title="4. 堆（Heap）"></a>4. <strong>堆（Heap）</strong></h3><ul><li><strong>内容</strong>：用于程序运行时的<strong>动态内存分配</strong>（如使用 <code>malloc</code>、<code>calloc</code>、<code>realloc</code> 等函数申请的内存）。</li><li><strong>特性</strong>：<strong>可读写</strong>。</li><li><strong>增长方向</strong>：从低地址向高地址<strong>增长</strong>。</li><li><strong>管理</strong>：由C标准库中的分配器（如 <code>malloc</code> 的实现）管理，它通过 <strong><code>brk</code> &#x2F; <code>sbrk</code></strong> 或 <strong><code>mmap</code></strong> 系统调用向操作系统申请更大的虚拟地址空间。</li></ul><h3 id="5-内存映射区（Memory-Mapping-Segment）"><a href="#5-内存映射区（Memory-Mapping-Segment）" class="headerlink" title="5. 内存映射区（Memory Mapping Segment）"></a>5. <strong>内存映射区（Memory Mapping Segment）</strong></h3><ul><li><strong>内容</strong>：<ul><li>动态链接库（如 <code>.so</code> 文件）映射到此区域（<strong>数据并没有真正从磁盘加载到物理内存</strong>，它只是建立了一个<strong>虚拟地址</strong>到<strong>文件页</strong>的映射关系）。</li><li>使用 <strong><code>mmap</code></strong> 系统调用进行文件 I&#x2F;O 映射的区域。</li><li>分配<strong>大块</strong>动态内存（<code>malloc</code> 超过一定阈值时会使用 <code>mmap</code>）。</li></ul></li><li><strong>特性</strong>：灵活，可读写。</li><li><strong>增长方向</strong>：通常从高地址向低地址<strong>增长</strong>。</li></ul><h3 id="6-栈（Stack）"><a href="#6-栈（Stack）" class="headerlink" title="6. 栈（Stack）"></a>6. <strong>栈（Stack）</strong></h3><ul><li><strong>内容</strong>：用于存放<strong>局部变量</strong>、函数<strong>参数</strong>、<strong>返回值</strong>以及函数调用所需的<strong>上下文</strong>信息（如返回地址）。</li><li><strong>特性</strong>：<strong>可读写</strong>。</li><li><strong>增长方向</strong>：从高地址向低地址<strong>增长</strong>。</li><li><strong>管理</strong>：由编译器和操作系统自动管理，遵循 <strong>后进先出（LIFO）</strong> 的原则。</li></ul><hr><h2 id="内存排布和地址增长方向"><a href="#内存排布和地址增长方向" class="headerlink" title="内存排布和地址增长方向"></a>内存排布和地址增长方向</h2><p>进程的虚拟地址空间通常呈现出以下<strong>排布规律</strong>（以典型的 Linux 系统为例）：</p><ol><li><strong>内核空间（Kernel Space）</strong>：位于虚拟地址的<strong>最高端</strong>。这部分内存为操作系统内核保留，用户程序通常无法直接访问。</li><li><strong>栈（Stack）</strong>：紧挨着内核空间下方，从<strong>高地址向低地址</strong>增长。</li><li><strong>内存映射区</strong>：位于栈和堆之间，通常也从<strong>高地址向低地址</strong>增长。</li><li><strong>堆（Heap）</strong>：位于代码段和数据段上方，从<strong>低地址向高地址</strong>增长。<ul><li><strong>堆和栈的“相遇”</strong>：在设计上，堆和栈的增长方向是相反的，它们之间通常会预留一大块未映射的区域。如果堆或栈增长过快，导致它们各自的边界相遇或越过对方，就会导致内存溢出或段错误。</li></ul></li><li><strong>BSS 段 &#x2F; 数据段 &#x2F; 代码段</strong>：这三个静态区域位于虚拟地址的<strong>低端</strong>。</li></ol><h3 id="简化示意图（从低地址到高地址）"><a href="#简化示意图（从低地址到高地址）" class="headerlink" title="简化示意图（从低地址到高地址）"></a>简化示意图（从低地址到高地址）</h3><table><thead><tr><th>虚拟地址（高）</th><th>区域名称</th><th>增长方向</th><th>内存用途</th></tr></thead><tbody><tr><td>↑</td><td><strong>内核空间</strong></td><td>-</td><td>操作系统内核使用</td></tr><tr><td></td><td><strong>栈 (Stack)</strong></td><td>↓ (向低地址增长)</td><td>局部变量、函数调用</td></tr><tr><td></td><td><strong>未分配区域</strong></td><td>-</td><td>-</td></tr><tr><td></td><td><strong>内存映射区 (mmap)</strong></td><td>↓ (向低地址增长)</td><td>动态库、大块内存</td></tr><tr><td></td><td><strong>未分配区域</strong></td><td>-</td><td>-</td></tr><tr><td></td><td><strong>堆 (Heap)</strong></td><td>↑ (向高地址增长)</td><td>动态分配内存 (<code>malloc</code>)</td></tr><tr><td></td><td><strong>BSS 段</strong></td><td>-</td><td>未初始化全局&#x2F;静态变量</td></tr><tr><td></td><td><strong>数据段</strong></td><td>-</td><td>已初始化全局&#x2F;静态变量</td></tr><tr><td>↓</td><td><strong>代码段 (Text)</strong></td><td>-</td><td>程序的机器指令</td></tr><tr><td>虚拟地址（低）</td><td></td><td></td><td></td></tr></tbody></table><h3 id="按需分页（Demand-Paging）"><a href="#按需分页（Demand-Paging）" class="headerlink" title="按需分页（Demand Paging）"></a>按需分页（Demand Paging）</h3><p>真正的效率提升在于**按需分页（Demand Paging）**机制：</p><ul><li><strong>初始状态</strong>：动态库被映射后，其对应的虚拟地址并没有实际的物理内存页与之对应。</li><li><strong>首次访问</strong>：当程序第一次试图执行动态库中的某个函数或访问某个数据时，CPU 会根据虚拟地址去查找<strong>页表</strong>。此时发现该页还没有加载到物理内存，会触发一个<strong>缺页中断（Page Fault）</strong>。</li><li><strong>加载页面</strong>：操作系统内核捕获到缺页中断后，会从磁盘上的动态库文件找到对应的**页面（Page）**内容，将其加载到一个**物理内存帧**中，并更新页表，建立虚拟地址与物理地址的映射。</li><li><strong>继续执行</strong>：程序随后在中断处恢复执行，就能够顺利访问该内存了。</li></ul><h1 id="裸机（STM32）"><a href="#裸机（STM32）" class="headerlink" title="裸机（STM32）"></a>裸机（STM32）</h1><p>这是一个从通用计算机（如 Linux 进程）转移到<strong>嵌入式系统</strong>（如 <strong>STM32 微控制器</strong>）的精彩问题！</p><p>STM32 微控制器<strong>没有</strong>操作系统提供的复杂的<strong>虚拟内存</strong>机制，也没有进程的概念。它的内存布局直接对应于其<strong>物理内存</strong>和<strong>片上外设</strong>的地址空间。</p><p>STM32 的内存布局是<strong>固定</strong>的，由其内部架构（基于 ARM Cortex-M 内核）决定，主要分为以下几个关键区域：</p><hr><h2 id="STM32-微控制器的内存布局"><a href="#STM32-微控制器的内存布局" class="headerlink" title="STM32 微控制器的内存布局"></a>STM32 微控制器的内存布局</h2><p><img src="/2025/09/30/Linux%E5%92%8C%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/1.png"></p><p>STM32 采用**哈佛结构（Harvard Architecture）*<em>或*<em>改进的冯·诺依曼结构</em></em>，其中代码和数据可以分开访问。其内存空间被划分为几个主要区域，每个区域都有一个固定的地址范围。</p><h3 id="1-闪存（Flash-Memory）-CODE-区"><a href="#1-闪存（Flash-Memory）-CODE-区" class="headerlink" title="1. 闪存（Flash Memory） - CODE 区"></a>1. 闪存（Flash Memory） - CODE 区</h3><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td><strong>地址范围</strong></td><td>通常从 <code>0x0800 0000</code> 开始</td></tr><tr><td><strong>内容</strong></td><td>存放程序<strong>代码</strong>（指令）和<strong>常量数据</strong>（如字符串字面量、<code>const</code> 变量）。</td></tr><tr><td><strong>特性</strong></td><td><strong>非易失性</strong>（掉电不丢失）。这是程序烧录的主要目标区域。程序启动时，CPU 从这里取指令执行。</td></tr></tbody></table><h3 id="2-SRAM（Static-RAM）-DATA-HEAP-STACK-区"><a href="#2-SRAM（Static-RAM）-DATA-HEAP-STACK-区" class="headerlink" title="2. SRAM（Static RAM） - DATA&#x2F;HEAP&#x2F;STACK 区"></a>2. SRAM（Static RAM） - DATA&#x2F;HEAP&#x2F;STACK 区</h3><p>SRAM 是 STM32 的主要<strong>工作内存</strong>，<strong>易失性</strong>（掉电丢失）。它被细分为我们熟悉的数据、堆和栈等区域。</p><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td><strong>地址范围</strong></td><td>通常从 <code>0x2000 0000</code> 开始</td></tr><tr><td><strong>内容</strong></td><td></td></tr><tr><td><strong>数据段</strong>(<code>.data</code>)</td><td>存放<strong>已初始化</strong>的<strong>全局&#x2F;静态变量</strong>。程序启动时，这些数据会从 Flash <strong>复制</strong>到 SRAM。</td></tr><tr><td><strong>BSS 段</strong>(<code>.bss</code>)</td><td>存放<strong>未初始化</strong>的<strong>全局&#x2F;静态变量</strong>。程序启动时，这部分空间会被<strong>清零</strong>。</td></tr><tr><td><strong>堆（Heap）</strong></td><td>用于程序运行时的<strong>动态内存分配</strong>（如 <code>malloc</code>）。<strong>从低地址向高地址增长</strong>。</td></tr><tr><td><strong>栈（Stack）</strong></td><td>用于存放<strong>局部变量</strong>、函数<strong>参数</strong>和<strong>返回地址</strong>。<strong>从高地址向低地址增长</strong>。</td></tr><tr><td><strong>注意</strong></td><td>在 STM32 上，堆和栈的空间是<strong>静态预留</strong>的，在链接脚本（Linker Script）中定义它们的大小和位置。堆和栈的增长如果互相侵占，会导致程序崩溃。</td></tr></tbody></table><h3 id="3-外设（Peripherals）-外设寄存器区"><a href="#3-外设（Peripherals）-外设寄存器区" class="headerlink" title="3. 外设（Peripherals） - 外设寄存器区"></a>3. 外设（Peripherals） - 外设寄存器区</h3><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td><strong>地址范围</strong></td><td>通常从 <code>0x4000 0000</code> 或 <code>0x5000 0000</code> 开始</td></tr><tr><td><strong>内容</strong></td><td>存放所有片上<strong>外设的控制寄存器</strong>（如 GPIO、定时器、ADC 等）。</td></tr><tr><td><strong>特性</strong></td><td>程序员通过<strong>读写特定地址的内存</strong>来控制硬件。例如，向某个地址写入 <code>1</code> 就可以点亮一个 LED 灯。这就是所谓的<strong>内存映射 I&#x2F;O (MMIO)</strong>。</td></tr></tbody></table><h3 id="4-启动区域（Boot-Memory）"><a href="#4-启动区域（Boot-Memory）" class="headerlink" title="4. 启动区域（Boot Memory）"></a>4. 启动区域（Boot Memory）</h3><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td><strong>地址范围</strong></td><td>从 <code>0x0000 0000</code> 开始</td></tr><tr><td><strong>内容</strong></td><td>包含了<strong>重映射</strong>的地址。STM32 在启动时，会将这个低地址区域映射到 Flash、系统存储器（System Memory，用于 Bootloader）或 SRAM 中的某一个。</td></tr><tr><td><strong>特性</strong></td><td>决定了微控制器<strong>启动后执行的第一条指令</strong>来自哪里。</td></tr></tbody></table><hr><h2 id="与-PC-内存模型的关键区别"><a href="#与-PC-内存模型的关键区别" class="headerlink" title="与 PC 内存模型的关键区别"></a>与 PC 内存模型的关键区别</h2><table><thead><tr><th>特性</th><th>PC &#x2F; Linux 进程</th><th>STM32 &#x2F; 嵌入式系统</th></tr></thead><tbody><tr><td><strong>内存类型</strong></td><td><strong>虚拟内存</strong>（抽象层）</td><td><strong>物理内存</strong>（直接访问）</td></tr><tr><td><strong>内存管理</strong></td><td>复杂，由 OS 动态管理和分配，使用<strong>分页</strong>和<strong>页表</strong>。</td><td>简单，<strong>静态分配</strong>，内存由<strong>链接器脚本</strong>预先分配。</td></tr><tr><td><strong>动态库&#x2F;mmap</strong></td><td>大量使用 <code>mmap</code> 加载动态库，实现<strong>按需分页</strong>。</td><td>不存在动态库概念，所有代码和数据在编译时就确定了位置。</td></tr><tr><td><strong>堆&#x2F;栈</strong></td><td>堆和栈之间的空间巨大且包含 <code>mmap</code> 区。</td><td>堆和栈的空间是<strong>有限且相邻</strong>的，由链接脚本严格划分。</td></tr><tr><td><strong>外设</strong></td><td>通过系统调用或驱动访问硬件。</td><td>通过<strong>内存映射 I&#x2F;O</strong>（直接读写内存地址）来控制硬件。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> STM32 </tag>
            
            <tag> MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C11 新特性和示例代码</title>
      <link href="/2025/09/19/C11-%E6%96%B0%E7%89%B9%E6%80%A7%E5%92%8C%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/"/>
      <url>/2025/09/19/C11-%E6%96%B0%E7%89%B9%E6%80%A7%E5%92%8C%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cppreference.cn/w/c/11">参考文档</a>，还可进一步了解<a href="https://cppreference.cn/w/c/23">c23</a>（但是测试了安装的gcc和clang (2025.9.19) 编译器没有支持）</p><h2 id="对齐处理（Alignment）的标准化"><a href="#对齐处理（Alignment）的标准化" class="headerlink" title="对齐处理（Alignment）的标准化"></a>对齐处理（Alignment）的标准化</h2><h4 id="Alignas-标识符"><a href="#Alignas-标识符" class="headerlink" title="_Alignas 标识符"></a><code>_Alignas</code> 标识符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdalign.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">_Alignas</span>(<span class="number">16</span>) <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Alignment of struct S: %zu\n&quot;</span>, <span class="keyword">alignof</span>(<span class="keyword">struct</span> S));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="alignof-运算符"><a href="#alignof-运算符" class="headerlink" title="alignof 运算符"></a><code>alignof</code> 运算符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdalign.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Alignment of double: %zu\n&quot;</span>, <span class="keyword">alignof</span>(<span class="type">double</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="aligned-alloc-函数"><a href="#aligned-alloc-函数" class="headerlink" title="aligned_alloc 函数"></a><code>aligned_alloc</code> 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> alignment = <span class="number">32</span>;</span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">128</span>;</span><br><span class="line">    <span class="type">void</span>* ptr = aligned_alloc(alignment, size);</span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Aligned allocation succeeded.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="头文件"><a href="#头文件" class="headerlink" title="&lt;stdalign.h&gt; 头文件"></a><code>&lt;stdalign.h&gt;</code> 头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdalign.h&gt;</span></span></span><br><span class="line"><span class="keyword">alignas</span>(<span class="number">16</span>) <span class="type">int</span> x;</span><br></pre></td></tr></table></figure><hr><h2 id="Noreturn-函数标记"><a href="#Noreturn-函数标记" class="headerlink" title="_Noreturn 函数标记"></a><code>_Noreturn</code> 函数标记</h2><p><code>_Noreturn</code> 函数标记，类似于 gcc 的 <code>__attribute__((noreturn))</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">_Noreturn</span> <span class="type">void</span> <span class="title function_">fatal</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fatal error: %s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Generic-泛型宏关键字"><a href="#Generic-泛型宏关键字" class="headerlink" title="_Generic 泛型宏关键字"></a><code>_Generic</code> 泛型宏关键字</h2><p>字符串例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如：若x为int类型，则替换 type_name(x) 为 int 类型后面的值，即 &quot;int&quot; 这个字符串</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> type_name(x) _Generic((x), \</span></span><br><span class="line"><span class="meta">    int: <span class="string">&quot;int&quot;</span>, \</span></span><br><span class="line"><span class="meta">    float: <span class="string">&quot;float&quot;</span>, \</span></span><br><span class="line"><span class="meta">    double: <span class="string">&quot;double&quot;</span>, \</span></span><br><span class="line"><span class="meta">    default: <span class="string">&quot;other&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, type_name(<span class="number">3.14</span>)); <span class="comment">// 输出 double</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, type_name(<span class="number">42</span>));   <span class="comment">// 输出 int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“函数重载”例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo_int</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am int type !!~\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo_double</span><span class="params">(<span class="type">double</span> x)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am double type !!~\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> foo(x) _Generic(x, int : foo_int, \</span></span><br><span class="line"><span class="meta">                          double : foo_double)(x)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    foo(<span class="number">123</span>);  <span class="comment">// foo_int(123) // I am int type !!~</span></span><br><span class="line">    foo(<span class="number">1.23</span>);  <span class="comment">// foo_double(1.23) // I am double type !!~</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="多线程（Multithreading）支持"><a href="#多线程（Multithreading）支持" class="headerlink" title="多线程（Multithreading）支持"></a>多线程（Multithreading）支持</h2><p>注意：无法在 Darwin clang 环境下使用</p><h4 id="Thread-local-存储类型标识符-和-头文件"><a href="#Thread-local-存储类型标识符-和-头文件" class="headerlink" title="_Thread_local 存储类型标识符 和 &lt;threads.h&gt; 头文件"></a><code>_Thread_local</code> 存储类型标识符 和 <code>&lt;threads.h&gt;</code> 头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;threads.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITER 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">_Thread_local</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">incrementCounter</span><span class="params">(<span class="type">void</span> *thr_id)</span> &#123;</span><br><span class="line">  <span class="type">int</span> tid = (<span class="type">int</span>)thr_id;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;thread %d started incrementing ID - %lu\n&quot;</span>, tid, thrd_current());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_ITER; ++i)</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *)counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">thrd_t</span> threads[NUM_THREADS];</span><br><span class="line">  <span class="type">int</span> rc, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">    rc = thrd_create(&amp;threads[i], (<span class="type">thrd_start_t</span>)incrementCounter, (<span class="type">void</span> *)i);</span><br><span class="line">    <span class="keyword">if</span> (rc == thrd_error) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;ERORR; thrd_create() call failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> retval;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">    thrd_join(threads[i], &amp;retval);</span><br><span class="line">    sum += retval;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">  thrd_exit(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread 0 started incrementing ID - 281473108406528</span><br><span class="line">thread 3 started incrementing ID - 281472963440896</span><br><span class="line">thread 1 started incrementing ID - 281473099952384</span><br><span class="line">thread 2 started incrementing ID - 281473091498240</span><br><span class="line">count = 40000</span><br></pre></td></tr></table></figure><p>若<strong>不加</strong>的输出（各个线程在竞争数据）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread 0 started incrementing ID - 281473865281824</span><br><span class="line">thread 2 started incrementing ID - 281473848373536</span><br><span class="line">thread 1 started incrementing ID - 281473856827680</span><br><span class="line">thread 3 started incrementing ID - 281473768747296</span><br><span class="line">count = 55938</span><br></pre></td></tr></table></figure><hr><h2 id="Atomic-类型修饰符和-头文件"><a href="#Atomic-类型修饰符和-头文件" class="headerlink" title="_Atomic 类型修饰符和 &lt;stdatomic.h&gt; 头文件"></a><code>_Atomic</code> 类型修饰符和 <code>&lt;stdatomic.h&gt;</code> 头文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdatomic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">_Atomic</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    atomic_fetch_add(&amp;count, <span class="number">1</span>); <span class="comment">// 原子量加一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="增强的-Unicode-支持"><a href="#增强的-Unicode-支持" class="headerlink" title="增强的 Unicode 支持"></a>增强的 Unicode 支持</h2><h4 id="char16-t-和-char32-t"><a href="#char16-t-和-char32-t" class="headerlink" title="char16_t 和 char32_t"></a><code>char16_t</code> 和 <code>char32_t</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char16_t</span> utf16_str[] = <span class="string">u&quot;你好&quot;</span>;</span><br><span class="line"><span class="type">char32_t</span> utf32_str[] = <span class="string">U&quot;世界&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="头文件-1"><a href="#头文件-1" class="headerlink" title="&lt;uchar.h&gt; 头文件"></a><code>&lt;uchar.h&gt;</code> 头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char16_t</span> str[] = <span class="string">u&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(str));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="删除-gets-，新增-gets-s"><a href="#删除-gets-，新增-gets-s" class="headerlink" title="删除 gets()，新增 gets_s()"></a>删除 <code>gets()</code>，新增 <code>gets_s()</code></h2><ul><li><code>gets()</code> 已被删除，不再安全。</li><li><code>gets_s()</code> 是 C11 增加的安全替代：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gets_s 在部分实现中可用</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">gets_s(buf, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="边界检查函数接口（如-fopen-s、strcat-s-等）"><a href="#边界检查函数接口（如-fopen-s、strcat-s-等）" class="headerlink" title="边界检查函数接口（如 fopen_s、strcat_s 等）"></a>边界检查函数接口（如 <code>fopen_s</code>、<code>strcat_s</code> 等）</h2><p>增加了<a href="https://zh.wikipedia.org/wiki/%E8%BE%B9%E7%95%8C%E6%A3%80%E6%9F%A5">边界检查</a>函数接口，定义了新的安全的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE* fp;</span><br><span class="line">    <span class="keyword">if</span> (fopen_s(&amp;fp, <span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 成功打开</span></span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="浮点处理宏的增强"><a href="#浮点处理宏的增强" class="headerlink" title="浮点处理宏的增强"></a>浮点处理宏的增强</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;float.h&gt;</span></span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Decimal digits of precision: %d\n&quot;</span>, DECIMAL_DIG);</span><br></pre></td></tr></table></figure><p>输出：<code>Decimal digits of precision: 36</code></p><hr><h2 id="匿名结构体-联合体支持"><a href="#匿名结构体-联合体支持" class="headerlink" title="匿名结构体&#x2F;联合体支持"></a>匿名结构体&#x2F;联合体支持</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">float</span> f;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; var;</span><br><span class="line">var.i = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="静态断言（Static-Assertion）-Static-assert"><a href="#静态断言（Static-Assertion）-Static-assert" class="headerlink" title="静态断言（Static Assertion）_Static_assert"></a>静态断言（Static Assertion）<code>_Static_assert</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">_Static_assert</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) == <span class="number">4</span>, <span class="string">&quot;int must be 4 bytes&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="新的-fopen-模式（“…x”）"><a href="#新的-fopen-模式（“…x”）" class="headerlink" title="新的 fopen 模式（“…x”）"></a>新的 fopen 模式（“…x”）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;wx&quot;</span>); <span class="comment">// 仅当文件不存在才创建并写入</span></span><br></pre></td></tr></table></figure><hr><h2 id="新增-quick-exit-函数"><a href="#新增-quick-exit-函数" class="headerlink" title="新增 quick_exit() 函数"></a>新增 quick_exit() 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 仅被 quick_exit 调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    at_quick_exit(cleanup);</span><br><span class="line">    quick_exit(<span class="number">0</span>); <span class="comment">// 快速退出，不执行普通 atexit 注册的清理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> C-11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>奇异递归模板模式 CRTP</title>
      <link href="/2025/09/02/%E5%A5%87%E5%BC%82%E9%80%92%E5%BD%92%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F-CRTP/"/>
      <url>/2025/09/02/%E5%A5%87%E5%BC%82%E9%80%92%E5%BD%92%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F-CRTP/</url>
      
        <content type="html"><![CDATA[<h2 id="CRTP-的用途"><a href="#CRTP-的用途" class="headerlink" title="CRTP 的用途"></a>CRTP 的用途</h2><p>CRTP (Curiously Recurring Template Pattern) 主要用于实现<strong>静态多态</strong>。与 C++ 中常见的虚函数（virtual function）实现的动态多态不同，CRTP 在编译时解析函数调用，因此没有运行时开销。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>假设我们想创建一个通用的基类，它可以计算任何派生类的面积，只要派生类提供一个 <code>getArea()</code> 方法。</p><h3 id="例子：计算几何图形的面积"><a href="#例子：计算几何图形的面积" class="headerlink" title="例子：计算几何图形的面积"></a>例子：计算几何图形的面积</h3><p>首先，我们定义一个<strong>CRTP基类模板</strong> <code>Shape</code>。这个基类有一个方法 <code>calculateAndPrintArea()</code>，它的任务是调用派生类中实现的 <code>getArea()</code> 方法，并打印结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculateAndPrintArea</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 static_cast 将基类指针转换为派生类指针。</span></span><br><span class="line">        <span class="comment">// 这就是 CRTP 的核心：基类“知道”派生类的类型，</span></span><br><span class="line">        <span class="comment">// 从而可以静态调用派生类的成员函数。</span></span><br><span class="line">        <span class="type">const</span> Derived&amp; derived = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> Derived&amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用派生类中实现的 getArea() 方法</span></span><br><span class="line">        <span class="type">double</span> area = derived.<span class="built_in">getArea</span>();</span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The area is: &quot;</span> &lt;&lt; area &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>接下来，我们创建两个具体的<strong>派生类</strong>：<code>Circle</code> 和 <code>Rectangle</code>。它们都继承自 <code>Shape</code>，并以自己作为模板参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape&lt;Circle&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> radius) : <span class="built_in">m_radius</span>(radius) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 派生类必须实现 getArea() 方法</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14159</span> * m_radius * m_radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> m_radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape&lt;Rectangle&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">double</span> width, <span class="type">double</span> height) : <span class="built_in">m_width</span>(width), <span class="built_in">m_height</span>(height) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 派生类必须实现 getArea() 方法</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_width * m_height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> m_width;</span><br><span class="line">    <span class="type">double</span> m_height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>在 <code>main</code> 函数中，我们可以创建 <code>Circle</code> 和 <code>Rectangle</code> 对象，并直接调用基类中定义的 <code>calculateAndPrintArea()</code>方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Circle <span class="title">circle</span><span class="params">(<span class="number">5.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Rectangle <span class="title">rectangle</span><span class="params">(<span class="number">4.0</span>, <span class="number">6.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用基类的方法，但实际上会调用派生类中实现的 getArea()</span></span><br><span class="line">    circle.<span class="built_in">calculateAndPrintArea</span>();      <span class="comment">// 输出: The area is: 78.5397</span></span><br><span class="line">    rectangle.<span class="built_in">calculateAndPrintArea</span>();   <span class="comment">// 输出: The area is: 24</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么这个例子体现了-CRTP？"><a href="#为什么这个例子体现了-CRTP？" class="headerlink" title="为什么这个例子体现了 CRTP？"></a>为什么这个例子体现了 CRTP？</h3><p>在这个例子中，<code>Shape</code> 基类模板利用<strong>奇异递归模板模式</strong>实现了<strong>静态多态</strong>。</p><ol><li><p><strong>静态类型信息</strong>：当 <code>Circle</code> 继承 <code>Shape&lt;Circle&gt;</code> 时，<code>Shape</code> 类在编译时就知道了它所操作的对象类型是 <code>Circle</code>。</p></li><li><p><strong>静态绑定</strong>：在 <code>Shape::calculateAndPrintArea()</code> 方法中，<code>static_cast&lt;const Derived&amp;&gt;(*this)</code> 将 <code>Shape</code> 对象的引用转换为一个<strong>编译时已知的派生类引用</strong>。</p></li><li><p><strong>无运行时开销</strong>：<code>derived.getArea()</code> 的调用是一个<strong>普通的函数调用</strong>，而不是虚函数表查找。这使得代码在运行时更加高效。</p></li></ol><p>通过这个模式，我们为所有派生类提供了通用的接口 (<code>calculateAndPrintArea()</code>)，同时将具体实现 (<code>getArea()</code>) 留给每个派生类自己完成，所有这些都在<strong>编译时</strong>完成，没有任何运行时多态的开销。</p><hr><h3 id="进阶：与-Deducing-this-的结合"><a href="#进阶：与-Deducing-this-的结合" class="headerlink" title="进阶：与 Deducing this 的结合"></a>进阶：与 Deducing this 的结合</h3><p>在刚才的例子中，为了在基类里调用派生类的方法，我们必须显式地将 <code>this</code> 指针进行 <code>static_cast</code>，这既不美观，也增加了出错的风险。</p><p>C++<strong>23</strong> 引入了“显式 <code>this</code> 对象参数”（explicit <code>this</code> object parameter），通常称为 “Deducing <code>this</code>“。它允许你将 <code>this</code> 作为一个明确的函数参数来声明，并可以将其模板化。</p><p>它看起来像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyType</span> &#123;</span><br><span class="line">    <span class="comment">// &#x27;self&#x27; 的类型会被推导为 *this 对象的实际类型</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Self&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">my_method</span><span class="params">(<span class="keyword">this</span> Self&amp;&amp; self, <span class="comment">/* ... other args ... */</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的 <code>Self</code> 会被推导为 <code>MyType&amp;</code>, <code>const MyType&amp;</code>, <code>MyType&amp;&amp;</code>, <code>const MyType&amp;&amp;</code> 等等，完美地保留了对象的 <code>const</code>&#x2F;<code>volatile</code> 限定和值类别。</p><p>当我们将 Deducing <code>this</code> 应用于 CRTP 模式时，上述所有痛点都迎刃而解。基类的实现变得异常简洁和优雅。</p><p><strong>结合后的现代化实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Self&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculateAndPrintArea</span><span class="params">(<span class="keyword">this</span> Self&amp;&amp; self)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 直接就可调用派生类中实现的 getArea() 方法</span></span><br><span class="line">        <span class="type">double</span> area = self.<span class="built_in">getArea</span>();</span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The area is: &quot;</span> &lt;&lt; area &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="如果去掉-template-会怎样？"><a href="#如果去掉-template-会怎样？" class="headerlink" title="如果去掉 template &lt;typename Derived&gt; 会怎样？"></a>如果去掉 <code>template &lt;typename Derived&gt;</code> 会怎样？</h4><p>如果我们去掉它，代码依然是合法的，但这就不再是 CRTP 模式了。它会变成一种不同的、更简单的模式，可以称之为 <strong>“Deducing <code>this</code> Mixin”</strong>。刚才的例子就可以去掉，因为我们并没有用到它，但是有些情况下不能去掉：</p><p>因为 <code>Derived</code> 在整个类定义中都有效，所以它能做到许多 <code>Self</code> 做不到的事情。这些事情正是 CRTP 模式强大功能的核心。</p><p><strong>示例1：实现静态工厂函数或克隆</strong></p><p>基类可以定义一个创建或复制派生类实例的接口，因为它在编译期就知道 <code>Derived</code> 的具体类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Clonable</span> &#123;</span><br><span class="line">    <span class="comment">// 只有知道 Derived 类型，才能返回 Derived 对象</span></span><br><span class="line">    <span class="function">Derived <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用派生类的拷贝构造函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Derived</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> Derived&amp;&gt;(*<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态工厂函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Derived <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Derived</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyType</span> : <span class="keyword">public</span> Clonable&lt;MyType&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">MyType obj1;</span><br><span class="line">MyType obj2 = obj1.<span class="built_in">clone</span>();       <span class="comment">// 正确</span></span><br><span class="line">MyType obj3 = MyType::<span class="built_in">create</span>();   <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>如果只用 <code>deducing this</code>，<code>clone</code> 函数的返回类型无法确定为 <code>Derived</code>，因为它在函数签名中不可用。</p><p><strong>示例2：访问派生类的类型别名或静态成员</strong></p><p>基类可以访问派生类中定义的 <code>static</code> 成员或类型别名（<code>using</code> &#x2F; <code>typedef</code>）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 访问派生类的静态成员</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Component ID: &quot;</span> &lt;&lt; Derived::COMPONENT_ID &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sensor</span> : <span class="keyword">public</span> Component&lt;Sensor&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> COMPONENT_ID = <span class="number">101</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Actuator</span> : <span class="keyword">public</span> Component&lt;Actuator&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> COMPONENT_ID = <span class="number">205</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Sensor s;</span><br><span class="line">s.<span class="built_in">print_info</span>(); <span class="comment">// 输出: Component ID: 101</span></span><br></pre></td></tr></table></figure><p><code>Self</code> 是在函数调用时才具象化的实例类型，所以无法用于在<strong>函数签名之外</strong>访问类型的静态属性**（也就是说之内的话也是可以的）。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 编程技巧 </tag>
            
            <tag> CRTP </tag>
            
            <tag> 模板编程 </tag>
            
            <tag> 静态多态 </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 高级C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this auto&amp;&amp; self 详解</title>
      <link href="/2025/09/02/this-auto-self-%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/09/02/this-auto-self-%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>这句代码定义了一个类的下标操作符（<code>operator[]</code>），但它使用了两个 C++23 的新特性，使其变得非常通用和强大：</p><ol><li><p><strong>显式 <code>this</code> 参数 (<code>this auto&amp;&amp; self</code>)</strong> 即 <strong>Deducing this</strong></p></li><li><p><strong>推导返回类型 (<code>auto&amp;&amp;</code>)</strong></p></li></ol><p>让我们一步步分解来理解。</p><h3 id="核心功能：定义下标操作符"><a href="#核心功能：定义下标操作符" class="headerlink" title="核心功能：定义下标操作符 []"></a>核心功能：定义下标操作符 <code>[]</code></h3><p>首先，这句代码的本质是重载（overload）下标操作符 <code>[]</code>。这允许类的对象可以像数组一样使用方括号来访问成员。例如，如果你有一个名为 <code>MyArray</code> 的类，定义了这个操作符后，你就可以这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyArray arr;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">auto</span> value = arr[<span class="number">5</span>]; <span class="comment">// 这会调用 MyArray::operator[]</span></span><br></pre></td></tr></table></figure><h3 id="1-this-auto-self：显式-this-对象参数"><a href="#1-this-auto-self：显式-this-对象参数" class="headerlink" title="1. this auto&amp;&amp; self：显式 this 对象参数"></a>1. <code>this auto&amp;&amp; self</code>：显式 <code>this</code> 对象参数</h3><p>这是 C++23 引入的一个重要特性，被称为 “Deducing <code>this</code>“。</p><p>在<strong>传统</strong>的 C++ 中，成员函数有一个隐式的 <code>this</code> 指针，指向调用该函数的对象。你可以根据 <code>const</code> 或 <code>&amp;</code>&#x2F;<code>&amp;&amp;</code> 限定符来为不同类型的对象（<code>const</code> 对象、<a href="./%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E8%AF%A6%E8%A7%A3.md">左值对象、右值对象</a>）重载成员函数。</p><p>例如，为了同时支持 <code>arr[i]</code> 和 <code>const_arr[i]</code>，你可能需要写两个版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++23 之前</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 版本 1: non-const 左值对象</span></span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) &amp; &#123;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 版本 2: const 左值对象</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span>&amp; &#123;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可能还需要为右值对象写更多版本...</span></span><br><span class="line">    <span class="comment">// int&amp;&amp; operator[](int index) &amp;&amp;;</span></span><br><span class="line">    <span class="comment">// const int&amp;&amp; operator[](int index) const&amp;&amp;;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方式非常繁琐。</p><p><strong><code>this auto&amp;&amp; self</code></strong> 通过将隐式的 <code>this</code> 指针变成一个显式的、可推导的函数参数，完美地解决了这个问题。</p><ul><li><p><strong><code>this</code></strong>: 关键字，表明这个参数是用来捕获 <code>*this</code> 对象（即调用该成员函数的对象实例）的。</p></li><li><p><strong><code>auto&amp;&amp;</code></strong>: 这是个“转发 (forward) 引用”或“通用引用”。它可以接收任何类型的对象（<code>const</code>、<code>non-const</code>、左值、右值），并保持其原始的类型和值类别（value category）。</p></li><li><p><strong><code>self</code></strong>: 这是我们给这个参数起的<em>名字</em>，就像普通的函数参数一样。</p></li></ul><p><strong><code>self</code> 的类型会根据调用对象的状态自动推导：</strong></p><table><thead><tr><th>如果这样调用…</th><th><code>self</code> 的类型会被推导为…</th></tr></thead><tbody><tr><td><code>MyArray arr; arr[0];</code></td><td><code>MyArray&amp;</code> (左值引用)</td></tr><tr><td><code>const MyArray arr; arr[0];</code></td><td><code>const MyArray&amp;</code> (<code>const</code> 左值引用)</td></tr><tr><td><code>MyArray{}; arr[0];</code></td><td><code>MyArray&amp;&amp;</code> (右值引用)</td></tr><tr><td><code>const MyArray{}; arr[0];</code></td><td><code>const MyArray&amp;&amp;</code> (<code>const</code> 右值引用)</td></tr></tbody></table><p>这样，你<strong>只需要写一个函数</strong>，编译器就会自动为你处理所有情况，极大地简化了代码。</p><h3 id="2-auto-：推导返回类型"><a href="#2-auto-：推导返回类型" class="headerlink" title="2. auto&amp;&amp;：推导返回类型"></a>2. <code>auto&amp;&amp;</code>：推导返回类型</h3><p>这里的 <code>auto&amp;&amp;</code> 作为返回类型，同样是一个“转发引用”。它的作用是<strong>完美转发</strong>（perfectly forward）<code>self</code> 对象内部的数据成员。</p><ul><li><p><strong>目标</strong>: <code>operator[]</code> 的返回值类型应该与 <code>self</code> 的类型相匹配。</p><ul><li><p>如果 <code>self</code> 是 <code>const</code> 的，返回的也应该是 <code>const</code> 引用。</p></li><li><p>如果 <code>self</code> 是 <code>non-const</code> 的，返回的应该是 <code>non-const</code> 引用，这样我们才能修改它（例如 <code>arr[0] = 100;</code>）。</p></li><li><p>如果 <code>self</code> 是一个右值（临时对象），我们可能希望返回一个右值引用。</p></li></ul></li></ul><p><code>auto&amp;&amp;</code> 配合 <code>std::forward</code> 就能轻松实现这一点。</p><h3 id="完整示例与解释"><a href="#完整示例与解释" class="headerlink" title="完整示例与解释"></a>完整示例与解释</h3><p>下面是一个完整的例子，展示了这句代码在实际类中的应用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// for std::forward</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// C++23 的统一下标操作符</span></span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; <span class="keyword">operator</span>[](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> index) &#123;</span><br><span class="line">        <span class="comment">// self 会被推导为 MyArray&amp;, const MyArray&amp;, MyArray&amp;&amp; 等</span></span><br><span class="line">        <span class="comment">// 我们使用 std::forward 来保持 self 的值类别</span></span><br><span class="line">        <span class="comment">// 并返回其内部 data 成员的相应引用类型</span></span><br><span class="line">        <span class="keyword">return</span> std::forward&lt;<span class="keyword">decltype</span>(self)&gt;(self).data[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyArray&lt;<span class="type">int</span>, <span class="number">5</span>&gt; arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. non-const 左值对象: self 推导为 MyArray&amp;</span></span><br><span class="line">    <span class="comment">// 返回类型为 int&amp;，可以修改</span></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;arr[0] = &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. const 左值对象: self 推导为 const MyArray&amp;</span></span><br><span class="line">    <span class="comment">// 返回类型为 const int&amp;，不能修改</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; const_arr = arr;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;const_arr[0] = &quot;</span> &lt;&lt; const_arr[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// const_arr[0] = 20; // 这行会编译错误，符合预期</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 右值（临时）对象: self 推导为 MyArray&amp;&amp;</span></span><br><span class="line">    <span class="comment">// 返回类型为 int&amp;&amp;</span></span><br><span class="line">    <span class="keyword">auto</span> value = MyArray&lt;<span class="type">int</span>, <span class="number">5</span>&gt;&#123;&#125;[<span class="number">0</span>]; <span class="comment">// 从一个临时对象取值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value from temporary = &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><p><code>std::forward&lt;decltype(self)&gt;(self)</code> 是关键。它确保如果 <code>self</code> 是一个左值引用（<code>MyArray&amp;</code>），那么 <code>self.data[index]</code> 也会被当作左值返回（类型为 <code>int&amp;</code>）。如果 <code>self</code> 是一个右值引用（<code>MyArray&amp;&amp;</code>），那么 <code>self.data[index]</code> 也会被当作右值返回（类型为 <code>int&amp;&amp;</code>）。</p></li><li><p><code>decltype(self)</code> 获取 <code>self</code> 被推导出的精确类型。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这句 <code>auto&amp;&amp; operator[](this auto&amp;&amp; self, int index)</code> 是 C++23 中一种极其现代、简洁且强大的方式来定义类的下标操作符。</p><p><strong>它的核心意思是：</strong></p><blockquote><p><strong>“定义一个通用的下标操作符，它能接受任何类型（<code>const</code>、<code>non-const</code>、左值、右值）的对象实例。它会根据调用对象的类型，自动推导出最合适的返回类型（<code>T&amp;</code>, <code>const T&amp;</code>, <code>T&amp;&amp;</code>等），从而允许我们用一套代码完美地处理所有情况，无论是读取、修改还是从临时对象中取值。”</strong></p></blockquote><p>它通过将 <code>this</code> 显式化和利用类型推导，彻底解决了旧版本 C++ 中需要为不同对象状态编写多个重载版本的繁琐问题。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++23 </tag>
            
            <tag> 显式this </tag>
            
            <tag> 新特性 </tag>
            
            <tag> 操作符重载 </tag>
            
            <tag> 现代C++ </tag>
            
            <tag> 语法特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用包装器</title>
      <link href="/2025/09/02/%E5%BC%95%E7%94%A8%E5%8C%85%E8%A3%85%E5%99%A8/"/>
      <url>/2025/09/02/%E5%BC%95%E7%94%A8%E5%8C%85%E8%A3%85%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><code>std::reference_wrapper</code> 是 C++ 标准库 <code>&lt;functional&gt;</code> 头文件中的一个类模板，它的主要作用是<strong>将引用包装成一个可拷贝、可赋值的对象</strong>。</p><h3 id="什么是-std-reference-wrapper？"><a href="#什么是-std-reference-wrapper？" class="headerlink" title="什么是 std::reference_wrapper？"></a>什么是 <code>std::reference_wrapper</code>？</h3><p>在 C++ 中，引用（reference）本身不能被重新赋值，也不能作为容器的元素，因为它们不符合大多数标准库容器和算法对**可拷贝（Copyable）<strong>或</strong>可赋值（Assignable）**的要求。</p><p><code>std::reference_wrapper&lt;T&gt;</code> 解决了这个问题。它内部持有一个 <code>T</code> 类型的引用，但它本身是一个对象，可以像普通对象一样被拷贝和赋值。当你拷贝一个 <code>std::reference_wrapper</code> 对象时，你拷贝的是对<strong>同一个</strong>原始对象的引用，而不是拷贝原始对象本身。</p><h3 id="为什么需要它？"><a href="#为什么需要它？" class="headerlink" title="为什么需要它？"></a>为什么需要它？</h3><p><code>std::reference_wrapper</code> 的主要用途是<strong>让引用能够与标准库容器和算法协同工作</strong>。</p><p>许多标准库组件，比如 <code>std::vector</code>、<code>std::list</code>、<code>std::thread</code>、<code>std::sort</code> 等，要求其操作的对象是可拷贝的。如果你直接尝试将引用放入这些容器或传递给这些函数，编译器会报错。</p><p>例如，下面的代码无法编译，因为 <code>std::vector</code> 不允许存储引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例：不能直接存储引用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// std::vector&lt;int&amp;&gt; my_vec; // 编译错误！</span></span><br></pre></td></tr></table></figure><p>通过使用 <code>std::reference_wrapper</code>，你可以绕过这个限制，将引用“伪装”成一个可存储在容器中的对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// 必须包含此头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// std::vector&lt;std::reference_wrapper&lt;int&gt;&gt; 允许存储对 int 对象的引用</span></span><br><span class="line">    std::vector&lt;std::reference_wrapper&lt;<span class="type">int</span>&gt;&gt; my_vec;</span><br><span class="line">    </span><br><span class="line">    my_vec.<span class="built_in">push_back</span>(std::<span class="built_in">ref</span>(a)); <span class="comment">// std::ref 是一个辅助函数，用于创建 std::reference_wrapper</span></span><br><span class="line">    my_vec.<span class="built_in">push_back</span>(std::<span class="built_in">ref</span>(b));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改容器中的第一个元素，实际上是修改了原始变量 a</span></span><br><span class="line">    my_vec[<span class="number">0</span>].<span class="built_in">get</span>() = <span class="number">100</span>; <span class="comment">// 使用 .get() 来获取被包装的引用</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original value of a: &quot;</span> &lt;&lt; a &lt;&lt; std::endl; <span class="comment">// 输出: Original value of a: 100</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original value of b: &quot;</span> &lt;&lt; b &lt;&lt; std::endl; <span class="comment">// 输出: Original value of b: 20</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>std::ref</code> 和 <code>std::cref</code> 辅助函数：</strong></p><p>为了方便使用，C++ 标准库提供了两个辅助函数：</p><ul><li><p><code>std::ref(T&amp; obj)</code>：创建一个 <code>std::reference_wrapper&lt;T&gt;</code> 对象。</p></li><li><p><code>std::cref(const T&amp; obj)</code>：创建一个 <code>std::reference_wrapper&lt;const T&gt;</code> 对象，用于常量引用。</p></li></ul><h3 id="std-reference-wrapper-的常见用途"><a href="#std-reference-wrapper-的常见用途" class="headerlink" title="std::reference_wrapper 的常见用途"></a><code>std::reference_wrapper</code> 的常见用途</h3><ul><li><p><strong>容器存储引用：</strong> 如上例所示，将引用放入 <code>std::vector</code>、<code>std::map</code> 等容器中。</p></li><li><p><strong>多线程传递可变对象：</strong> 当使用 <code>std::thread</code> 启动新线程时，如果你希望线程函数能够修改一个外部变量，你需要通过 <code>std::ref</code> 传递引用。直接传递变量会发生拷贝。</p></li><li><p><strong>泛型编程与算法：</strong> 在使用如 <code>std::bind</code> 或 <code>std::sort</code> 等算法时，如果你想让它们操作原始对象而不是拷贝，<code>std::reference_wrapper</code> 是一个重要的工具。</p></li></ul><p><strong>例子：<code>std::sort</code> 的应用</strong></p><p>假设你有一个自定义对象的向量，你想根据其中一个成员变量对它们进行排序，但你不想拷贝整个对象。你可以创建一个存储 <code>std::reference_wrapper</code> 的向量来对原始对象进行间接排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="built_in">MyObject</span>(<span class="type">int</span> i, <span class="type">const</span> std::string&amp; n) : <span class="built_in">id</span>(i), <span class="built_in">name</span>(n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;MyObject&gt; objs;</span><br><span class="line">    objs.<span class="built_in">emplace_back</span>(<span class="number">2</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">    objs.<span class="built_in">emplace_back</span>(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">    objs.<span class="built_in">emplace_back</span>(<span class="number">3</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个包含对原始对象引用的向量</span></span><br><span class="line">    std::vector&lt;std::reference_wrapper&lt;MyObject&gt;&gt; refs;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; obj : objs) &#123;</span><br><span class="line">        refs.<span class="built_in">push_back</span>(std::<span class="built_in">ref</span>(obj));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 sort 对引用进行排序，比较器通过 .get() 访问原始对象</span></span><br><span class="line">    std::<span class="built_in">sort</span>(refs.<span class="built_in">begin</span>(), refs.<span class="built_in">end</span>(), [](<span class="type">const</span> std::reference_wrapper&lt;MyObject&gt;&amp; a, <span class="type">const</span> std::reference_wrapper&lt;MyObject&gt;&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">get</span>().id &lt; b.<span class="built_in">get</span>().id;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原始向量 objs 保持不变，但 refs 向量已经排序</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted references:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ref : refs) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; ref.<span class="built_in">get</span>().id &lt;&lt; <span class="string">&quot;, Name: &quot;</span> &lt;&lt; ref.<span class="built_in">get</span>().name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p><code>std::reference_wrapper</code> 是一种“引用对象”，它解决了 C++ 中引用不能被拷贝、不能被赋值、不能作为容器元素的问题。它的核心价值在于<strong>让引用能够无缝地融入 C++ 标准库的容器和算法生态系统</strong>，从而在需要传递引用而非拷贝时提供了强大的支持。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
            <tag> 引用包装器 </tag>
            
            <tag> 标准库 </tag>
            
            <tag> 容器 </tag>
            
            <tag> 泛型编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动语义</title>
      <link href="/2025/09/02/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/"/>
      <url>/2025/09/02/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h2 id="C-移动语义：深入解析核心概念与优势"><a href="#C-移动语义：深入解析核心概念与优势" class="headerlink" title="C++ 移动语义：深入解析核心概念与优势"></a>C++ 移动语义：深入解析核心概念与优势</h2><p>在 C++11 标准中，<strong>移动语义 (Move Semantics)</strong> 是一项革命性的新增特性，其核心思想在于<strong>避免不必要的内存拷贝</strong>，通过“窃取”或“转移”资源的所有权来提升程序性能。这在处理大型数据结构，如容器、字符串或任何持有动态分配内存的类时，效果尤为显著。</p><h3 id="为何需要移动语义？问题的根源：深拷贝"><a href="#为何需要移动语义？问题的根源：深拷贝" class="headerlink" title="为何需要移动语义？问题的根源：深拷贝"></a>为何需要移动语义？问题的根源：深拷贝</h3><p>在 C++11 之前，对象的复制是通过<strong>拷贝构造函数</strong>和<strong>拷贝赋值运算符</strong>完成的。当对象内部含有指针，指向动态分配的资源（如堆内存）时，为了确保新旧对象各自拥有一份独立的资源，必须进行<strong>深拷贝</strong>。</p><p>例如，考虑一个简单的字符串类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* s = <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        size_ = <span class="built_in">strlen</span>(s);</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">char</span>[size_ + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data_, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数 (深拷贝)</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">char</span>[size_ + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data_, other.data_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data_;</span><br><span class="line">    <span class="type">size_t</span> size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>深拷贝的问题在于，当源对象是一个**临时对象（右值）**时，这种拷贝就显得非常浪费。临时对象在表达式结束后就会被立即销毁，我们花费了大量资源去复制它，然后又马上释放这些资源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyString <span class="title">a</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">MyString <span class="title">b</span><span class="params">(a)</span></span>; <span class="comment">// 调用拷贝构造函数，有必要</span></span><br><span class="line"><span class="function">MyString <span class="title">c</span><span class="params">(MyString(<span class="string">&quot;World&quot;</span>))</span></span>; <span class="comment">// 调用拷贝构造函数，但源对象是临时对象，拷贝是浪费</span></span><br></pre></td></tr></table></figure><p>在第三行中，<code>MyString(&quot;World&quot;)</code> 创建了一个临时对象，它的内容被深拷贝到 <code>c</code> 中，然后这个临时对象被销assed，其内部的 <code>data_</code> 被释放。如果能直接将临时对象的 <code>data_</code> “转移”给 <code>c</code>，就可以避免这次昂贵的内存分配和拷贝。</p><h3 id="核心概念：右值引用-Rvalue-Reference"><a href="#核心概念：右值引用-Rvalue-Reference" class="headerlink" title="核心概念：右值引用 (Rvalue Reference)"></a>核心概念：右值引用 (Rvalue Reference)</h3><p>为了解决上述问题，C++11 引入了<strong>右值引用</strong>，其语法为 <code>T&amp;&amp;</code>。右值引用专门用于“绑定”到右值（临时对象、函数返回值等）。</p><ul><li><p><strong>左值 (Lvalue)</strong>：可以出现在赋值语句左侧的表达式，通常拥有持久的内存地址，可以被取地址。例如，变量名。</p></li><li><p><strong>右值 (Rvalue)</strong>：只能出现在赋值语句右侧的表达式，通常是临时的，即将消亡。例如，字面量、函数返回的临时对象。</p></li></ul><p>通过重载接受右值引用的函数，我们就可以区分出传递的是左值还是右值，并为右值提供一种不同的、更高效的处理方式。</p><h3 id="实现移动语义：移动构造函数与移动赋值运算符"><a href="#实现移动语义：移动构造函数与移动赋值运算符" class="headerlink" title="实现移动语义：移动构造函数与移动赋值运算符"></a>实现移动语义：移动构造函数与移动赋值运算符</h3><p>移动语义主要通过两个特殊的成员函数来实现：</p><ol><li><p><strong>移动构造函数 (Move Constructor)</strong></p></li><li><p><strong>移动赋值运算符 (Move Assignment Operator)</strong></p></li></ol><p>它们的参数都是一个<strong>右值引用</strong>。其核心逻辑是“窃取”源对象的资源，并将源对象置于一个有效的、可析构的状态（通常是将其内部指针设为 <code>nullptr</code>）。</p><p>为 <code>MyString</code> 类添加移动构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动构造函数</span></span><br><span class="line"><span class="built_in">MyString</span>(MyString&amp;&amp; other) <span class="keyword">noexcept</span> &#123; <span class="comment">// noexcept 很重要</span></span><br><span class="line">    <span class="comment">// 1. 窃取资源</span></span><br><span class="line">    data_ = other.data_;</span><br><span class="line">    size_ = other.size_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将源对象置于有效状态</span></span><br><span class="line">    other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    other.size_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，当用一个右值初始化 <code>MyString</code> 对象时，编译器会优先选择移动构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyString <span class="title">c</span><span class="params">(MyString(<span class="string">&quot;World&quot;</span>))</span></span>; <span class="comment">// 调用移动构造函数，非常高效</span></span><br></pre></td></tr></table></figure><p>这个过程没有新的内存分配，也没有数据拷贝，仅仅是几个指针的赋值操作。</p><h3 id="std-move：将左值转换为右值"><a href="#std-move：将左值转换为右值" class="headerlink" title="std::move：将左值转换为右值"></a><code>std::move</code>：将左值转换为右值</h3><p>有时候，我们希望强制对一个左值（例如一个即将不再使用的具名变量）也进行移动操作。这时就需要使用 <code>std::move</code>。</p><p><code>std::move</code> 本身<strong>并不执行任何移动操作</strong>，它的唯一作用是<strong>将一个左值强制转换为右值引用</strong>，从而让编译器能够调用移动构造函数或移动赋值运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// MyString s2(s1); // 调用拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我确定 s1 不再需要了，可以安全地移动它的资源</span></span><br><span class="line"><span class="function">MyString <span class="title">s2</span><span class="params">(std::move(s1))</span></span>; <span class="comment">// 调用移动构造函数，s1 的资源被转移给 s2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时，s1 内部的 data_ 已经为 nullptr，处于有效但不可用的状态</span></span><br></pre></td></tr></table></figure><p><strong>警告</strong>：在使用 <code>std::move</code> 之后，必须假定原始对象（上例中的 <code>s1</code>）的状态是未知的，不应再使用它，除非重新给它赋值。</p><h3 id="移动语义的优势"><a href="#移动语义的优势" class="headerlink" title="移动语义的优势"></a>移动语义的优势</h3><ol><li><p><strong>性能提升</strong>：通过避免不必要的深拷贝和内存分配，极大地提高了涉及资源转移场景的运行效率。</p></li><li><p><strong>资源所有权的清晰转移</strong>：使得资源（如文件句柄、网络套接字、智能指针 <code>std::unique_ptr</code>）的独占所有权模型得以实现。<code>std::unique_ptr</code> 禁止拷贝，但允许移动，就是移动语义的最佳实践之一。</p></li><li><p><strong>标准库的广泛应用</strong>：C++ 标准库中的许多组件，如 <code>std::vector</code>, <code>std::string</code>, <code>std::thread</code> 等都充分利用了移动语义。例如，当 <code>std::vector</code> 空间不足需要扩容时，如果其元素类型支持移动，它会移动旧内存中的元素到新内存，而不是逐一拷贝，从而显著优化性能。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>C++ 移动语义是现代C++编程的基石之一。它通过引入右值引用，并配合移动构造函数和移动赋值运算符，允许编译器在适当的时候（当源对象是即将消亡的右值时）选择“资源转移”而非“资源拷贝”。<code>std::move</code> 则为开发者提供了手动触发这种优化的能力。深刻理解并正确使用移动语义，是编写高效、现代的C++代码的关键。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 现代C++ </tag>
            
            <tag> 内存管理 </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> 移动语义 </tag>
            
            <tag> 右值引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左值和右值详解</title>
      <link href="/2025/09/02/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/09/02/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>C++ 的左值（lvalue）和右值（rvalue）是 C++ 语言中一个非常基础但又极其重要的概念。它们是 C++ 表达式（expression）的两种基本属性，深刻地影响着代码的性能和写法，尤其是在 C++11 标准引入“移动语义”（Move Semantics）之后。</p><p>简单来说，区分左值和右值的核心标准是：<strong>这个表达式所代表的数据，我们还能不能在后面的代码里再次访问到它。</strong></p><ul><li><p><strong>左值 (lvalue - locator value)</strong>：指那些在内存中<strong>有固定地址</strong>、<strong>可以被取地址</strong>（用 <code>&amp;</code> 运算符）并且<strong>在表达式结束后依然存在</strong>的表达式。你可以把它想象成一个有名字、有固定地址的“容器”。</p></li><li><p><strong>右值 (rvalue - read value)</strong>：指那些<strong>临时的</strong>、<strong>没有固定地址</strong>、在表达式结束后就会被销毁的表达式。你只能读取它的值，但不能对它取地址（通常情况下）。可以把它看作一个“即用即弃”的临时数据。</p></li></ul><hr><h3 id="从“赋值操作符”的左右看起（经典-C-98-时代）"><a href="#从“赋值操作符”的左右看起（经典-C-98-时代）" class="headerlink" title="从“赋值操作符”的左右看起（经典 C++98 时代）"></a>从“赋值操作符”的左右看起（经典 C++98 时代）</h3><p>在 C++ 的早期，最简单的区分方法是看它能否出现在赋值操作符 <code>=</code> 的左边：</p><ul><li><p><strong>能放在 <code>=</code> 左边的，就是左值。</strong> 因为放在左边意味着你要给它赋值，它必须有一个明确的、持久的存储位置。</p></li><li><p><strong>不能放在 <code>=</code> 左边的，就是右值。</strong> 因为它们是临时的，给一个即将销毁的东西赋值是毫无意义的。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>; <span class="comment">// &#x27;a&#x27; 是左值，因为它有内存地址，我们可以反复使用它。&#x27;10&#x27; 是右值，它是一个字面量，没有固定地址。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>; <span class="comment">// &#x27;b&#x27; 是左值。</span></span><br><span class="line"></span><br><span class="line">a = b;      <span class="comment">// 正确：&#x27;a&#x27; 和 &#x27;b&#x27; 都是左值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的都是错误的，因为等号左边不是一个合法的左值</span></span><br><span class="line"><span class="comment">// 10 = a;         // 错误！10 是一个右值（字面量）。</span></span><br><span class="line"><span class="comment">// (a + b) = 30;   // 错误！(a + b) 的计算结果是一个临时值，是右值。</span></span><br></pre></td></tr></table></figure><p><strong>常见的左值：</strong></p><ul><li><p>变量名 (<code>a</code>, <code>b</code>)</p></li><li><p>数组元素 (<code>arr[0]</code>)</p></li><li><p>返回左值引用的函数调用 (<code>get_a_reference()</code>)</p></li><li><p>解引用的指针 (<code>*p</code>)</p></li></ul><p><strong>常见的右值：</strong></p><ul><li><p>字面量 (<code>10</code>, <code>true</code>, <code>&#39;c&#39;</code>)</p></li><li><p>算术表达式的结果 (<code>a + b</code>)</p></li><li><p>返回非引用类型的函数返回值 (<code>get_a_value()</code>)</p></li><li><p>Lambda 表达式</p></li></ul><hr><h3 id="C-11-的革命：右值引用的诞生与移动语义"><a href="#C-11-的革命：右值引用的诞生与移动语义" class="headerlink" title="C++11 的革命：右值引用的诞生与移动语义"></a>C++11 的革命：右值引用的诞生与<a href="%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89.md">移动语义</a></h3><p>到了 C++11 标准，情况变得更加有趣和重要。为了解决临时对象产生的深拷贝（deep copy）带来的巨大性能开销，C++11 引入了<strong>右值引用（Rvalue Reference）和移动语义（Move Semantics）</strong>。</p><hr><h3 id="三、现代-C-的值类别（C-11-及以后）"><a href="#三、现代-C-的值类别（C-11-及以后）" class="headerlink" title="三、现代 C++ 的值类别（C++11 及以后）"></a>三、现代 C++ 的值类别（C++11 及以后）</h3><p>为了更精确地描述表达式的属性，C++11 以后将值的类别划分得更细，分为五个类别：</p><ol><li><p><strong>左值 (lvalue)</strong>: 传统的左值，有固定身份和位置。</p></li><li><p><strong>纯右值 (prvalue - pure rvalue)</strong>: 传统的右值，比如字面量 <code>10</code>、<code>true</code>，以及函数返回的非引用临时对象。它们是“纯粹”的值，不与任何具体对象相关联。</p></li><li><p><strong>将亡值 (xvalue - expiring value)</strong>: 这是 C++11 新增的概念。它代表那些生命周期即将结束的对象，通常是 <code>std::move</code> 的结果或返回右值引用的函数调用。它虽然像右值一样资源可以被窃取，但它又和某个具体的对象（曾经是左值）相关联。</p></li></ol><p>这五个类别之间有如下关系：</p><ul><li><p><strong>广义左值 (glvalue - generalized lvalue)</strong> &#x3D; <strong>左值</strong> + <strong>将亡值</strong>。（表示有身份的对象）</p></li><li><p><strong>右值 (rvalue)</strong> &#x3D; <strong>纯右值</strong> + <strong>将亡值</strong>。（表示可以被移动的对象）</p></li></ul><p>对大多数开发者而言，你不需要每天都去记忆这五个类别的精确定义。你只需要理解核心思想：</p><ul><li><p><strong>左值</strong>：有名字、能取地址、持久的对象。</p></li><li><p><strong>右值</strong>：临时的、即将销毁的、可以被“移动”的对象。</p></li><li><p><strong><code>std::move</code></strong>：一个“授权”，允许编译器将一个左值当作右值来处理，以便触发移动语义。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>特性</th><th>左值 (lvalue)</th><th>右值 (rvalue)</th></tr></thead><tbody><tr><td><strong>核心含义</strong></td><td>持久的对象，有固定内存地址</td><td>临时的值，表达式结束后即销毁</td></tr><tr><td><strong>能否取地址 (<code>&amp;</code>)</strong></td><td>可以</td><td>通常不可以（将亡值是例外）</td></tr><tr><td><strong>能否在 <code>=</code> 左边</strong></td><td>可以</td><td>不可以</td></tr><tr><td><strong>绑定到引用类型</strong></td><td>左值引用 (<code>T&amp;</code>)</td><td>右值引用 (<code>T&amp;&amp;</code>)</td></tr><tr><td><strong>与性能的关系</strong></td><td>通常涉及拷贝（Copy）</td><td>允许移动（Move），性能更高</td></tr><tr><td><strong>典型例子</strong></td><td>变量名、数组元素</td><td>字面量、表达式结果、<code>std::move</code>的结果</td></tr></tbody></table><p>理解左值和右值的区别是掌握现代 C++ 内存管理和性能优化的关键。它不仅是理论知识，更是编写高效、优雅代码的基石。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 编程基础 </tag>
            
            <tag> 现代C++ </tag>
            
            <tag> 内存管理 </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合和聚合的区别</title>
      <link href="/2025/09/02/%E7%BB%84%E5%90%88%E5%92%8C%E8%81%9A%E5%90%88%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/09/02/%E7%BB%84%E5%90%88%E5%92%8C%E8%81%9A%E5%90%88%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h3><p>组合是一种<strong>强拥有</strong>关系，表示“部分”是“整体”的<strong>生命周期的一部分</strong>。如果整体被销毁，那么它的所有部分也会被自动销毁。</p><p>可以把组合想象成一个房子和它的墙壁。你不能把墙壁从房子里拿出来，让它们独立存在。如果房子被拆除，墙壁也就不复存在了。</p><p><strong>主要特点：</strong></p><ul><li><p><strong>强生命周期依赖：</strong> 部分对象的生命周期由整体对象控制。</p></li><li><p><strong>独占拥有：</strong> 一个部分只能属于一个整体。</p></li><li><p><strong>创建关系：</strong> 通常，整体对象负责创建其部分对象。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分类：引擎</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Engine</span>(std::string t) : <span class="built_in">type</span>(t) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Engine (&quot;</span> &lt;&lt; type &lt;&lt; <span class="string">&quot;) created.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Engine</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Engine (&quot;</span> &lt;&lt; type &lt;&lt; <span class="string">&quot;) destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体类：汽车</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 组合关系：Car 拥有一个 Engine 对象</span></span><br><span class="line">    <span class="comment">// Engine 对象的生命周期由 Car 控制</span></span><br><span class="line">    Engine engine;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Car 构造函数负责创建 Engine 对象</span></span><br><span class="line">    <span class="built_in">Car</span>(std::string engine_type) : <span class="built_in">engine</span>(engine_type) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Car created.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Car</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Car destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// Engine 对象在 Car 析构时自动销毁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">myCar</span><span class="params">(<span class="string">&quot;V8&quot;</span>)</span></span>; </span><br><span class="line">    <span class="comment">// 当 myCar 对象离开作用域或被销毁时，它所拥有的 Engine 对象也会被销毁。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Engine (V8) created.</span><br><span class="line">Car created.</span><br><span class="line">Car destroyed.</span><br><span class="line">Engine (V8) destroyed.</span><br></pre></td></tr></table></figure><hr><h3 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h3><p>聚合是一种<strong>弱拥有</strong>关系，表示“部分”可以<strong>独立于</strong>“整体”存在。即使整体被销毁，部分仍然可以继续存在。</p><p>可以把聚合想象成一个部门和它的员工。员工可以加入或离开一个部门，但他们仍然是独立的个体。即使部门解散了，员工并不会消失。</p><p><strong>主要特点：</strong></p><ul><li><p><strong>弱生命周期依赖：</strong> 部分对象的生命周期不依赖于整体对象。</p></li><li><p><strong>共享拥有：</strong> 一个部分可以被多个整体共享。</p></li><li><p><strong>引用关系：</strong> 通常通过指针或引用来建立关系。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分类：员工</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Employee</span>(std::string n) : <span class="built_in">name</span>(n) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Employee (&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;) created.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Employee</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Employee (&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;) destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体类：部门</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 聚合关系：Department 包含指向 Employee 对象的指针</span></span><br><span class="line">    <span class="comment">// Department 不拥有 Employee 对象的生命周期</span></span><br><span class="line">    std::vector&lt;Employee*&gt; employees;</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Department</span>(std::string n) : <span class="built_in">name</span>(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEmployee</span><span class="params">(Employee* emp)</span> </span>&#123;</span><br><span class="line">        employees.<span class="built_in">push_back</span>(emp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Department</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Department (&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;) destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 注意：Department 析构时，不会销毁 Employee 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Employee 对象独立创建，其生命周期不受 Department 控制</span></span><br><span class="line">    Employee* emp1 = <span class="keyword">new</span> <span class="built_in">Employee</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    Employee* emp2 = <span class="keyword">new</span> <span class="built_in">Employee</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Department <span class="title">sales_dept</span><span class="params">(<span class="string">&quot;Sales&quot;</span>)</span></span>;</span><br><span class="line">        sales_dept.<span class="built_in">addEmployee</span>(emp1);</span><br><span class="line">        sales_dept.<span class="built_in">addEmployee</span>(emp2);</span><br><span class="line">    &#125; <span class="comment">// sales_dept 离开作用域，被销毁，但 emp1 和 emp2 仍然存在</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时，部门对象已经销毁，但员工对象仍然存在</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Alice&#x27;s status: Still exists.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 必须手动释放 Employee 对象</span></span><br><span class="line">    <span class="keyword">delete</span> emp1;</span><br><span class="line">    <span class="keyword">delete</span> emp2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Employee (Alice) created.</span><br><span class="line">Employee (Bob) created.</span><br><span class="line">Department (Sales) destroyed.</span><br><span class="line">Alice&#x27;s status: Still exists.</span><br><span class="line">Employee (Alice) destroyed.</span><br><span class="line">Employee (Bob) destroyed.</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>特性</th><th>组合（Composition）</th><th>聚合（Aggregation）</th></tr></thead><tbody><tr><td><strong>关系</strong></td><td>“部分”是“整体”的一部分</td><td>“部分”<strong>是</strong>一个“整体”的成员</td></tr><tr><td><strong>生命周期</strong></td><td>强依赖，整体销毁部分也销毁</td><td>弱依赖，整体销毁部分可继续存在</td></tr><tr><td><strong>拥有关系</strong></td><td>独占拥有</td><td>共享拥有</td></tr><tr><td><strong>实现方式</strong></td><td>通常是成员变量</td><td>通常是指针或引用成员变量</td></tr><tr><td><strong>类比</strong></td><td>房子和墙壁</td><td>部门和员工</td></tr><tr><td><strong>适用场景</strong></td><td>当部分没有整体就无意义时</td><td>当部分可以独立存在或被共享时</td></tr></tbody></table><p>在实际编程中，区分这两种关系对于正确管理内存和设计类之间的耦合至关重要。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本基础</title>
      <link href="/2025/08/25/Shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/08/25/Shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>注意：在本文中，不以 <code> #!/bin/bash</code> 开头的代码均为伪代码或命令，仅供示意。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 上面一行称为 shabang，为的是直接执行脚本的时候能使用正确的解释器</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, world!&quot;</span></span><br></pre></td></tr></table></figure><p>使用以下命令来检查语法错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -n ./xxx.sh</span><br></pre></td></tr></table></figure><p>没有错误将不会有任何输出，执行脚本可以通过以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash ./xxx.sh <span class="comment"># 直接指定解释器来执行</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="built_in">chmod</span> +x ./xxx.sh &amp;&amp; ./xxx.sh <span class="comment"># 把脚本赋予可执行权限后直接执行</span></span><br></pre></td></tr></table></figure><h2 id="使用变量和注释"><a href="#使用变量和注释" class="headerlink" title="使用变量和注释"></a>使用变量和注释</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一个注释，不会被执行</span></span><br></pre></td></tr></table></figure><p>获取变量的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASH</span> <span class="comment"># &#x27;$&#x27;加变量名用于获取变量值</span></span><br><span class="line"><span class="comment"># 全大写的一般为系统变量，用户自行定义的变量一般写成全小写形式</span></span><br><span class="line"><span class="comment"># 如 &#x27;$HOME $PATH $PWD&#x27;</span></span><br></pre></td></tr></table></figure><p>定义一个变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=Mark</span><br></pre></td></tr></table></figure><p>使用这个变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> The name is <span class="variable">$name</span></span><br></pre></td></tr></table></figure><h2 id="读取用户输入"><a href="#读取用户输入" class="headerlink" title="读取用户输入"></a>读取用户输入</h2><p>单一变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Enter name: &quot;</span></span><br><span class="line"><span class="built_in">read</span> name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your name is <span class="variable">$name</span>.&quot;</span></span><br></pre></td></tr></table></figure><p>多个变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Enter name: &quot;</span></span><br><span class="line"><span class="built_in">read</span> name1 name2 name3</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your name is <span class="variable">$name1</span>, <span class="variable">$name2</span>, <span class="variable">$name3</span>.&quot;</span></span><br></pre></td></tr></table></figure><p>太麻烦了，使用数组来读取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -a names <span class="comment"># array</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Names: <span class="variable">$&#123;names[0]&#125;</span>, ...&quot;</span></span><br></pre></td></tr></table></figure><p>输入时请在每个名字间加入空格。如果我们想在同一行打印和输入或者在输密码的时候保证隐私：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&#x27;Enter username: &#x27;</span> user_name</span><br><span class="line"><span class="built_in">read</span> -sp <span class="string">&#x27;Enter password: &#x27;</span> user_password <span class="comment"># 输入将不会有任何回显</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;name is <span class="variable">$user_name</span>&quot;</span></span><br></pre></td></tr></table></figure><p>如果你不想定义变量来存储：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Enter name: &quot;</span></span><br><span class="line"><span class="built_in">read</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your name is <span class="variable">$REPLY</span>.&quot;</span></span><br><span class="line"><span class="comment"># read 会把读取到的都存进 $REPLY，这是个系统变量</span></span><br></pre></td></tr></table></figure><h2 id="向脚本传入参数"><a href="#向脚本传入参数" class="headerlink" title="向脚本传入参数"></a>向脚本传入参数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$0</span> <span class="variable">$1</span> <span class="variable">$2</span></span><br></pre></td></tr></table></figure><p>如果是通过下面指令执行的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./xxx.sh -qwq 123</span><br></pre></td></tr></table></figure><p>将会打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./xxx.sh -qwq 123</span><br></pre></td></tr></table></figure><p>将参数作为数组存储：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">args=(<span class="string">&quot;<span class="variable">$@</span>&quot;</span>) <span class="comment"># &#x27;$@&#x27;作为数组</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arg[0]&#125;</span> ...</span><br><span class="line"><span class="comment"># 但是请注意，arg[0] 等效 $1 而不是 $0</span></span><br></pre></td></tr></table></figure><p>打印一共传入了多少个参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$#</span> <span class="comment"># 同样，不包括 $0</span></span><br></pre></td></tr></table></figure><h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">count=10</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$count</span> -eq 10 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;cond is true&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;cond is false&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="整型数对比"><a href="#整型数对比" class="headerlink" title="整型数对比"></a>整型数对比</h3><table><thead><tr><th>语句</th><th>效果</th></tr></thead><tbody><tr><td>-eq</td><td>等于</td></tr><tr><td>-ne</td><td>不等于</td></tr><tr><td>-gt or &gt; if ((  ))</td><td>大于</td></tr><tr><td>-ge or &gt;&#x3D; if ((  ))</td><td>大于等于</td></tr><tr><td>-lt or &lt; if ((  ))</td><td>小于</td></tr><tr><td>-le or &lt;&#x3D; if ((  ))</td><td>小于等于</td></tr></tbody></table><p><code>if((  ))</code> 代表语句要包括在里面，于正常的 <code>if[  ]</code> 不同。</p><h3 id="字符串对比"><a href="#字符串对比" class="headerlink" title="字符串对比"></a>字符串对比</h3><table><thead><tr><th>语句</th><th>效果</th></tr></thead><tbody><tr><td>&#x3D; or &#x3D;&#x3D;</td><td>等于</td></tr><tr><td>!&#x3D;</td><td>不等于</td></tr><tr><td>&lt; if [[  ]]</td><td>ASCII码表来比大小</td></tr><tr><td>&gt; if [[  ]]</td><td>同上</td></tr><tr><td>-z</td><td>null，长度为0</td></tr></tbody></table><p><code>if[[  ]]</code> 代表语句要包括在里面，于正常的 <code>if[  ]</code> 不同。</p><h2 id="文件操作符"><a href="#文件操作符" class="headerlink" title="文件操作符"></a>文件操作符</h2><table><thead><tr><th align="left">操作符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">-b file</td><td align="left">检测文件是否是块设备文件，如果是，则返回 true。</td><td align="left">[ -b $file ] 返回 false。</td></tr><tr><td align="left">-c file</td><td align="left">检测文件是否是字符设备文件，如果是，则返回 true。</td><td align="left">[ -c $file ] 返回 false。</td></tr><tr><td align="left">-d file</td><td align="left">检测文件是否是目录，如果是，则返回 true。</td><td align="left">[ -d $file ] 返回 false。</td></tr><tr><td align="left">-f file</td><td align="left">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td><td align="left">[ -f $file ] 返回 true。</td></tr><tr><td align="left">-g file</td><td align="left">检测文件是否设置了 SGID 位，如果是，则返回 true。</td><td align="left">[ -g $file ] 返回 false。</td></tr><tr><td align="left">-k file</td><td align="left">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td><td align="left">[ -k $file ] 返回 false。</td></tr><tr><td align="left">-p file</td><td align="left">检测文件是否是有名管道，如果是，则返回 true。</td><td align="left">[ -p $file ] 返回 false。</td></tr><tr><td align="left">-u file</td><td align="left">检测文件是否设置了 SUID 位，如果是，则返回 true。</td><td align="left">[ -u $file ] 返回 false。</td></tr><tr><td align="left">-r file</td><td align="left">检测文件是否可读，如果是，则返回 true。</td><td align="left">[ -r $file ] 返回 true。</td></tr><tr><td align="left">-w file</td><td align="left">检测文件是否可写，如果是，则返回 true。</td><td align="left">[ -w $file ] 返回 true。</td></tr><tr><td align="left">-x file</td><td align="left">检测文件是否可执行，如果是，则返回 true。</td><td align="left">[ -x $file ] 返回 true。</td></tr><tr><td align="left">-s file</td><td align="left">检测文件是否为空（文件大小是否大于0），不为空返回 true。</td><td align="left">[ -s $file ] 返回 true。</td></tr><tr><td align="left">-e file</td><td align="left">检测文件（包括目录）是否存在，如果是，则返回 true。</td><td align="left">[ -e $file ] 返回 true。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
            <tag> 脚本编程 </tag>
            
            <tag> 自动化 </tag>
            
            <tag> 命令行 </tag>
            
            <tag> Bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAN理论基础</title>
      <link href="/2025/08/21/CAN%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/08/21/CAN%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>CAN 定义了物理层（Physical）和数据链路层（DataLink）</p><ul><li>物理层：规定引脚数、如何定义0和1等等</li><li>数据链路层：如何定义一个CAN帧</li></ul><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>特性包括</p><ul><li>包括 CAN_Low 和 CAN_High 两个线</li><li>逐位总线仲裁</li><li>双绞线，差分信号</li></ul><p><img src="/2025/08/21/CAN%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/1.png"></p><h3 id="电平"><a href="#电平" class="headerlink" title="电平"></a>电平</h3><p><img src="/2025/08/21/CAN%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2.png"></p><p>0为显性，1为隐性，即0可以把1覆盖了</p><h3 id="按位仲裁"><a href="#按位仲裁" class="headerlink" title="按位仲裁"></a>按位仲裁</h3><p><img src="/2025/08/21/CAN%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/3.png"></p><p>可以理解0的优先级比1高，即数字越小优先级越高；节点A它发送了1却检测到了0，那它就会停止发送了，因为有优先级更高的设备在传输</p><h2 id="数据链路层（帧）"><a href="#数据链路层（帧）" class="headerlink" title="数据链路层（帧）"></a>数据链路层（帧）</h2><p>共有三种类型：</p><p>其中**<code>错误帧</code><strong>、</strong><code>过载帧</code><strong>、</strong><code>帧间隔</code>**都是由硬件完成的，没有办法用软件来控制。</p><p>数据帧和遥控帧有**<code>标准格式</code><strong>与</strong><code>扩展格式</code><strong>。标准格式有</strong><code>11位</code><strong>标识符，扩展格式有</strong><code>29位</code>**标识符。</p><ul><li>数据帧</li><li>远程帧</li><li>错误帧</li></ul><h3 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h3><p><img src="/2025/08/21/CAN%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/4.png"></p><p><img src="/2025/08/21/CAN%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/5.png"></p><p>包括</p><table><thead><tr><th>1</th><th>帧起始</th><th>表示帧的开始，产生一个bit的显性电平。</th></tr></thead><tbody><tr><td>2</td><td>仲裁段</td><td>表示帧的优先级， 由标识符（ID）和传送帧类型(RTR)组成。</td></tr><tr><td>3</td><td>控制端</td><td>表示数据的字节数，由6个bit构成（4bits为DLC 0～8bytes）。IDE位用于表明此帧是标准帧还是扩展帧。</td></tr><tr><td>4</td><td>数据段</td><td>数据的具体内容，可发送0～8 个字节的数据。</td></tr><tr><td>5</td><td>CRC段</td><td>用于校验传输是否正确。</td></tr><tr><td>6</td><td>ACK段</td><td>表示确认是否正常接收。</td></tr><tr><td>7</td><td>帧结束</td><td>表示此帧结束。</td></tr></tbody></table><h3 id="远程帧"><a href="#远程帧" class="headerlink" title="远程帧"></a>远程帧</h3><p>用于请求数据</p><p>不包括数据区</p><h3 id="错误帧"><a href="#错误帧" class="headerlink" title="错误帧"></a>错误帧</h3><p>Transmitted when a node detects a fault and cause all other nodes to detect a fault</p><p>包括</p><ul><li>错误标志</li><li>错误分割（留时间给其他设备发错误帧）</li></ul><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><ul><li><p>配置波特率</p></li><li><p>配置过滤器：<strong>CAN过滤器有两种工作模式</strong>：<strong><code>列表模式</code></strong> 与 <strong><code>掩码模式</code></strong>。</p><ul><li>列表：列出ID名字，过滤器通过判断报文ID与其是否一致来决定是接受还是舍弃这份报文。</li><li>掩码：通过确定ID特定位的值来判断报文的接受与丢弃。</li></ul></li><li><p>之后就可以发送和接收了</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
          <category> 通信协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAN </tag>
            
            <tag> 通信协议 </tag>
            
            <tag> 总线 </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> 物理层 </tag>
            
            <tag> 数据链路层 </tag>
            
            <tag> 理论基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言细枝末节</title>
      <link href="/2025/08/21/C%E8%AF%AD%E8%A8%80%E7%BB%86%E6%9E%9D%E6%9C%AB%E8%8A%82/"/>
      <url>/2025/08/21/C%E8%AF%AD%E8%A8%80%E7%BB%86%E6%9E%9D%E6%9C%AB%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<h2 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h2><pre><code>16位操作系统：long：4字节，int：2字节32位操作系统：long：4字节，int：4字节64位操作系统：long：8字节，int：4字节</code></pre><p>所以最好使用 stdint 内的指定位数的定义（如int8、int32等）保证移植的兼容性</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul><li>用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化（告诉编译器对该变量不做优化，都会直接从变量内存地址中读取数据）</li></ul><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p><strong>全局（静态）存储区</strong>：分为 DATA 段和 BSS 段。DATA 段（全局初始化区）存放初始化的全局变量和静态变量；BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。</p><ul><li>在修饰变量的时候，static 修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。</li><li>static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。</li><li>static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。</li><li>不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。</li><li>考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。</li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h3><p>核心特性</p><ul><li>自动分配与释放：由编译器自动管理，函数调用时分配栈帧，函数返回时自动释放。</li><li>后进先出（LIFO）</li><li>高速访问</li><li>空间有限</li></ul><p>存储内容</p><ul><li>局部变量：函数内部定义的变量。</li><li>返回地址：函数执行完毕后返回的位置。</li><li>函数参数：调用函数时传递的参数。</li><li>寄存器值：保存调用前的寄存器状态，以便恢复。</li></ul><p>优缺点</p><ul><li>优点：无需手动管理内存，速度快，不会内存泄漏。</li><li>缺点：生命周期固定（函数结束即释放），空间有限。</li></ul><h3 id="堆（heap）"><a href="#堆（heap）" class="headerlink" title="堆（heap）"></a>堆（heap）</h3><p>核心特性</p><ul><li>手动分配与释放：使用malloc&#x2F;calloc&#x2F;realloc分配，free释放。</li><li>动态生命周期：内存块的生命周期由程序员控制，可跨函数使用。</li><li>碎片化问题：频繁分配和释放可能导致内存碎片，降低空间利用率。</li><li>慢速访问：需通过指针间接访问，效率低于栈。</li></ul><p>存储内容</p><ul><li>动态分配的对象：如malloc返回的内存块。</li><li>大型数据结构：如数组、链表、树等需要动态调整大小的结构。</li><li>跨函数数据：需要在函数调用结束后继续存在的数据。</li></ul><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p><strong>空指针</strong>：指针变量指向内存中编号为0的空间</p><p><strong>野指针</strong>：指针变量指向非法的内存空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针指向的值是不可以更改的</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * p1 = &amp;a; </span><br><span class="line"></span><br><span class="line"><span class="comment">//指针指向是不可以改的</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p2 = &amp;a;</span><br></pre></td></tr></table></figure><h2 id="数据集合"><a href="#数据集合" class="headerlink" title="数据集合"></a>数据集合</h2><h3 id="共用体（union）"><a href="#共用体（union）" class="headerlink" title="共用体（union）"></a>共用体（union）</h3><p>所有成员共用一块内存，大小取决于最大大小成员</p><h3 id="枚举（enum）"><a href="#枚举（enum）" class="headerlink" title="枚举（enum）"></a>枚举（enum）</h3><p>默认从 0 开始递增</p><h3 id="位域（Bit-Field）"><a href="#位域（Bit-Field）" class="headerlink" title="位域（Bit Field）"></a>位域（Bit Field）</h3><p>位域用于结构体中，定义每个字段占用的比特位数；越前面定义的在内存的越高位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Flags</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ready : <span class="number">1</span>;<span class="comment">// 1bit</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> error : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mode  : <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>位域不能取地址（&amp;f.ready 不合法）</li><li>字段数值不能超过位数范围（2^n - 1）</li><li>与具体编译器实现密切相关（跨平台需小心）</li></ul><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LED_PIN (1 &lt;&lt; 2)</span></span><br><span class="line"></span><br><span class="line">PORT |= LED_PIN;   <span class="comment">// 置位</span></span><br><span class="line">PORT &amp;= ~LED_PIN;  <span class="comment">// 清零</span></span><br><span class="line">PORT ^= LED_PIN;   <span class="comment">// 翻转</span></span><br></pre></td></tr></table></figure><h2 id="编译和调试"><a href="#编译和调试" class="headerlink" title="编译和调试"></a>编译和调试</h2><h3 id="四阶段"><a href="#四阶段" class="headerlink" title="四阶段"></a>四阶段</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -E main.c -o main.i   # 预处理</span><br><span class="line">gcc -S main.c -o main.s   # 编译为汇编</span><br><span class="line">gcc -c main.c -o main.o   # 汇编为目标文件</span><br><span class="line">gcc main.o -o main        # 链接生成可执行文件</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程技巧 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 数据类型 </tag>
            
            <tag> 跨平台 </tag>
            
            <tag> 编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UART理论基础</title>
      <link href="/2025/08/20/UART%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/08/20/UART%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p>串行通信：数据一位一位按时间顺序发送（与并行通信相对）。</p></li><li><p>异步（Asynchronous）：发送端和接收端不共享时钟线，而是通过预先约定的波特率（baud rate）和帧格式来同步数据采样。</p></li></ul><h2 id="物理连接与信号"><a href="#物理连接与信号" class="headerlink" title="物理连接与信号"></a>物理连接与信号</h2><ul><li><p>常见的信号线：TX（发）和 RX（收），通常两设备交叉连接（A的TX接B的RX）。</p></li><li><p>电平标准：常见TTL电平（0V ~ 5V 或 0V ~ 3.3V）和RS-232（-3～-15V表示 1 ，+3～+15V表示 0 ）等。不同电平不可直接连接，需电平转换器（如 MAX232）。</p></li><li><p>差分连接：RS485差分连接（TX 包括 TXD-、TXD+，以此类推），当两条差分线之间压差为正时（如+2V～+6V）为逻辑1，反之</p></li></ul><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p><img src="/2025/08/20/UART%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/1.png"></p><ul><li><p>起始位：通信以发送方发送逻辑0为开始（空闲时为高电平），同时这也是为了同步采样周期。</p></li><li><p>数据位：可以为 5～8 bit，最低位优先</p></li><li><p>奇偶校验位：可以为</p><ul><li><p>关闭（0 bit）</p></li><li><p>奇校验（odd parity）：数据位的1的个数为偶，则该位为1，反之</p></li><li><p>偶校验（even parity）：数据位的1的个数为偶，则该位为0，反之</p></li></ul></li><li><p>停止位：是逻辑1，高电平，长度可以为1 bit、1.5 bit、2 bit</p></li></ul><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p><strong>1.RTS （Require ToSend，发送请求）为输出信号，用于指示本设备准备好可接收数据，低电平有效，低电平说明本设备可以接收数据。</strong></p><p><strong>2.CTS （Clear ToSend，发送允许）为输入信号，用于判断是否可以向对方发送数据，低电平有效，低电平说明本设备可以向对方发送数据。</strong></p><p>因此流控制可以控制数据传输的进程，防止数据的丢失。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
          <category> 通信协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> 理论基础 </tag>
            
            <tag> 串行通信 </tag>
            
            <tag> UART </tag>
            
            <tag> 异步通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPI理论基础</title>
      <link href="/2025/08/20/SPI%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/08/20/SPI%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="SPI-协议简介"><a href="#SPI-协议简介" class="headerlink" title="SPI 协议简介"></a>SPI 协议简介</h2><p>SPI（Serial Peripheral Interface）协议是一种主从式的通信协议，主设备可以同时控制多个从设备，但每个从设备只能被一个主设备控制。SPI 协议的主要特点是通信速度快，但通信线路较多，常用于短距离的板内通信。  </p><p>SPI 通信必须由主机发起通信（无论是发送还是接收），从机被动接受。从机不能主动发送数据。  </p><h2 id="SPI-接口形式"><a href="#SPI-接口形式" class="headerlink" title="SPI 接口形式"></a>SPI 接口形式</h2><p>SPI 接口有如下几个引脚：</p><ul><li>SCLK（Serial Clock）：时钟信号</li><li>MOSI（Master Output &#x2F; Slave Input）：主设备输出、从设备输入</li><li>MISO（Master Input &#x2F; Slave Output）：主设备输入、从设备输出</li><li>CS（Chip Select）：片选信号，用于选择从设备</li></ul><p><strong>此处只讨论标准 SPI，不讨论 Dual SPI、Qual SPI 等扩展协议。</strong></p><h2 id="SPI-时序"><a href="#SPI-时序" class="headerlink" title="SPI 时序"></a>SPI 时序</h2><h3 id="片选信号"><a href="#片选信号" class="headerlink" title="片选信号"></a>片选信号</h3><p>SPI 传输过程中，输出 CS 为低电平，选择从设备。从设备只有在 CS 为低电平时，才会响应主设备的时钟信号。</p><p>在多个从设备的情况下，可以使用多个 CS 引脚，每个 CS 引脚对应一个从设备。在每次传输开始前，主设备需要先拉低对应的 CS 引脚，然后再传输数据。传输结束后，主设备需要拉高对应的 CS 引脚，释放从设备。</p><p>在单个从设备的情况下，可以直接将从设备的 CS 引脚接地，省去了主设备控制 CS 引脚的步骤。也可以使用硬件 NSS 信号作为从设备的 CS 引脚。</p><h3 id="协议参数"><a href="#协议参数" class="headerlink" title="协议参数"></a>协议参数</h3><p>SPI 协议的主要参数有：</p><ul><li>时钟极性（CPOL，Clock Polarity）：时钟空闲状态为高电平（1）还是低电平（0）</li><li>时钟相位（CPHA，Clock Phase）：数据在时钟的第一个边沿采样（0）还是第二个边沿采样（1）</li><li>时钟频率（SCLK，Serial Clock）：时钟信号的频率</li><li>传输顺序：MSB（高位，即左到右）优先还是 LSB（低位）优先</li></ul><h3 id="SPI-时序实例"><a href="#SPI-时序实例" class="headerlink" title="SPI 时序实例"></a>SPI 时序实例</h3><p>传输 0xC8，MSB 优先，SPI Mode 0（CPOL&#x3D;0，CPHA&#x3D;0）时钟空闲低电平，第一个边沿采样。<br><img src="/2025/08/20/SPI%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/SpiExample.png"></p><h3 id="时钟信号"><a href="#时钟信号" class="headerlink" title="时钟信号"></a>时钟信号</h3><p>SPI 时钟信号由主设备产生，从设备被动接收。时钟信号仅在传输数据时使用，空闲状态会维持在高电平或低电平（由时钟极性决定）。</p><h3 id="数据信号"><a href="#数据信号" class="headerlink" title="数据信号"></a>数据信号</h3><p>数据信号在时钟信号的边沿采样，具体第一边沿还是第二边沿由时钟相位决定。   </p><p>数据的比特序分为 MSB 优先 和 LSB 优先两种，双方需要提前约定。</p><h3 id="SPI-模式"><a href="#SPI-模式" class="headerlink" title="SPI 模式"></a>SPI 模式</h3><p>SPI 模式号是 CPOL 和 CPHA 的组合，一共有四种模式：</p><ul><li>Mode $0&#x3D;(00)_2$：CPOL&#x3D;0，CPHA&#x3D;0</li><li>Mode $1&#x3D;(01)_2$：CPOL&#x3D;0，CPHA&#x3D;1</li><li>Mode $2&#x3D;(10)_2$：CPOL&#x3D;1，CPHA&#x3D;0</li><li>Mode $3&#x3D;(11)_2$：CPOL&#x3D;1，CPHA&#x3D;1</li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
          <category> 通信协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> 理论基础 </tag>
            
            <tag> SPI </tag>
            
            <tag> 串行通信 </tag>
            
            <tag> 主从通信 </tag>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIC理论基础</title>
      <link href="/2025/08/19/IIC%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/08/19/IIC%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>IIC 是两线串行通信协议（serial data line (SDA) serial clock line (SCL)），支持多设备于同一总线通信，每个设备拥有唯一地址来标识。</p><h3 id="速度模式"><a href="#速度模式" class="headerlink" title="速度模式"></a>速度模式</h3><p><img src="/2025/08/19/IIC%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/1.png"></p><ul><li>标准模式：最慢的模式</li><li>快速模式：要求总线容值和设备兼容性能匹配</li><li>快速+模式：同上</li></ul><p>下面两个稍微有些特殊：</p><ul><li>高速模式：两者需协商后才能启用该模式</li><li>超快模式：该模式只能进行写操作，并且一些IIC功能也不可用</li></ul><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="两线连接"><a href="#两线连接" class="headerlink" title="两线连接"></a>两线连接</h3><p><img src="/2025/08/19/IIC%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2.png"></p><h3 id="开漏连接"><a href="#开漏连接" class="headerlink" title="开漏连接"></a>开漏连接</h3><p>SDA和SCL都要开漏连接，两者各自连接到一个NMOS，以便可以在需要的时候接地来拉低总线。开漏连接就是IIC能连接多个设备的原因。</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="开始和停止"><a href="#开始和停止" class="headerlink" title="开始和停止"></a>开始和停止</h3><p><img src="/2025/08/19/IIC%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/3.png"></p><ul><li>开始：将 SDA 和 SCL 都拉低（先拉 SDA）</li><li>结束：将 SDA 和 SCL 都释放为高电平（先放 SCL）</li></ul><h3 id="逻辑1和0"><a href="#逻辑1和0" class="headerlink" title="逻辑1和0"></a>逻辑1和0</h3><p><img src="/2025/08/19/IIC%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/4.png"></p><ul><li>SDA 释放高时为逻辑 1，下拉时为逻辑 0</li><li>SCL 上升沿和下降沿采样时 SDA 的状态必须相同，否则无效（因为会被识别为开始或结束信号）</li></ul><h3 id="通信帧"><a href="#通信帧" class="headerlink" title="通信帧"></a>通信帧</h3><p>一个帧9个bit，为了开始通信，需要发送开始信号后接设备地址（7bit or 10bit，10bit则要发两个bytes）</p><p><img src="/2025/08/19/IIC%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/5.png"></p><ul><li>若 R&#x2F;W 位为 1 则是主机要求读取从机数据，即 R，反之</li><li>第九比特为 ACK，由目标设备（即写入时是从机拉低，读取时是主机拉低）在 SCL 周期内拉低 SDA，表示收到数据；若SDA一直为高电平，则表明没有对应地址的设备收到请求</li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
          <category> 通信协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> 理论基础 </tag>
            
            <tag> IIC </tag>
            
            <tag> I2C </tag>
            
            <tag> 双线通信 </tag>
            
            <tag> 总线通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL下编译rv110x系列芯片固件</title>
      <link href="/2024/11/20/WSL%20%E4%B8%8B%E7%BC%96%E8%AF%91%20rv110x%20%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87%E5%9B%BA%E4%BB%B6/"/>
      <url>/2024/11/20/WSL%20%E4%B8%8B%E7%BC%96%E8%AF%91%20rv110x%20%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87%E5%9B%BA%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>系统使用 Windows 11 WSL2 Ubuntu 24.04</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="一、没有-python-这个命令"><a href="#一、没有-python-这个命令" class="headerlink" title="一、没有 python 这个命令"></a>一、没有 python 这个命令</h3><p>是因为安装了 python3 但没有 python 没有指向它</p><p><code>sudo apt install python-is-python3</code></p><p>安装该包来解决这个问题</p><h3 id="二、PATH-包含空格"><a href="#二、PATH-包含空格" class="headerlink" title="二、PATH 包含空格"></a>二、PATH 包含空格</h3><p>WSL 把 windows 的 PATH 也一起弄到 Linux 内了</p><p>修改 WSL 配置文件 <code>/etc/wsl.conf</code> 添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[interop]</span><br><span class="line">appendWindowsPath=false</span><br></pre></td></tr></table></figure><p>关闭 wsl 八秒以上再启动即可解决</p><h3 id="三、找不到-cpio-模块"><a href="#三、找不到-cpio-模块" class="headerlink" title="三、找不到 cpio 模块"></a>三、找不到 cpio 模块</h3><p>安装一下 <code>sudo apt install cpio</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Luckfox </tag>
            
            <tag> RV110x </tag>
            
            <tag> WSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nanopi neo core 作为下位机首次配置流程</title>
      <link href="/2023/05/03/Nanopi-neo-core-%E4%BD%9C%E4%B8%BA%E4%B8%8B%E4%BD%8D%E6%9C%BA%E9%A6%96%E6%AC%A1%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B/"/>
      <url>/2023/05/03/Nanopi-neo-core-%E4%BD%9C%E4%B8%BA%E4%B8%8B%E4%BD%8D%E6%9C%BA%E9%A6%96%E6%AC%A1%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p> <a href="https://detail.yinxiang.com/index.html?guid=ba0bc618-4d29-4d47-ac6c-94ee43c146a3&loginName=zz&token=V1-5045541-MYjTa8q0ZLek6LeI38RvqD5jI24sVIuET6GRx9SRx+6LylYFWfpEohLy/GvK2k1C4rP7Xzg8KW3ITmaY3ABkQrRRKV0qmmvJzOQxupLrrBHjOgO1kKvbb0qVhVeAmkvE/4Zh8sYgbnZuLLj0qaPvTHhnkf37MKJ7Y2i/Ct54j8WhHzSEjBmO0qGrJSZVbxJ0&at=false&platformType=1&deviceinfo=%7B%22application%22:%22android_miniapp%22,%22applicationVersion%22:%221.1.22%22,%22platform%22:%22microsoft%22,%22platformVersion%22:%22Windows%2011%20x64%22,%22locale%22:%22zh_CN%22%7D&unionId=f5d82db79639969b9e276eb18f7d6c98&userId=36590286&sessionId=011Yboll2OePB94SKHll2I8bMS3Ybol1&channelId=wx75425a38a3ed6402">原本的配置流程链接</a></p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ol><li>NanoPi NEO Core 板子</li><li>4G 及以上的 TF 卡和读卡器</li><li>USB 转串口</li><li>水下机器人主板（提供网口和供电）</li></ol><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ol><li>安装 SSH 软件（较新的 Windows 系统一般自带，也可以去下载专门的 SSH 软件，如：<code>putty</code> 、<code>finalshell</code>、<code>MobXterm</code>等等）</li><li>串口终端（如 <code>putty</code> 、<code>MobXterm</code> 等等）</li><li>前往 <a href="https://wiki.friendlyelec.com/wiki/index.php/NanoPi_NEO_Core/zh">官方 WiKi</a> 下载系统镜像，注意要下载 带 eflasher 的 Ubuntu xenial 4.14 ，即文件名类似于 <code>h3_ eflasher friendlycore-xenial_ 4.14_ armhf 20210618.img.zip</code> 的镜像文件</li></ol><h1 id="开始烧录固件"><a href="#开始烧录固件" class="headerlink" title="开始烧录固件"></a>开始烧录固件</h1><p>（全新的 Nano Pi 会内置该固件，可以直接跳到<strong>系统配置</strong>）</p><h2 id="向-SD-卡写入镜像"><a href="#向-SD-卡写入镜像" class="headerlink" title="向 SD 卡写入镜像"></a>向 SD 卡写入镜像</h2><p>使用镜像写入工具（如 <code>win32diskimager</code>），选择指定镜像烧录（烧录前请确保 SD 卡只有一个分区）</p><h2 id="使用串口连接-Nano-Pi"><a href="#使用串口连接-Nano-Pi" class="headerlink" title="使用串口连接 Nano Pi"></a>使用串口连接 Nano Pi</h2><p>请将 USB 转串口连接到 Nano Pi 的 RX0 和 TX0 引脚，并且共地，引脚图如下：</p><p><img src="https://wiki.friendlyelec.com/wiki/images/5/53/NEO_Core_pinout-02.jpg"></p><h2 id="电脑连接SBC"><a href="#电脑连接SBC" class="headerlink" title="电脑连接SBC"></a>电脑连接SBC</h2><ol><li><p>将烧录好的 SD 卡插入 Nano Pi</p></li><li><p>使用 Nano Pi 上的 USB 给板子供电</p></li><li><p>将 USB 转串口连接到电脑的串口终端</p></li><li><p>输入账户密码进行登陆（用户账号和密码都是 <code>pi</code> ，root 用户密码是 <code>fa</code>），进入系统后在终端输入 <code>su root</code> 切换 root 用户，后执行 <code>eflasher</code> 命令进入如下界面：<img src="https://wiki.friendlyelec.com/wiki/images/0/09/Eflasher_friendlycore1.jpg"></p></li><li><p>输入“１”后按回车，选择烧写 friendlycore 系统到 eMMC 上后，会提示如下信息：<img src="https://wiki.friendlyelec.com/wiki/images/6/60/Eflasher_friendlycore2_h3.jpg"></p></li><li><p>输入“yes”，确定进行烧写：</p><p><img src="https://wiki.friendlyelec.com/wiki/images/0/0c/Eflasher_friendlycore3.jpg"></p></li><li><p>等待烧写完毕后，断电并从卡槽中取出 TF 卡。</p></li></ol><h1 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h1><h2 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h2><p>将 Nano Pi 插入调试主板后，给其供电并连接网口至路由器</p><h2 id="电脑端操作"><a href="#电脑端操作" class="headerlink" title="电脑端操作"></a>电脑端操作</h2><ol><li><p>到路由器后台查看 Nano Pi 的 IP 地址，使用 SSH 工具连接至 Nano Pi （用户账号和密码都是 <code>pi</code> ，root 用户密码是 <code>fa</code>）</p></li><li><p>更换国内软件源，终端输入 <code>sudo nano /etc/apt/sources.list</code> 后修改为如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial main restricted universe multiverse</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-updates main restricted universe multiverse</span><br></pre></td></tr></table></figure></li><li><p>更新软件源（依次输入以下命令）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get clean</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment">#可能需要较长时间，期间不能关闭 SSH 连接</span></span><br></pre></td></tr></table></figure></li><li><p>安装必备软件（依次输入以下命令）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gdb htop cmake unzip i2c-tools autoconf automake libtool</span><br><span class="line"></span><br><span class="line">sudo apt-get install libgstreamer*</span><br><span class="line"></span><br><span class="line">sudo apt-get install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc gstreamer1.0-tools gstreamer1.0-x gstreamer1.0-alsa gstreamer1.0-pulseaudio</span><br><span class="line"></span><br><span class="line"><span class="comment">#可能有些软件包找不到了，请在命令中删除那些软件包的名字再尝试安装</span></span><br></pre></td></tr></table></figure></li><li><p>到 Github 下载 rovmaster 的源码 zip 压缩包，使用网络传输到 Nano Pi ，在 SSH 终端中使用 <code>unzip</code> 命令进行解压</p></li><li><p>解压后进入 <strong>rov-master-main</strong> 文件夹，输入 <code>sudo chmod +x build.sh</code> 后输入 <code>sudo ./build.sh</code> 进行依赖编译</p></li><li><p>显示 <em>构建完成</em> 后，输入命令 <code>make</code> 后<strong>没有错误</strong>后，再输入一次 <code>make</code> 就会产生可执行文件 <code>rovmaster</code></p></li><li><p>使能 <code>spi1</code> 外设，输入 <code>udo npi-config</code> 命令后到 <code>\&gt; Advanced Options</code> 中使能相关 SPI 设备</p></li><li><p>修改静态 IP ，输入命令 <code>sudo nano /etc/network/interfaces</code> 后将原文件内容注释掉后加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">allow-hotplug eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 192.168.137.219</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.137.1</span><br><span class="line">dns-nameservers 192.168.137.1</span><br></pre></td></tr></table></figure></li><li><p>配置结束</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
          <category> 硬件平台 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> NanoPi </tag>
            
            <tag> SBC </tag>
            
            <tag> 单板计算机 </tag>
            
            <tag> 系统配置 </tag>
            
            <tag> 嵌入式Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RockPi 5B Armbian 首次开机设置流程</title>
      <link href="/2023/04/03/RockPi-5B-Armbian-%E9%A6%96%E6%AC%A1%E5%BC%80%E6%9C%BA%E8%AE%BE%E7%BD%AE%E6%B5%81%E7%A8%8B/"/>
      <url>/2023/04/03/RockPi-5B-Armbian-%E9%A6%96%E6%AC%A1%E5%BC%80%E6%9C%BA%E8%AE%BE%E7%BD%AE%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="镜像烧录"><a href="#镜像烧录" class="headerlink" title="镜像烧录"></a>镜像烧录</h2><p>下载 Armbian 最新镜像 <em>Armbian_x.x.x_Rock-5b_jammy_legacy_x.x.x_gnome_desktop.img.xz</em> 烧录到SD内（推荐使用 Raspberry Pi Imager）</p><h2 id="安装后相关设置"><a href="#安装后相关设置" class="headerlink" title="安装后相关设置"></a>安装后相关设置</h2><ol><li><p>首先启动3D加速</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:liujianfeng1994/panfork-mesa</span><br><span class="line">sudo add-apt-repository ppa:liujianfeng1994/rockchip-multimedia</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt dist-upgrade</span><br><span class="line">sudo apt install kodi</span><br></pre></td></tr></table></figure></li><li><p>如果要使用Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --<span class="built_in">set</span> iptables /usr/sbin/iptables-legacy</span><br><span class="line">update-alternatives --<span class="built_in">set</span> ip6tables /usr/sbin/ip6tables-legacy</span><br></pre></td></tr></table></figure></li><li><p>安装中文字体（后把shell改为中文才不会乱码）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ttf-wqy-microhei</span><br><span class="line">sudo apt-get install ttf-wqy-zenhei</span><br></pre></td></tr></table></figure><p>需要GUI(Gnome)也为中文可以到设置里切换语言，会自动安装</p></li><li><p>安装风扇接口驱动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/lukaszsobala/fan-control-rock5b</span><br><span class="line"><span class="built_in">cd</span> fan-control-rock5b</span><br><span class="line">make package</span><br><span class="line">sudo dpkg -i fan-control*.deb</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> fan-control</span><br><span class="line">systemctl start fan-control</span><br></pre></td></tr></table></figure></li><li><p>安装HDMI采集卡驱动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gstreamer1.0-rockchip1 gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly</span><br></pre></td></tr></table></figure><p>4K查看(请在显卡控制菜单中选择yuv420格式输出):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gst-launch-1.0 -e v4l2src device=/dev/video0 ! videoconvert ! <span class="string">&#x27;video/x-raw,format=NV12,width=3840,height=2160&#x27;</span> ! autovideosink</span><br></pre></td></tr></table></figure><p>4K录制+监看(请在显卡控制菜单中选择yuv420格式输出):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gst-launch-1.0 -e v4l2src device=/dev/video0 ! <span class="string">&#x27;video/x-raw,format=NV12,width=3840,height=2160&#x27;</span> ! <span class="built_in">tee</span> name=t t. ! mpph265enc bps=20000000 bps-max=40000000 rc-mode=vbr ! h265parse ! mp4mux name=mux ! filesink location=4k60hdmiin.mp4 alsasrc device=default ! opusenc bitrate=192000 ! mux. t. ! queue leaky=1 ! autovideosink <span class="built_in">sync</span>=<span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ol><p>想要修改视频码率请更改mpph265enc bps&#x3D;和bps-max&#x3D;,单位bit&#x2F;s<br>修改音频码率请更改opusenc bitrate&#x3D;,单位bit&#x2F;s<br>不需要录音或开启录制后卡死可以把<code>alsasrc device=default ! opusenc bitrate=192000 ! mux.</code> 删掉<br>不需要监看可以把<code>t. ! queue leaky=1 ! autovideosink sync=false</code>删掉<br>需要h264格式请把mpph265enc改成mpph264enc 并把h265parse改成h264parse<br>如果报错<code>streaming stopped, reason not-negotiated (-4)</code> 首先运行dmesg看看有没有报错刷屏, 如果有,那么建议换一根好点的HDMI线. 否则检查电脑输出分辨率和格式.<br>想要其它格式和分辨率要把<code>&#39;video/x-raw,format=NV12,width=3840,height=2160&#39;</code>作对应修改! 其中format建议NV12&#x2F;NV16&#x2F;BGR&#x2F;RGB挨个试一遍<br>1080p下采集的刷新率其实不受限于60Hz, 可以在电脑上自行修改.</p><ol start="6"><li><p>A8型号的蓝牙驱动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">nano /etc/modprobe.d/blacklist.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#最后一行加上以下这些</span></span><br><span class="line">blacklist pgdrv</span><br><span class="line">blacklist btusb</span><br><span class="line">blacklist btrtl</span><br><span class="line">blacklist btbcm</span><br><span class="line">blacklist btintel</span><br><span class="line"></span><br><span class="line">systemctl restart bluetooth</span><br></pre></td></tr></table></figure></li><li><p>其他定制设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo armbian-config</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RockPi </tag>
            
            <tag> Armbian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-IDF WIFI的使用(1) 初步入门</title>
      <link href="/2023/01/03/ESP32-IDF-WIFI%E7%9A%84%E4%BD%BF%E7%94%A8-1-%E5%88%9D%E6%AD%A5%E5%85%A5%E9%97%A8/"/>
      <url>/2023/01/03/ESP32-IDF-WIFI%E7%9A%84%E4%BD%BF%E7%94%A8-1-%E5%88%9D%E6%AD%A5%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>WiFi相关文档参阅 <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v5.0/esp32/api-guides/wifi.html">乐鑫IDF编程文档</a></p><p>具体启动流程如下:</p><p><img src="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v5.0/esp32/_images/seqdiag-3539a23193af2f08aeb412fd527f18a5a1b2fd43.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ESP_ERROR_CHECK(esp_netif_init());  <span class="comment">//创建一个 LwIP 核心任务，并初始化 LwIP 相关工作</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_event_loop_create_default());   <span class="comment">//创建一个系统事件任务，并初始化应用程序事件的回调函数。在此情况下，该回调函数唯一的动作就是将事件中继到应用程序任务中</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_netif_create_default_wifi_sta());   <span class="comment">//创建有 TCP/IP 堆栈的默认网络接口实例绑定 station</span></span><br><span class="line">    <span class="type">wifi_init_config_t</span> wifi_init_config = WIFI_INIT_CONFIG_DEFAULT;</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_init(&amp;wifi_init_config));</span><br><span class="line"></span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));</span><br><span class="line"></span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_start());</span><br><span class="line"></span><br><span class="line">    <span class="type">wifi_country_t</span> country_config = &#123;</span><br><span class="line">        .cc = <span class="string">&quot;CN&quot;</span>,</span><br><span class="line">        .schan = <span class="number">1</span>,</span><br><span class="line">        .nchan = <span class="number">13</span>,</span><br><span class="line">        .policy = WIFI_COUNTRY_POLICY_AUTO,</span><br><span class="line">    &#125;;</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_country(&amp;country_config));</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
            <tag> IDF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-IDF 自定义分区表的编写</title>
      <link href="/2023/01/02/ESP32-IDF-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E5%8C%BA%E8%A1%A8%E7%9A%84%E7%BC%96%E5%86%99/"/>
      <url>/2023/01/02/ESP32-IDF-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E5%8C%BA%E8%A1%A8%E7%9A%84%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Name,   Type, SubType, Offset,  Size, Flags</span><br><span class="line">nvs,      data, nvs,     ,        0x6000,</span><br><span class="line">phy_init, data, phy,     ,        0x1000,</span><br><span class="line">factory,  app,  factory, ,        1M,</span><br></pre></td></tr></table></figure><p>第一个为NVS分区,大小为24K多一点;第三个就是存放程序的地方,大小为1MByte</p><p>我们在底下多加一行NVS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_nvs, data, nvs, , 1M,</span><br></pre></td></tr></table></figure><p>将这些内容保存为 <code>partitions.csv</code> 后放在项目根目录并修改 Manuconfig 里面使用的分区表.</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>这里以NVS为例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">nvs_handle_t</span> testhandle;</span><br><span class="line">nvs_open_from_partition(<span class="string">&quot;my_nvs&quot;</span>, <span class="string">&quot;test_name&quot;</span>, NVS_READWRITE, &amp;testhandle);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
            <tag> IDF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-IDF 非易失性存储 NVS (二) 相关工具</title>
      <link href="/2023/01/02/ESP32-IDF-%E9%9D%9E%E6%98%93%E5%A4%B1%E6%80%A7%E5%AD%98%E5%82%A8-NVS-%E4%BA%8C-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/01/02/ESP32-IDF-%E9%9D%9E%E6%98%93%E5%A4%B1%E6%80%A7%E5%AD%98%E5%82%A8-NVS-%E4%BA%8C-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="NVS迭代器"><a href="#NVS迭代器" class="headerlink" title="NVS迭代器"></a>NVS迭代器</h1><p>相当于终端的 <code>ls</code> 命令,可以遍历 NVS 所有的 key 和 value</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example of listing all the key-value pairs of any type under specified partition and namespace</span></span><br><span class="line"> <span class="type">nvs_iterator_t</span> it = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="type">esp_err_t</span> res = nvs_entry_find(&lt;nvs_partition_name&gt;, &lt;namespace&gt;, NVS_TYPE_ANY, &amp;it);</span><br><span class="line"> <span class="keyword">while</span>(res == ESP_OK) &#123;</span><br><span class="line">     <span class="type">nvs_entry_info_t</span> info;</span><br><span class="line">     nvs_entry_info(it, &amp;info); <span class="comment">// Can omit error check if parameters are guaranteed to be non-NULL</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;key &#x27;%s&#x27;, type &#x27;%d&#x27; \n&quot;</span>, info.key, info.type);</span><br><span class="line">     res = nvs_entry_next(&amp;it);</span><br><span class="line"> &#125;</span><br><span class="line"> nvs_release_iterator(it);</span><br></pre></td></tr></table></figure><h1 id="获取NVS当前状态"><a href="#获取NVS当前状态" class="headerlink" title="获取NVS当前状态"></a>获取NVS当前状态</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example of nvs_get_stats() to get the number of used entries and free entries:</span></span><br><span class="line"><span class="type">nvs_stats_t</span> nvs_stats;</span><br><span class="line">nvs_get_stats(<span class="literal">NULL</span>, &amp;nvs_stats);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Count: UsedEntries = (%d), FreeEntries = (%d), AllEntries = (%d)\n&quot;</span>,</span><br><span class="line">       nvs_stats.used_entries, nvs_stats.free_entries, nvs_stats.total_entries);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
            <tag> IDF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-IDF 非易失性存储 NVS (一) 入门</title>
      <link href="/2022/12/19/ESP32-IDF-%E9%9D%9E%E6%98%93%E5%A4%B1%E6%80%A7%E5%AD%98%E5%82%A8-NVS-%E4%B8%80-%E5%85%A5%E9%97%A8/"/>
      <url>/2022/12/19/ESP32-IDF-%E9%9D%9E%E6%98%93%E5%A4%B1%E6%80%A7%E5%AD%98%E5%82%A8-NVS-%E4%B8%80-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>NVS格式就是一种flash的文件管理方式，因为他自身这种键值对的数据结构有较大的空间开销，所有不适合很长的数据（重复的key会浪费空间），而适合一对一对的这种短的数据（优势应该是方便查管理）.在ESP32上NVS是基础，比如WIFI都会使用到NVS来存储配置文件。<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/api-reference/storage/nvs_flash.html">乐鑫官方文档</a></p><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><table><thead><tr><th>函数名</th><th>描述</th></tr></thead><tbody><tr><td>nvs_flash_init()</td><td>挂载NVS</td></tr><tr><td>nvs_flash_deinit()</td><td>卸载NVS</td></tr><tr><td>nvs_open(const char* namespace_name, nvs_open_mode_t open_mode, nvs_handle_t *out_handle)</td><td>打开对应namespace的NVS</td></tr><tr><td>nvs_close(nvs_handle_t *out_handle)</td><td>关闭NVS</td></tr><tr><td>nvs_get_xx(nvs_handle_t c_handle, const char* key, xx* out_value)</td><td>获取数据(如果对应key数据不存在则out_value不会被修改)</td></tr><tr><td>nvs_set_xx(nvs_handle_t handle, const char* key, xx value))</td><td>写入数据</td></tr><tr><td>nvs_commit(nvs_handle_t handle)</td><td>写入所有数据(加在所有set后面)</td></tr></tbody></table><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nvs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nvs_flash.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NS_TEST <span class="string">&quot;ns-test&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_TEST <span class="string">&quot;key-test&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">nvs_handle_t</span> testhandle;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    vTaskDelay(<span class="number">1000</span>/portTICK_PERIOD_MS);</span><br><span class="line">    nvs_flash_init();</span><br><span class="line">    nvs_open(NS_TEST, NVS_READWRITE, &amp;testhandle);</span><br><span class="line">    nvs_get_u16(testhandle, KEY_TEST, &amp;count);</span><br><span class="line">    ESP_LOGI(<span class="string">&quot;NVS&quot;</span>, <span class="string">&quot;the count %d&quot;</span>, count);</span><br><span class="line">    nvs_set_u16(testhandle, KEY_TEST, ++count);</span><br><span class="line">    nvs_commit(testhandle);</span><br><span class="line">    nvs_close(testhandle);</span><br><span class="line">    nvs_flash_deinit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="BLOB"><a href="#BLOB" class="headerlink" title="BLOB"></a>BLOB</h1><p>可以存放任何类型的数据,如结构体和字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">esp_err_t</span> <span class="title function_">nvs_set_blob</span><span class="params">(<span class="type">nvs_handle_t</span> c_handle,</span></span><br><span class="line"><span class="params">                       <span class="type">const</span> <span class="type">char</span>* key,</span></span><br><span class="line"><span class="params">                       <span class="type">const</span> <span class="type">void</span>* value,</span></span><br><span class="line"><span class="params">                       <span class="type">size_t</span> length)</span></span><br></pre></td></tr></table></figure><p>用法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> ssid[<span class="number">50</span>];</span><br><span class="line">    <span class="type">char</span> password[<span class="number">50</span>];</span><br><span class="line">&#125; <span class="type">ap_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ap_t</span> ap1;</span><br><span class="line"><span class="type">ap_t</span> aps[max_ap];</span><br><span class="line"></span><br><span class="line">nvs_set_blob(my_handle, <span class="string">&quot;test&quot;</span>, ap1, <span class="keyword">sizeof</span>(ap1));</span><br><span class="line">nvs_set_blob(my_handle, <span class="string">&quot;tests&quot;</span>, aps, <span class="keyword">sizeof</span>(aps));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
            <tag> IDF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-IDF 自定义菜单 Menuconfig 入门</title>
      <link href="/2022/12/17/ESP32-IDF-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95-Menuconfig-%E5%85%A5%E9%97%A8/"/>
      <url>/2022/12/17/ESP32-IDF-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95-Menuconfig-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>  程序写好后，肯定会有很多变量需要设置，为了方便他人和未来的自己，我们可以把这些变量做到 Menuconfig 中。这样子，其他人或者未来的自己，就不需要打开代码，直接使用 Menuconfig 配置后，编译再上传即可。</p><p>乐鑫文档; <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/kconfig.html">https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/kconfig.html</a> </p><p>Kconfig 标准; <a href="https://www.kernel.org/doc/html/latest/kbuild/kconfig-language.html">https://www.kernel.org/doc/html/latest/kbuild/kconfig-language.html</a></p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>例如下面这段点灯代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LEDPIN 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELAY_MS_TIME 2000</span></span><br><span class="line">...</span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pin_status = <span class="number">0</span>;</span><br><span class="line">    gpio_reset_pin(LEDPIN);</span><br><span class="line">    gpio_set_direction(LEDPIN, GPIO_MODE_OUTPUT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        gpio_set_level(LEDPIN, pin_status);</span><br><span class="line">        vTaskDelay(DELAY_MS_TIME);</span><br><span class="line">        pin_state = !pin_state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时如果需要修改引脚将需要找到对应文件修改代码里面的宏定义，相对来说比较麻烦。</p><h2 id="下面将演示如何通过-Manuconfig-配置"><a href="#下面将演示如何通过-Manuconfig-配置" class="headerlink" title="下面将演示如何通过 Manuconfig 配置:"></a>下面将演示如何通过 Manuconfig 配置:</h2><ul><li>先在main文件夹下创建 <code>Kconfig.projbuild</code> 内容如下:</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">menu <span class="string">&quot;blink_cust&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">config</span> LED_PIN</span><br><span class="line">int</span><br><span class="line">prompt <span class="string">&quot;ESP32上的LED连接到的引脚&quot;</span></span><br><span class="line">range <span class="number">0</span> <span class="number">39</span></span><br><span class="line">default <span class="number">2</span></span><br><span class="line">help</span><br><span class="line">GPIO号码可以通过查阅原理图得知</span><br><span class="line"></span><br><span class="line"><span class="built_in">config</span> DELAY_MS</span><br><span class="line">int</span><br><span class="line">prompt <span class="string">&quot;闪烁间隔时间(MS)&quot;</span></span><br><span class="line">range <span class="number">100</span> <span class="number">10000</span></span><br><span class="line">default <span class="number">1000</span></span><br><span class="line">help</span><br><span class="line">你要设置闪烁的间隔时间</span><br><span class="line"></span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure><ul><li>更改原来的代码</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pin_status = <span class="number">0</span>;</span><br><span class="line">    gpio_reset_pin(LED_PIN);</span><br><span class="line">    gpio_set_direction(LED_PIN, GPIO_MODE_OUTPUT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        gpio_set_level(LED_PIN, pin_status);</span><br><span class="line">        vTaskDelay(DELAY_MS);</span><br><span class="line">        pin_state = !pin_state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
          <category> ESP32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> ESP32 </tag>
            
            <tag> IDF </tag>
            
            <tag> Menuconfig </tag>
            
            <tag> 开发环境 </tag>
            
            <tag> 配置管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-IDF Cmake编写要点</title>
      <link href="/2022/11/08/ESP32-IDF-Cmake%E7%BC%96%E5%86%99%E8%A6%81%E7%82%B9/"/>
      <url>/2022/11/08/ESP32-IDF-Cmake%E7%BC%96%E5%86%99%E8%A6%81%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="1-文件通配-增量构建"><a href="#1-文件通配-增量构建" class="headerlink" title="1.文件通配 &amp; 增量构建"></a>1.文件通配 &amp; 增量构建</h2><p>在 ESP-IDF 组件中添加源文件的首选方法是在 COMPONENT_SRCS 中手动列出它们:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idf_component_register(SRCS library/a.c library/b.c platform/platform.c</span><br><span class="line">                       ...)</span><br></pre></td></tr></table></figure><p>这是在 CMake 中手动列出源文件的 最佳实践。然而，当有许多源文件都需要添加到构建中时，这种方法就会很不方便。ESP-IDF 构建系统因此提供了另一种替代方法，即使用 SRC_DIRS 来指定源文件:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idf_component_register(SRC_DIRS library platform</span><br><span class="line">                       ...)</span><br></pre></td></tr></table></figure><p>后台会使用通配符在指定的目录中查找源文件。但是请注意，在使用这种方法的时候，如果组件中添加了一个新的源文件，CMake 并不知道重新运行配置，最终该文件也没有被加入构建中。</p><p>如果是自己添加的源文件，这种折衷还是可以接受的，因为用户可以触发一次干净的构建，或者运行 idf.py reconfigure 来手动重启 CMake。但是，如果你需要与其他使用 Git 等版本控制工具的开发人员共享项目时，问题就会变得更加困难，因为开发人员有可能会拉取新的版本。</p><p>ESP-IDF 中的组件使用了第三方的 Git CMake 集成模块（&#x2F;tools&#x2F;cmake&#x2F;third_party&#x2F;GetGitRevisionDescription.cmake），任何时候源码仓库的提交记录发生了改变，该模块就会自动重新运行 CMake。即只要拉取了新的 ESP-IDF 版本，CMake 就会重新运行。</p><p>对于不属于 ESP-IDF 的项目组件，有以下几个选项供参考：</p><p>如果项目文件保存在 Git 中，ESP-IDF 会自动跟踪 Git 修订版本，并在它发生变化时重新运行 CMake。</p><p>如果一些组件保存在第三方 Git 仓库中（不在项目仓库或 ESP-IDF 仓库），则可以在组件 CMakeLists 文件中调用 git_describe 函数，以便在 Git 修订版本发生变化时自动重启 CMake。</p><p><strong>如果没有使用 Git，请记住在源文件发生变化时手动运行 idf.py reconfigure。</strong></p><p>使用 idf_component_register 的 SRCS 参数来列出项目组件中的所有源文件则可以完全避免这一问题。</p><p>具体选择哪一方式，就要取决于项目本身，以及项目用户。</p><h2 id="2-嵌入二进制数据"><a href="#2-嵌入二进制数据" class="headerlink" title="2. 嵌入二进制数据"></a>2. 嵌入二进制数据</h2><p>有时您的组件希望使用一个二进制文件或者文本文件，但是您又不希望将它们重新格式化为 C 源文件。</p><p>这时，您可以在组件注册中指定 EMBED_FILES 参数，用空格分隔要嵌入的文件名称:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idf_component_register(...</span><br><span class="line">                       EMBED_FILES server_root_cert.der)</span><br></pre></td></tr></table></figure><p>或者，如果文件是字符串，则可以使用EMBED_TXTFILES 变量，把文件的内容转成以 null 结尾的字符串嵌入:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idf_component_register(...</span><br><span class="line">                       EMBED_TXTFILES server_root_cert.pem)</span><br></pre></td></tr></table></figure><p>文件的内容会被添加到 Flash 的 .rodata 段，用户可以通过符号名来访问，如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">uint8_t</span> server_root_cert_pem_start[] <span class="keyword">asm</span>(<span class="string">&quot;_binary_server_root_cert_pem_start&quot;</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">uint8_t</span> server_root_cert_pem_end[]   <span class="keyword">asm</span>(<span class="string">&quot;_binary_server_root_cert_pem_end&quot;</span>);</span><br></pre></td></tr></table></figure><p>符号名会根据文件全名生成，如 EMBED_FILES 中所示，字符 &#x2F;、. 等都会被下划线替代。符号名称中的 _binary 前缀由 objcopy 命令添加，对文本文件和二进制文件都是如此。</p><p>如果要将文件嵌入到项目中，而非组件中，可以调用 target_add_binary_data 函数:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target_add_binary_data(myproject.elf <span class="string">&quot;main/data.bin&quot;</span> TEXT)</span><br></pre></td></tr></table></figure><p>文件的内容会被添加到 Flash 的 .rodata 段，用户可以通过符号名来访问，如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">uint8_t</span> server_root_cert_pem_start[] <span class="keyword">asm</span>(<span class="string">&quot;_binary_server_root_cert_pem_start&quot;</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">uint8_t</span> server_root_cert_pem_end[]   <span class="keyword">asm</span>(<span class="string">&quot;_binary_server_root_cert_pem_end&quot;</span>);</span><br></pre></td></tr></table></figure><p>符号名会根据文件全名生成，如 EMBED_FILES 中所示，字符 &#x2F;、. 等都会被下划线替代。符号名称中的 _binary 前缀由 objcopy 命令添加，对文本文件和二进制文件都是如此。<br>如果要将文件嵌入到项目中，而非组件中，可以调用 target_add_binary_data 函数:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target_add_binary_data(myproject.elf <span class="string">&quot;main/data.bin&quot;</span> TEXT)</span><br></pre></td></tr></table></figure><p>并将这行代码放在项目 CMakeLists.txt 的 project() 命令之后，修改 myproject.elf 为你自己的项目名。如果最后一个参数是 TEXT，那么构建系统会嵌入以 null 结尾的字符串，如果最后一个参数被设置为 BINARY，则将文件内容按照原样嵌入。</p><p>有关使用此技术的示例，请查看 file_serving 示例 protocols&#x2F;http_server&#x2F;file_serving&#x2F;main&#x2F;CMakeLists.txt 中的 main 组件，两个文件会在编译时加载并链接到固件中。</p><p>也可以嵌入生成的文件:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(OUTPUT my_processed_file.bin</span><br><span class="line">                  <span class="keyword">COMMAND</span> my_process_file_cmd my_unprocessed_file.bin)</span><br><span class="line">target_add_binary_data(my_target <span class="string">&quot;my_processed_file.bin&quot;</span> BINARY)</span><br></pre></td></tr></table></figure><p>上述示例中，my_processed_file.bin 是通过命令 my_process_file_cmd 从文件 my_unprocessed_file.bin 中生成，然后嵌入到目标中。</p><p>使用 DEPENDS 参数来指明对目标的依赖性:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_target</span>(my_process <span class="keyword">COMMAND</span> ...)</span><br><span class="line">target_add_binary_data(my_target <span class="string">&quot;my_embed_file.bin&quot;</span> BINARY DEPENDS my_process)</span><br></pre></td></tr></table></figure><p>target_add_binary_data 的 DEPENDS 参数确保目标首先执行。</p><p>———-转自IDF官方文档</p>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
            <tag> IDF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(十七)--任务通知3</title>
      <link href="/2022/11/06/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%83-%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A53/"/>
      <url>/2022/11/06/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%83-%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A53/</url>
      
        <content type="html"><![CDATA[<p> 再额外介绍剩下的几个关于任务通知的函数</p><h2 id="1-API介绍"><a href="#1-API介绍" class="headerlink" title="1.API介绍"></a>1.API介绍</h2><ul><li>发送通知</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotifyAndQuery</span><span class="params">( TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                                 <span class="type">uint32_t</span> ulValue,</span></span><br><span class="line"><span class="params">                                 eNotifyAction eAction,</span></span><br><span class="line"><span class="params">                                 <span class="type">uint32_t</span> *pulPreviousNotifyValue )</span>;</span><br><span class="line"> </span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyAndQueryIndexed</span><span class="params">( TaskHandle_t xTaskToNotify, </span></span><br><span class="line"><span class="params">                                        UBaseType_t uxIndexToNotify, </span></span><br><span class="line"><span class="params">                                        <span class="type">uint32_t</span> ulValue, </span></span><br><span class="line"><span class="params">                                        eNotifyAction eAction, </span></span><br><span class="line"><span class="params">                                        <span class="type">uint32_t</span> *pulPreviousNotifyValue )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyAndQueryFromISR</span><span class="params">( </span></span><br><span class="line"><span class="params">                      TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                      <span class="type">uint32_t</span> ulValue,</span></span><br><span class="line"><span class="params">                      eNotifyAction eAction,</span></span><br><span class="line"><span class="params">                      <span class="type">uint32_t</span> *pulPreviousNotifyValue,</span></span><br><span class="line"><span class="params">                      BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyAndQueryIndexedFromISR</span><span class="params">( </span></span><br><span class="line"><span class="params">                      TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                      UBaseType_t uxIndexToNotify</span></span><br><span class="line"><span class="params">                      <span class="type">uint32_t</span> ulValue,</span></span><br><span class="line"><span class="params">                      eNotifyAction eAction,</span></span><br><span class="line"><span class="params">                      <span class="type">uint32_t</span> *pulPreviousNotifyValue,</span></span><br><span class="line"><span class="params">                      BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">xTaskToNotify</td><td align="center">要通知到的任务的句柄</td></tr><tr><td align="center">ulValue</td><td align="center">通知内容</td></tr><tr><td align="center">eAction</td><td align="center">要执行的操作，内容如上节</td></tr><tr><td align="center">pulPreviousNotifyValue</td><td align="center">返回调用之前的通知内容</td></tr><tr><td align="center">uxIndexToNotify</td><td align="center">要发送到的通知的索引值</td></tr><tr><td align="center">返回值</td><td align="center">只可能返回pdPASS</td></tr></tbody></table><ul><li>（清除）通知状态</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotifyStateClear</span><span class="params">( TaskHandle_t xTask )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyStateClearIndexed</span><span class="params">( TaskHandle_t xTask, </span></span><br><span class="line"><span class="params">                                          UBaseType_t uxIndexToClear )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ulTaskNotifyValueClear</span><span class="params">( TaskHandle_t xTask, </span></span><br><span class="line"><span class="params">                                 <span class="type">uint32_t</span> ulBitsToClear )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ulTaskNotifyValueClearIndexed</span><span class="params">( TaskHandle_t xTask, </span></span><br><span class="line"><span class="params">                                        UBaseType_t uxIndexToClear,</span></span><br><span class="line"><span class="params">                                        <span class="type">uint32_t</span> ulBitsToClear )</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">xTask</td><td align="center">要操作通知的任务句柄</td></tr><tr><td align="center">uxIndexToClear</td><td align="center">操作指定索引值的通知</td></tr><tr><td align="center">ulBitsToClear</td><td align="center">要操作的位</td></tr><tr><td align="center">返回值</td><td align="center">BaseType_t：pdTRUE 或者 pdFALSE ；uint32_t：返回清空之前的通知值</td></tr></tbody></table><p>通过调用 xTaskNotifyStateClear 可以清除通知的“pending”状态，使其恢复可以使用的状态。</p><h2 id="2-程序实例"><a href="#2-程序实例" class="headerlink" title="2. 程序实例"></a>2. 程序实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> ulPreviousValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set bit 8 in the 0th notification value of the task referenced </span></span><br><span class="line"><span class="comment">by xTask1Handle. Store the task&#x27;s previous 0th notification </span></span><br><span class="line"><span class="comment">value (before bit 8 is set) in ulPreviousValue. */</span></span><br><span class="line">xTaskNotifyAndQueryIndexed( xTask1Handle, </span><br><span class="line">                            <span class="number">0</span>, </span><br><span class="line">                            ( <span class="number">1UL</span> &lt;&lt; <span class="number">8UL</span> ), </span><br><span class="line">                            eSetBits, </span><br><span class="line">                            &amp;ulPreviousValue );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Send a notification to the task referenced by xTask2Handle, </span></span><br><span class="line"><span class="comment">potentially removing the task from the Blocked state, but without </span></span><br><span class="line"><span class="comment">updating the task&#x27;s notification value.  Store the tasks notification </span></span><br><span class="line"><span class="comment">value in ulPreviousValue. */</span></span><br><span class="line">xTaskNotifyAndQuery( xTask2Handle, <span class="number">0</span>, eNoAction, &amp;ulPreviousValue );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the notification value of the task referenced by xTask3Handle </span></span><br><span class="line"><span class="comment">to 0x50, even if the task had not read its previous notification value. </span></span><br><span class="line"><span class="comment">The task&#x27;s previous notification value is of no interest so the last </span></span><br><span class="line"><span class="comment">parameter is set to NULL. */</span></span><br><span class="line">xTaskNotifyAndQuery( xTask3Handle, <span class="number">0x50</span>, eSetValueWithOverwrite,  <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the notification value of the task referenced by xTask4Handle </span></span><br><span class="line"><span class="comment">to 0xfff,</span></span><br><span class="line"><span class="comment">but only if to do so would not overwrite the task&#x27;s existing notification</span></span><br><span class="line"><span class="comment">value before the task had obtained it (by a call to xTaskNotifyWait()</span></span><br><span class="line"><span class="comment">or ulTaskNotifyTake()).  The task&#x27;s previous notification value is saved</span></span><br><span class="line"><span class="comment">in ulPreviousValue. */</span></span><br><span class="line"><span class="keyword">if</span>( xTaskNotifyAndQuery( xTask4Handle,</span><br><span class="line">                         <span class="number">0xfff</span>,</span><br><span class="line">                         eSetValueWithoutOverwrite,</span><br><span class="line">                         &amp;ulPreviousValue ) == pdPASS )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* The task&#x27;s notification value was updated. */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* The task&#x27;s notification value was not updated. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(十六)--任务通知2</title>
      <link href="/2022/11/06/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E5%85%AD-%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A52/"/>
      <url>/2022/11/06/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E5%85%AD-%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A52/</url>
      
        <content type="html"><![CDATA[<p>今天讲给大家演示如何使用直接任务通知来取代事件组的功能。 任务通知使用的是32bits，而之前讲的事件组是24bits，所以，只要不是涉及多个任务， 那么这个直接任务通知可以完全取代事件组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> TaskHandle_t xledTask = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESET_0  0b1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDBIT_1 0b10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDBIT_2 0b100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDBIT_3 0b1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDBIT_4 0b10000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDBIT_5 0b100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDBIT_6 0b1000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDBIT_7 0b10000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDBIT_8 0b100000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDBIT_9 0b1000000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟电话键盘的实现代码是抄的。</span></span><br><span class="line"><span class="comment">// 哪位大神有这个产品的链接，我来100个，实在是太复古了</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dialTask</span><span class="params">(<span class="type">void</span> * pvParam)</span> &#123;</span><br><span class="line">  <span class="type">const</span> byte INDIALPIN = <span class="number">33</span>;</span><br><span class="line">  <span class="type">const</span> byte PULSEPIN = <span class="number">32</span>;</span><br><span class="line">  pinMode(INDIALPIN, INPUT_PULLUP);</span><br><span class="line">  pinMode(PULSEPIN, INPUT_PULLUP);</span><br><span class="line"></span><br><span class="line">  byte counter = <span class="number">0</span>;</span><br><span class="line">  boolean inDialPinLastState;</span><br><span class="line">  boolean pulsPinLastState;</span><br><span class="line"></span><br><span class="line">  inDialPinLastState = digitalRead(INDIALPIN);</span><br><span class="line">  pulsPinLastState = digitalRead(PULSEPIN);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    boolean inDialPinState = digitalRead(INDIALPIN);</span><br><span class="line">    boolean pulsPinState = digitalRead(PULSEPIN);</span><br><span class="line">    <span class="keyword">if</span> (inDialPinState != inDialPinLastState) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!inDialPinState) &#123;</span><br><span class="line">        counter = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (counter) &#123;</span><br><span class="line">          counter = counter % <span class="number">10</span>;</span><br><span class="line">          <span class="comment">// ---- 横线上方Dial的判断代码为抄的 ----</span></span><br><span class="line">          <span class="comment">// Serial.println(counter);</span></span><br><span class="line">          <span class="type">uint32_t</span> ulEventGroup;</span><br><span class="line">          <span class="keyword">switch</span> (counter) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: ulEventGroup = RESET_0 ; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: ulEventGroup = LEDBIT_1 ; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: ulEventGroup = LEDBIT_2 ; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: ulEventGroup = LEDBIT_3 ; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>: ulEventGroup = LEDBIT_4 ; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>: ulEventGroup = LEDBIT_5 ; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>: ulEventGroup = LEDBIT_6 ; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>: ulEventGroup = LEDBIT_7 ; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>: ulEventGroup = LEDBIT_8 ; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>: ulEventGroup = LEDBIT_9 ; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: ulEventGroup = RESET_0 ; <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          xTaskNotify( xledTask,</span><br><span class="line">                       ulEventGroup,</span><br><span class="line">                       eSetBits);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// ---- 横线下方Dial的判断代码为抄的 ----</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      inDialPinLastState = inDialPinState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pulsPinLastState != pulsPinState) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!pulsPinLastState) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">      &#125;</span><br><span class="line">      pulsPinLastState = pulsPinState;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ledTask</span><span class="params">(<span class="type">void</span> *pvParam)</span> &#123;</span><br><span class="line"></span><br><span class="line">  byte led_pins[<span class="number">9</span>] = &#123;<span class="number">23</span>, <span class="number">22</span>, <span class="number">21</span>, <span class="number">19</span>, <span class="number">18</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (byte pin : led_pins) pinMode(pin, OUTPUT);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> ulNotifiedValue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    xTaskNotifyWait( pdFALSE,    <span class="comment">/* Don&#x27;t clear bits on entry. */</span></span><br><span class="line">                     ULONG_MAX,        <span class="comment">/* Clear all bits on exit. */</span></span><br><span class="line">                     &amp;ulNotifiedValue, <span class="comment">/* Stores the notified value. */</span></span><br><span class="line">                     portMAX_DELAY );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第0位 为 0 熄灭所有灯</span></span><br><span class="line">    <span class="keyword">if</span> (ulNotifiedValue &amp; (<span class="number">1</span> &lt;&lt; <span class="number">0</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">        digitalWrite(led_pins[i - <span class="number">1</span>], LOW);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对0-9位进行判断，如果第一位是1，那么点亮第一个LED，以此类推</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ulNotifiedValue &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">        digitalWrite(led_pins[i - <span class="number">1</span>], HIGH);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line"></span><br><span class="line">  xTaskCreate(dialTask, <span class="string">&quot;Dial Panel&quot;</span>, <span class="number">1024</span> * <span class="number">10</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">  xTaskCreate(ledTask, <span class="string">&quot;Nine LED&quot;</span>, <span class="number">1024</span> * <span class="number">10</span>, <span class="literal">NULL</span>, <span class="number">1</span>, &amp;xledTask);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(十五)--任务通知1</title>
      <link href="/2022/11/04/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%BA%94-%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A51/"/>
      <url>/2022/11/04/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%BA%94-%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A51/</url>
      
        <content type="html"><![CDATA[<p>Direct Task Notification是FreeRTOS 10版本以后的最重要的一个功能。他可以实现大部分二进制信号量，计数信号量，事件组，邮箱等等的功能。而且速度快45%，并且占用更少的内存，所以我们应该尽量使用任务通知这个功能。本集会深层次的讲解什么是notification，以及对他的读，写 和等待。一个任务将会有多个通知，一个通知包含**值（value）<strong>以及</strong>状态（status）**这两个内容，<strong>值</strong>占4个字节，<strong>状态</strong>占一个字节。</p><h2 id="1-API介绍"><a href="#1-API介绍" class="headerlink" title="1.API介绍"></a>1.API介绍</h2><h3 id="1-发送通知"><a href="#1-发送通知" class="headerlink" title="1.发送通知"></a>1.发送通知</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotifyGive</span><span class="params">( TaskHandle_t xTaskToNotify )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyGiveIndexed</span><span class="params">( TaskHandle_t xTaskToNotify, </span></span><br><span class="line"><span class="params">                                    UBaseType_t uxIndexToNotify )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskNotifyGiveFromISR</span><span class="params">( TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                              BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskNotifyGiveIndexedFromISR</span><span class="params">( TaskHandle_t xTaskToNotify, </span></span><br><span class="line"><span class="params">                                     UBaseType_t uxIndexToNotify, </span></span><br><span class="line"><span class="params">                                     BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><em>xTaskToNotify</em></td><td align="center">通知被发给指定的任务的句柄</td></tr><tr><td align="center"><em>uxIndexToNotify</em></td><td align="center">通知的检索值（一个任务可以有多个通知，可以指定放在哪个位置）</td></tr><tr><td align="center">返回值</td><td align="center">一定返回pdPASS</td></tr></tbody></table><h3 id="2-接受通知"><a href="#2-接受通知" class="headerlink" title="2.接受通知"></a>2.接受通知</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">ulTaskNotifyTake</span><span class="params">( BaseType_t xClearCountOnExit,</span></span><br><span class="line"><span class="params">                            TickType_t xTicksToWait )</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ulTaskNotifyTakeIndexed</span><span class="params">( UBaseType_t uxIndexToWaitOn, </span></span><br><span class="line"><span class="params">                                   BaseType_t xClearCountOnExit, </span></span><br><span class="line"><span class="params">                                   TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">xClearCountOnExit</td><td align="center">可以为pdTRUE和pdFALSE，为pdTRUE时整个通知会被恢复为0</td></tr><tr><td align="center">xTicksToWait</td><td align="center">最大等待时间</td></tr><tr><td align="center">uxIndexToWaitOn</td><td align="center">要等的通知的检索值</td></tr><tr><td align="center">返回值</td><td align="center">返回接受到的通知值</td></tr></tbody></table><p><strong>以上两种发送和接受通知的方式适合作为二进制信号量和计数信号量来使用，因为这相比下面的API来说更加简单。</strong></p><h3 id="3-等待通知"><a href="#3-等待通知" class="headerlink" title="3.等待通知"></a>3.等待通知</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotifyWait</span><span class="params">( <span class="type">uint32_t</span> ulBitsToClearOnEntry,</span></span><br><span class="line"><span class="params">                             <span class="type">uint32_t</span> ulBitsToClearOnExit,</span></span><br><span class="line"><span class="params">                             <span class="type">uint32_t</span> *pulNotificationValue,</span></span><br><span class="line"><span class="params">                             TickType_t xTicksToWait )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyWaitIndexed</span><span class="params">( UBaseType_t uxIndexToWaitOn, </span></span><br><span class="line"><span class="params">                                    <span class="type">uint32_t</span> ulBitsToClearOnEntry, </span></span><br><span class="line"><span class="params">                                    <span class="type">uint32_t</span> ulBitsToClearOnExit, </span></span><br><span class="line"><span class="params">                                    <span class="type">uint32_t</span> *pulNotificationValue, </span></span><br><span class="line"><span class="params">                                    TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ulBitsToClearOnEntry</td><td align="center">进入前清除的位，不清除就填入0x0000</td></tr><tr><td align="center">ulBitsToClearOnExit</td><td align="center">退出前清除的位，不清除则填入0x0000</td></tr><tr><td align="center">pulNotificationValue</td><td align="center">获取通知的值</td></tr><tr><td align="center">xTicksToWait</td><td align="center">最大等待时间</td></tr><tr><td align="center">uxIndexToWaitOn</td><td align="center">等待的消息的检索值</td></tr><tr><td align="center">返回值</td><td align="center">在规定时间获取到则返回pdTRUE，否则返回pdFALSE</td></tr></tbody></table><h3 id="4-发送通知"><a href="#4-发送通知" class="headerlink" title="4.发送通知"></a>4.发送通知</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotify</span><span class="params">( TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                         <span class="type">uint32_t</span> ulValue,</span></span><br><span class="line"><span class="params">                         eNotifyAction eAction )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyIndexed</span><span class="params">( TaskHandle_t xTaskToNotify, </span></span><br><span class="line"><span class="params">                                UBaseType_t uxIndexToNotify, </span></span><br><span class="line"><span class="params">                                <span class="type">uint32_t</span> ulValue, </span></span><br><span class="line"><span class="params">                                eNotifyAction eAction )</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">xTaskToNotify</td><td align="center">通知被发给指定的任务的句柄</td></tr><tr><td align="center">ulValue</td><td align="center">要更改的对方的通知的对应位</td></tr><tr><td align="center">eAction</td><td align="center">对对应位的操作，可以为eIncrement（增加一），eNoAction（不变），eSetBits（对应位置于1），eSetValueWithOverwrite（对应位置1，并且将其他原有为1的位置0），eSetValueWithoutOverwrite（对应位置1，但不把其他原有为1的位置0）</td></tr><tr><td align="center">uxIndexToNotify</td><td align="center">通知的索引值</td></tr><tr><td align="center">返回值</td><td align="center">只可能会返回pdPASS</td></tr></tbody></table><h2 id="2-程序实例"><a href="#2-程序实例" class="headerlink" title="2.程序实例"></a>2.程序实例</h2><h3 id="1-wait与notify"><a href="#1-wait与notify" class="headerlink" title="1. wait与notify"></a>1. wait与notify</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vAnEventProcessingTask</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> ulNotifiedValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    &#123;</span><br><span class="line">        xTaskNotifyWaitIndexed( <span class="number">0</span>,         <span class="comment">/* 等待第0个通知. */</span></span><br><span class="line">                                <span class="number">0x00</span>,      <span class="comment">/* 在进入时不清除任何位. */</span></span><br><span class="line">                                ULONG_MAX, <span class="comment">/* 在退出前清除所有位. */</span></span><br><span class="line">                                &amp;ulNotifiedValue, <span class="comment">/* 接受到的消息. */</span></span><br><span class="line">                                portMAX_DELAY );  <span class="comment">/* 无限等待. */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 处理接受到的消息. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( ( ulNotifiedValue &amp; <span class="number">0x01</span> ) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 第0位被置1 - 则触发对应函数. */</span></span><br><span class="line">            prvProcessBit0Event();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( ( ulNotifiedValue &amp; <span class="number">0x02</span> ) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 第1位被置1 - 则触发对应函数. */</span></span><br><span class="line">            prvProcessBit1Event();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( ( ulNotifiedValue &amp; <span class="number">0x04</span> ) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 第2位被置1 - 则触发对应函数. */</span></span><br><span class="line">            prvProcessBit2Event();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Etc. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-take和give"><a href="#2-take和give" class="headerlink" title="2. take和give"></a>2. take和give</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是一个中断句柄. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vANInterruptHandler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">BaseType_t xHigherPriorityTaskWoken;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clear the interrupt. */</span></span><br><span class="line">    prvClearInterruptSource();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* xHigherPriorityTaskWoken must be initialised to pdFALSE.  If calling</span></span><br><span class="line"><span class="comment">    vTaskNotifyGiveFromISR() unblocks the handling task, and the priority of</span></span><br><span class="line"><span class="comment">    the handling task is higher than the priority of the currently running task,</span></span><br><span class="line"><span class="comment">    then xHigherPriorityTaskWoken will automatically get set to pdTRUE. */</span></span><br><span class="line">    xHigherPriorityTaskWoken = pdFALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Unblock the handling task so the task can perform any processing necessitated</span></span><br><span class="line"><span class="comment">    by the interrupt.  xHandlingTask is the task&#x27;s handle, which was obtained</span></span><br><span class="line"><span class="comment">    when the task was created. */</span></span><br><span class="line">    vTaskNotifyGiveIndexedFromISR( xHandlingTask, <span class="number">0</span>, &amp;xHigherPriorityTaskWoken );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Force a context switch if xHigherPriorityTaskWoken is now set to pdTRUE.</span></span><br><span class="line"><span class="comment">    The macro used to do this is dependent on the port and may be called</span></span><br><span class="line"><span class="comment">    portEND_SWITCHING_ISR. */</span></span><br><span class="line">    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* A task that blocks waiting to be notified that the peripheral needs servicing,</span></span><br><span class="line"><span class="comment">processing all the events pending in the peripheral each time it is notified to </span></span><br><span class="line"><span class="comment">do so. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vHandlingTask</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line">BaseType_t xEvent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Block indefinitely (without a timeout, so no need to check the function&#x27;s</span></span><br><span class="line"><span class="comment">        return value) to wait for a notification.  Here the RTOS task notification</span></span><br><span class="line"><span class="comment">        is being used as a binary semaphore, so the notification value is cleared</span></span><br><span class="line"><span class="comment">        to zero on exit.  NOTE!  Real applications should not block indefinitely,</span></span><br><span class="line"><span class="comment">        but instead time out occasionally in order to handle error conditions</span></span><br><span class="line"><span class="comment">        that may prevent the interrupt from sending any more notifications. */</span></span><br><span class="line">        ulTaskNotifyTakeIndexed( <span class="number">0</span>,               <span class="comment">/* Use the 0th notification */</span></span><br><span class="line">                                 pdTRUE,          <span class="comment">/* Clear the notification value </span></span><br><span class="line"><span class="comment">                                                     before exiting. */</span></span><br><span class="line">                                 portMAX_DELAY ); <span class="comment">/* Block indefinitely. */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The RTOS task notification is used as a binary (as opposed to a</span></span><br><span class="line"><span class="comment">        counting) semaphore, so only go back to wait for further notifications</span></span><br><span class="line"><span class="comment">        when all events pending in the peripheral have been processed. */</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            xEvent = xQueryPeripheral();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( xEvent != NO_MORE_EVENTS )</span><br><span class="line">            &#123;</span><br><span class="line">                vProcessPeripheralEvent( xEvent );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span>( xEvent != NO_MORE_EVENTS );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(十四)--信息缓存</title>
      <link href="/2022/11/02/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E5%9B%9B-%E4%BF%A1%E6%81%AF%E7%BC%93%E5%AD%98/"/>
      <url>/2022/11/02/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E5%9B%9B-%E4%BF%A1%E6%81%AF%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>Message Buffer是基于Stream Buffer的。只是在每一次发送数据的时候多了四个字节的空间用于存放消息的大小。更具这个消息大小，读取放就可以一次读取出全部消息的内容。在视频中，也会对全部三个FreeRTOS的数据类型进行对比，分别是Queue，Stream Buffer 和 Message Buffer。</p><h2 id="1-API介绍"><a href="#1-API介绍" class="headerlink" title="1.API介绍"></a>1.API介绍</h2><h3 id="1-创建缓存"><a href="#1-创建缓存" class="headerlink" title="1.创建缓存"></a>1.创建缓存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MessageBufferHandle_t <span class="title function_">xMessageBufferCreate</span><span class="params">( <span class="type">size_t</span> xBufferSizeBytes )</span>;</span><br><span class="line"></span><br><span class="line">MessageBufferHandle_t <span class="title function_">xMessageBufferCreateWithCallback</span><span class="params">( </span></span><br><span class="line"><span class="params">                          <span class="type">size_t</span> xBufferSizeBytes,</span></span><br><span class="line"><span class="params">                          StreamBufferCallbackFunction_t pxSendCompletedCallback,</span></span><br><span class="line"><span class="params">                          StreamBufferCallbackFunction_t pxReceiveCompletedCallback )</span>;</span><br><span class="line"></span><br><span class="line">MessageBufferHandle_t <span class="title function_">xMessageBufferCreateStatic</span><span class="params">(</span></span><br><span class="line"><span class="params">                          <span class="type">size_t</span> xBufferSizeBytes,</span></span><br><span class="line"><span class="params">                          <span class="type">uint8_t</span> *pucMessageBufferStorageArea,</span></span><br><span class="line"><span class="params">                          StaticMessageBuffer_t *pxStaticMessageBuffer )</span>;</span><br><span class="line"></span><br><span class="line">MessageBufferHandle_t <span class="title function_">xMessageBufferCreateStaticWithCallback</span><span class="params">(</span></span><br><span class="line"><span class="params">                          <span class="type">size_t</span> xBufferSizeBytes,</span></span><br><span class="line"><span class="params">                          <span class="type">uint8_t</span> *pucMessageBufferStorageArea,</span></span><br><span class="line"><span class="params">                          StaticMessageBuffer_t *pxStaticMessageBuffer,</span></span><br><span class="line"><span class="params">                          StreamBufferCallbackFunction_t pxSendCompletedCallback,</span></span><br><span class="line"><span class="params">                          StreamBufferCallbackFunction_t pxReceiveCompletedCallback )</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">xBufferSizeBytes</td><td align="center">缓存大小</td></tr><tr><td align="center">pxSendCompletedCallback</td><td align="center">发送完成回调函数</td></tr><tr><td align="center">pxReceiveCompletedCallback</td><td align="center">接受完成回调函数</td></tr><tr><td align="center">pucMessageBufferStorageArea</td><td align="center">用于存放要写入到缓存的数据，大小必须比xBufferSizeBytes大一个字节。</td></tr><tr><td align="center">pxStaticMessageBuffer</td><td align="center">存放缓存的内存空间</td></tr><tr><td align="center">返回值</td><td align="center">创建失败返回NULL，成功返回句柄</td></tr></tbody></table><h3 id="2-发送数据到缓存"><a href="#2-发送数据到缓存" class="headerlink" title="2.发送数据到缓存"></a>2.发送数据到缓存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">xMessageBufferSend</span><span class="params">( MessageBufferHandle_t xMessageBuffer,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> <span class="type">void</span> *pvTxData,</span></span><br><span class="line"><span class="params">                           <span class="type">size_t</span> xDataLengthBytes,</span></span><br><span class="line"><span class="params">                           TickType_t xTicksToWait )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">xMessageBufferSendFromISR</span><span class="params">( MessageBufferHandle_t xMessageBuffer,</span></span><br><span class="line"><span class="params">                                  <span class="type">const</span> <span class="type">void</span> *pvTxData,</span></span><br><span class="line"><span class="params">                                  <span class="type">size_t</span> xDataLengthBytes,</span></span><br><span class="line"><span class="params">                                  BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure><p>与 <strong>stream buffer</strong> 的参数同理。</p><h3 id="3-从缓存接受数据"><a href="#3-从缓存接受数据" class="headerlink" title="3.从缓存接受数据"></a>3.从缓存接受数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">xMessageBufferReceive</span><span class="params">( MessageBufferHandle_t xMessageBuffer,</span></span><br><span class="line"><span class="params">                              <span class="type">void</span> *pvRxData,</span></span><br><span class="line"><span class="params">                              <span class="type">size_t</span> xBufferLengthBytes,</span></span><br><span class="line"><span class="params">                              TickType_t xTicksToWait )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">xMessageBufferReceiveFromISR</span><span class="params">( MessageBufferHandle_t xMessageBuffer,</span></span><br><span class="line"><span class="params">                                     <span class="type">void</span> *pvRxData,</span></span><br><span class="line"><span class="params">                                     <span class="type">size_t</span> xBufferLengthBytes,</span></span><br><span class="line"><span class="params">                                     BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure><h3 id="4-删除和重置缓存"><a href="#4-删除和重置缓存" class="headerlink" title="4.删除和重置缓存"></a>4.删除和重置缓存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vMessageBufferDelete</span><span class="params">( MessageBufferHandle_t xMessageBuffer )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xMessageBufferReset</span><span class="params">( MessageBufferHandle_t xMessageBuffer )</span>;</span><br></pre></td></tr></table></figure><h3 id="5-查询状态"><a href="#5-查询状态" class="headerlink" title="5.查询状态"></a>5.查询状态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">xMessageBufferSpacesAvailable</span><span class="params">( MessageBufferHandle_t xMessageBuffer )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xMessageBufferIsEmpty</span><span class="params">( MessageBufferHandle_t xMessageBuffer )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xMessageBufferIsFull</span><span class="params">( MessageBufferHandle_t xMessageBuffer )</span>;</span><br></pre></td></tr></table></figure><h2 id="2-代码实例"><a href="#2-代码实例" class="headerlink" title="2.代码实例"></a>2.代码实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;freertos/message_buffer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MessageBufferHandle_t xMessageBuffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> xMessageBufferSizeBytes = <span class="number">100</span>;</span><br><span class="line">xMessageBuffer = xMessageBufferCreate( xMessageBufferSizeBytes );</span><br><span class="line"></span><br><span class="line">String <span class="title function_">randomGPS</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> gps[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> counter = <span class="number">100</span>;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="keyword">switch</span> (random(<span class="number">0</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="comment">// 返回 经度 纬度 海拔</span></span><br><span class="line">      <span class="built_in">sprintf</span>(gps, <span class="string">&quot;%d-%d-%d-%d&quot;</span>, counter, random(<span class="number">100</span>, <span class="number">999</span>), random(<span class="number">100</span>, <span class="number">999</span>), random(<span class="number">100</span>, <span class="number">999</span>));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="comment">// 返回 经度 纬度</span></span><br><span class="line">      <span class="built_in">sprintf</span>(gps, <span class="string">&quot;%d-%d-%d&quot;</span>, counter, random(<span class="number">100</span>, <span class="number">999</span>), random(<span class="number">100</span>, <span class="number">999</span>));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="comment">// 返回 海拔</span></span><br><span class="line">      <span class="built_in">sprintf</span>(gps, <span class="string">&quot;%d-%d&quot;</span>, counter, random(<span class="number">100</span>, <span class="number">999</span>));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> String(gps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">readGPS</span><span class="params">(<span class="type">void</span> * pvParam)</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> xBytesSent; <span class="comment">//The number of bytes written to the message buffer.</span></span><br><span class="line">  String gpsInfo;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    gpsInfo = randomGPS(); <span class="comment">//随机发送不同长度的信息</span></span><br><span class="line">    xBytesSent = xMessageBufferSend( xMessageBuffer,</span><br><span class="line">                                     ( <span class="type">void</span> * ) &amp;gpsInfo,</span><br><span class="line">                                     <span class="keyword">sizeof</span>( gpsInfo ),</span><br><span class="line">                                     portMAX_DELAY );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( xBytesSent != <span class="keyword">sizeof</span>( gpsInfo ) )</span><br><span class="line">    &#123;</span><br><span class="line">      Serial.println(<span class="string">&quot;危险: xMessageBufferSend 发送数据不完整&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vTaskDelay(<span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpsDecoder</span><span class="params">(String gpsinfo)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">GPS</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> counter;</span><br><span class="line">    <span class="type">int</span> longVal;</span><br><span class="line">    <span class="type">int</span> latVal;</span><br><span class="line">    <span class="type">int</span> AltVal;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  String s1, s2, s3, s4;</span><br><span class="line">  <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">  String gpsinfo2 = gpsinfo;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    counter++;</span><br><span class="line">    <span class="type">int</span> index = gpsinfo.indexOf(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (gpsinfo.indexOf(<span class="string">&#x27;-&#x27;</span>) &lt; <span class="number">0</span>) gpsinfo = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    gpsinfo = gpsinfo.substring(index + <span class="number">1</span>, gpsinfo.length());</span><br><span class="line">  &#125; <span class="keyword">while</span> (gpsinfo.length() &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  GPS gps;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (counter) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      gps.counter = gpsinfo2.substring(<span class="number">0</span>, <span class="number">3</span>).toInt();</span><br><span class="line">      gps.longVal = <span class="number">-1</span>;</span><br><span class="line">      gps.latVal = <span class="number">-1</span>;</span><br><span class="line">      gps.AltVal = gpsinfo2.substring(<span class="number">4</span>, <span class="number">7</span>).toInt();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      gps.counter = gpsinfo2.substring(<span class="number">0</span>, <span class="number">3</span>).toInt();</span><br><span class="line">      gps.longVal = gpsinfo2.substring(<span class="number">4</span>, <span class="number">7</span>).toInt();</span><br><span class="line">      gps.latVal = gpsinfo2.substring(<span class="number">8</span>, <span class="number">11</span>).toInt();</span><br><span class="line">      gps.AltVal = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      gps.counter = gpsinfo2.substring(<span class="number">0</span>, <span class="number">3</span>).toInt();</span><br><span class="line">      gps.longVal = gpsinfo2.substring(<span class="number">4</span>, <span class="number">7</span>).toInt();</span><br><span class="line">      gps.latVal = gpsinfo2.substring(<span class="number">8</span>, <span class="number">11</span>).toInt();</span><br><span class="line">      gps.AltVal = gpsinfo2.substring(<span class="number">12</span>, <span class="number">15</span>).toInt();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">showGPS</span><span class="params">(<span class="type">void</span> * pvParam)</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> xReceivedBytes;</span><br><span class="line">  String gpsInfo;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> xMessageSizeMax = <span class="number">100</span>;</span><br><span class="line">  lcd.init();</span><br><span class="line">  lcd.backlight();</span><br><span class="line">  lcd.setCursor(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  lcd.print(<span class="string">&quot;   GPS INFO&quot;</span>); <span class="comment">//clear this line</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    xReceivedBytes = xMessageBufferReceive( xMessageBuffer,</span><br><span class="line">                                            ( <span class="type">void</span> * ) &amp;gpsInfo,</span><br><span class="line">                                            xMessageSizeMax, <span class="comment">//This sets the maximum length of the message that can be received.</span></span><br><span class="line">                                            portMAX_DELAY );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( xReceivedBytes &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      gpsDecoder(gpsInfo); <span class="comment">//解码，并且显示到屏幕上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vTaskDelay(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(十三)--流媒体缓存</title>
      <link href="/2022/11/02/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%89-%E6%B5%81%E5%AA%92%E4%BD%93%E7%BC%93%E5%AD%98/"/>
      <url>/2022/11/02/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%89-%E6%B5%81%E5%AA%92%E4%BD%93%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>FreeRTOS 10以后引入了一个新的数据类型就是 Stream Buffer。它和Queue最大的不同就是，Stream Buffer读写的大小没有限制，而Queue是预设值好固定的值。Stream Buffer 流媒体缓存顾名思义它的受众对象就是 流媒体 比如MP3，视频，在线电台等。</p><h2 id="1-API介绍"><a href="#1-API介绍" class="headerlink" title="1.API介绍"></a>1.API介绍</h2><h3 id="1-创建缓存"><a href="#1-创建缓存" class="headerlink" title="1.创建缓存"></a>1.创建缓存</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StreamBufferHandle_t <span class="title">xStreamBufferCreate</span><span class="params">( <span class="type">size_t</span> xBufferSizeBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">size_t</span> xTriggerLevelBytes )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">StreamBufferHandle_t <span class="title">xStreamBufferCreateWithCallback</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">size_t</span> xBufferSizeBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">size_t</span> xTriggerLevelBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">                         StreamBufferCallbackFunction_t pxSendCompletedCallback,</span></span></span><br><span class="line"><span class="params"><span class="function">                         StreamBufferCallbackFunction_t pxReceiveCompletedCallback )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">StreamBufferHandle_t <span class="title">xStreamBufferCreateStatic</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">size_t</span> xBufferSizeBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">size_t</span> xTriggerLevelBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">uint8_t</span> *pucStreamBufferStorageArea,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    StaticStreamBuffer_t *pxStaticStreamBuffer )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">StreamBufferHandle_t <span class="title">xStreamBufferCreateStaticWithCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">size_t</span> xBufferSizeBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">size_t</span> xTriggerLevelBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">uint8_t</span> *pucStreamBufferStorageArea,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    StaticStreamBuffer_t *pxStaticStreamBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    StreamBufferCallbackFunction_t pxSendCompletedCallback,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    StreamBufferCallbackFunction_t pxReceiveCompletedCallback )</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><em>xBufferSizeBytes</em></td><td align="center">一次能接受的最大字节数</td></tr><tr><td align="center"><em>xTriggerLevelBytes</em></td><td align="center">缓存内数据超过这个数值，才会被读取</td></tr><tr><td align="center"><em>pxSendCompletedCallback</em></td><td align="center">发送完成回调函数</td></tr><tr><td align="center"><em>pxReceiveCompletedCallback</em></td><td align="center">接受完成回调函数</td></tr><tr><td align="center">返回值</td><td align="center">返回NULL则内存不够无法创建，成功创建会返回句柄</td></tr></tbody></table><h3 id="2-发送到缓存"><a href="#2-发送到缓存" class="headerlink" title="2.发送到缓存"></a>2.发送到缓存</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">xStreamBufferSend</span><span class="params">( StreamBufferHandle_t xStreamBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">void</span> *pvTxData,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">size_t</span> xDataLengthBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TickType_t xTicksToWait )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">xStreamBufferSendFromISR</span><span class="params">( StreamBufferHandle_t xStreamBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> <span class="type">void</span> *pvTxData,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">size_t</span> xDataLengthBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 BaseType_t *pxHigherPriorityTaskWoken )</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><em>xStreamBuffer</em></td><td align="center">要发送到的缓存的句柄</td></tr><tr><td align="center"><em>pvTxData</em></td><td align="center">指向要发送数据的指针</td></tr><tr><td align="center"><em>xDataLengthBytes</em></td><td align="center">向缓存发送的最大字节数</td></tr><tr><td align="center"><em>pxHigherPriorityTaskWoken</em></td><td align="center">可为NULL，让正在等待数据的任务解除阻塞态，并且那个任务的优先级高于此值</td></tr><tr><td align="center">返回值</td><td align="center">有多少字节数据被写到了缓存中</td></tr></tbody></table><h3 id="3-从缓存接受数据"><a href="#3-从缓存接受数据" class="headerlink" title="3.从缓存接受数据"></a>3.从缓存接受数据</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">xStreamBufferReceive</span><span class="params">( StreamBufferHandle_t xStreamBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">void</span> *pvRxData,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">size_t</span> xBufferLengthBytes,<span class="comment">//一次最大接受多少字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">                             TickType_t xTicksToWait )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">xStreamBufferReceiveFromISR</span><span class="params">( StreamBufferHandle_t xStreamBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">void</span> *pvRxData,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">size_t</span> xBufferLengthBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    BaseType_t *pxHigherPriorityTaskWoken )</span></span>;</span><br></pre></td></tr></table></figure><h3 id="4-删除缓存"><a href="#4-删除缓存" class="headerlink" title="4.删除缓存"></a>4.删除缓存</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vStreamBufferDelete</span><span class="params">( StreamBufferHandle_t xStreamBuffer )</span></span>;</span><br></pre></td></tr></table></figure><h3 id="5-改变缓存"><a href="#5-改变缓存" class="headerlink" title="5.改变缓存"></a>5.改变缓存</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改变已经创建了的缓存的触发阈值</span></span><br><span class="line"><span class="function">BaseType_t <span class="title">xStreamBufferSetTriggerLevel</span><span class="params">( StreamBufferHandle_t xStreamBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">size_t</span> xTriggerLevel )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重置缓存，清空所有数据</span></span><br><span class="line"><span class="function">BaseType_t <span class="title">xStreamBufferReset</span><span class="params">( StreamBufferHandle_t xStreamBuffer )</span></span>;</span><br></pre></td></tr></table></figure><h3 id="6-缓存的相关信息"><a href="#6-缓存的相关信息" class="headerlink" title="6.缓存的相关信息"></a>6.缓存的相关信息</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回缓存内还有多少字节数据</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">xStreamBufferBytesAvailable</span><span class="params">( StreamBufferHandle_t xStreamBuffer )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回缓存还剩多少空间</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">xStreamBufferSpacesAvailable</span><span class="params">( StreamBufferHandle_t xStreamBuffer )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存是否为空，返回pdTRUE或者pdFALSE</span></span><br><span class="line"><span class="function">BaseType_t <span class="title">xStreamBufferIsEmpty</span><span class="params">( StreamBufferHandle_t xStreamBuffer )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存是否已满，返回pdTRUE或者pdFALSE</span></span><br><span class="line"><span class="function">BaseType_t <span class="title">xStreamBufferIsFull</span><span class="params">( StreamBufferHandle_t xStreamBuffer )</span></span>;</span><br></pre></td></tr></table></figure><h2 id="2-代码实例"><a href="#2-代码实例" class="headerlink" title="2.代码实例"></a>2.代码实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;freertos/stream_buffer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">StreamBufferHandle_t xStreamMusic = <span class="literal">NULL</span>; <span class="comment">//创建一个 Stream Buffer 的 handler</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Stream Buffer的最大尺寸，如果超出可能内存空间，那么创建Stream Buffer就会失败</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> xStreamBufferSizeBytes = <span class="number">540</span>;</span><br><span class="line">  <span class="comment">//Trigger Level - Stream Buffer内数据超过这个数值，才会被读取</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> xTriggerLevel = <span class="number">8</span>;</span><br><span class="line">xStreamMusic = <span class="built_in">xStreamBufferCreate</span>(xStreamBufferSizeBytes, xTriggerLevel);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">downloadTask</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123; <span class="comment">//下载音乐</span></span><br><span class="line">  String music;</span><br><span class="line">  <span class="type">size_t</span> xBytesSent; <span class="comment">//The number of bytes written to the stream buffer.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从网络下载音乐，放一些随机的延迟</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">random</span>(<span class="number">20</span>, <span class="number">40</span>); i++) <span class="built_in">vTaskDelay</span>(<span class="number">1</span>);</span><br><span class="line">    music = <span class="built_in">randomMusic</span>(); <span class="comment">//随机生成一些数据</span></span><br><span class="line"></span><br><span class="line">    xBytesSent = <span class="built_in">xStreamBufferSend</span>( xStreamMusic,</span><br><span class="line">                                    (<span class="type">void</span> *)&amp;music,</span><br><span class="line">                                    <span class="built_in">sizeof</span>(music),</span><br><span class="line">                                    portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( xBytesSent != <span class="built_in">sizeof</span>( music ) ) &#123;</span><br><span class="line">      Serial.<span class="built_in">println</span>(<span class="string">&quot;警告: xStreamBufferSend 写入数据出错&quot;</span>);  <span class="comment">//Optional</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vTaskDelay</span>(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">playBackTask</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123; <span class="comment">//解码并且播放</span></span><br><span class="line">  <span class="type">size_t</span> xReceivedBytes; <span class="comment">//The number of bytes read from the stream buffer.</span></span><br><span class="line">  <span class="type">size_t</span> xReadBytes = <span class="number">8</span>*<span class="number">10</span><span class="number">-1</span>;</span><br><span class="line">  String music;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    xReceivedBytes = <span class="built_in">xStreamBufferReceive</span>( xStreamMusic,</span><br><span class="line">                                           ( <span class="type">void</span> * ) &amp;music,</span><br><span class="line">                                           xReadBytes,</span><br><span class="line">                                           portMAX_DELAY );</span><br><span class="line">    <span class="keyword">if</span> ( xReceivedBytes &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">decode</span>(music);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(十二)--事件标志组</title>
      <link href="/2022/10/29/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%BA%8C-%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84/"/>
      <url>/2022/10/29/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%BA%8C-%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>事件组就是所有任务共享的3个字节(24个位)。事件 “标志 “是一个布尔值（1或0），用于指示一个事件是否发生。事件 “组 “是一组事件标志。事件标志只能为1或0，允许事件标志的状态存储在单个位中，事件组中所有事件标志的状态存储在单个变量中；事件组中每个事件标志的状态由类型为EventBits_t的变量中的单个位表示。因此，事件标志也被称为事件“位”。如果EventBits_t变量中的一位被设为1，则该位表示的事件已经发生。如果在EventBits_t变量中一个位被设置为0。那么由该位表示的事件没有发生。</p><h2 id="2-使用到的API"><a href="#2-使用到的API" class="headerlink" title="2.使用到的API"></a>2.使用到的API</h2><h3 id="1-创建与删除"><a href="#1-创建与删除" class="headerlink" title="1.创建与删除"></a>1.创建与删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventGroupHandle_t <span class="title">xEventGroupCreate</span><span class="params">( <span class="type">void</span> )</span></span>;<span class="comment">//创建事件组，返回的是创建的事件组的句柄</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vEventGroupDelete</span><span class="params">( EventGroupHandle_t xEventGroup )</span></span>;<span class="comment">//删除事件组，传入要删除事件组的句柄</span></span><br></pre></td></tr></table></figure><h3 id="2-等待事件组"><a href="#2-等待事件组" class="headerlink" title="2.等待事件组"></a>2.等待事件组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventBits_t <span class="title">xEventGroupWaitBits</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> EventGroupHandle_t xEventGroup,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> EventBits_t uxBitsToWaitFor,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> BaseType_t xClearOnExit,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> BaseType_t xWaitForAllBits,</span></span></span><br><span class="line"><span class="params"><span class="function">                       TickType_t xTicksToWait )</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><em>xEventGroup</em></td><td align="center">要等待的事件组的句柄</td></tr><tr><td align="center"><em>uxBitsToWaitFor</em></td><td align="center">要等待事件组的位，如（111）即为等bit0到bit2</td></tr><tr><td align="center"><em>xClearOnExit</em></td><td align="center">是否在等到该位后清除该位</td></tr><tr><td align="center"><em>xWaitForAllBits</em></td><td align="center">当要等多个位时是否要等全部还是等一个</td></tr><tr><td align="center"><em>xTicksToWait</em></td><td align="center">最大等待时间</td></tr><tr><td align="center">返回值</td><td align="center">返回当前事件组的内容</td></tr></tbody></table><h3 id="3-设置事件组"><a href="#3-设置事件组" class="headerlink" title="3.设置事件组"></a>3.设置事件组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set 给对应位置 1</span></span><br><span class="line"><span class="function">EventBits_t <span class="title">xEventGroupSetBits</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> EventBits_t uxBitsToSet )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BaseType_t <span class="title">xEventGroupSetBitsFromISR</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                          EventGroupHandle_t xEventGroup,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> EventBits_t uxBitsToSet,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BaseType_t *pxHigherPriorityTaskWoken )</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// clear 给对应位置 0</span></span><br><span class="line"><span class="function">EventBits_t <span class="title">xEventGroupClearBits</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                                 EventGroupHandle_t xEventGroup,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> EventBits_t uxBitsToClear )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BaseType_t <span class="title">xEventGroupClearBitsFromISR</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                                EventGroupHandle_t xEventGroup,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">const</span> EventBits_t uxBitsToClear )</span></span>;</span><br></pre></td></tr></table></figure><p>返回值：**BaseType_t **返回pdPASS，或者pdFAIL；<strong>EventBits_t</strong> 返回当前事件组。</p><h3 id="4-同步事件组"><a href="#4-同步事件组" class="headerlink" title="4.同步事件组"></a>4.同步事件组</h3><p>相当于<strong>set</strong>和<strong>wait</strong>的组合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventBits_t <span class="title">xEventGroupSync</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> EventBits_t uxBitsToSet,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> EventBits_t uxBitsToWaitFor,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TickType_t xTicksToWait )</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><em>xEventGroup</em></td><td align="center">要操作的事件组的句柄</td></tr><tr><td align="center"><em>uxBitsToSet</em></td><td align="center">要设置的位</td></tr><tr><td align="center"><em>uxBitsToWaitFor</em></td><td align="center">要等待的位</td></tr><tr><td align="center"><em>xTicksToWait</em></td><td align="center">最大等待时间</td></tr><tr><td align="center">返回值</td><td align="center">返回当前的事件组</td></tr></tbody></table><h2 id="3-使用实例"><a href="#3-使用实例" class="headerlink" title="3.使用实例"></a>3.使用实例</h2><h3 id="1-不使用sync"><a href="#1-不使用sync" class="headerlink" title="1.不使用sync"></a>1.不使用sync</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADDTOCART_0( 1 &lt;&lt; 0 ) <span class="comment">//0001 bit0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAYMENT_1( 1 &lt;&lt; 1 )  <span class="comment">//0010 bit1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVENTORY_2( 1 &lt;&lt; 2 ) <span class="comment">//0100 bit2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLBITS 0xFFFFFF <span class="comment">//24bits都是1</span></span></span><br><span class="line"></span><br><span class="line">EventGroupHandle_t xEventPurchase = <span class="literal">NULL</span>; <span class="comment">//创建event handler</span></span><br><span class="line">xEventPurchase = <span class="built_in">xEventGroupCreate</span>(); <span class="comment">//创建 event group</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">purchaseTask</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  EventBits_t uxBits;  <span class="comment">// Event Group 24Bits 的 值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    uxBits = <span class="built_in">xEventGroupSetBits</span>(xEventPurchase, ADDTOCART_0); <span class="comment">// 将bit 0 设置为1</span></span><br><span class="line">    <span class="keyword">if</span> ((uxBits &amp; ADDTOCART_0)) &#123;</span><br><span class="line">      Serial.<span class="built_in">println</span>(<span class="string">&quot;商品已经添加到了购物车，付款中...&quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">print</span>(<span class="string">&quot;   Event Group Value:&quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">println</span>(uxBits, BIN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uxBits = <span class="built_in">xEventGroupWaitBits</span> (xEventPurchase,  <span class="comment">//Event Group Handler</span></span><br><span class="line">                                  ADDTOCART_0 | PAYMENT_1 | INVENTORY_2,     <span class="comment">//等待Event Group中的那个Bit(s)</span></span><br><span class="line">                                  pdFALSE,         <span class="comment">//执行后，对应的Bits是否重置为 0</span></span><br><span class="line">                                  pdTRUE,          <span class="comment">//等待的Bits判断关系 True为 AND, False为 OR</span></span><br><span class="line">                                  xTimeOut);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//因为有可能在规定时间内还是无法等到该位，此时程序还是会继续向下，所以要加判断</span></span><br><span class="line">    <span class="keyword">if</span> ((uxBits &amp; ADDTOCART_0) &amp;&amp; (uxBits &amp; PAYMENT_1) &amp;&amp; (uxBits &amp; INVENTORY_2)) &#123;</span><br><span class="line">      <span class="comment">//随机延迟, 模拟网页显示，恭喜买家入手商品</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">random</span>(<span class="number">100</span>, <span class="number">200</span>); i++) <span class="built_in">vTaskDelay</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">xEventGroupClearBits</span>(xEventPurchase, ALLBITS); <span class="comment">//重置</span></span><br><span class="line">      uxBits = <span class="built_in">xEventGroupGetBits</span>(xEventPurchase); <span class="comment">//读取</span></span><br><span class="line"></span><br><span class="line">      Serial.<span class="built_in">println</span>(<span class="string">&quot;交易完成, RESET Event Group&quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">print</span>(<span class="string">&quot;   Event Group Value:&quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">println</span>(uxBits, BIN);</span><br><span class="line">      Serial.<span class="built_in">println</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vTaskDelete</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//vTaskDelay(10000);</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//         |</span></span><br><span class="line"><span class="comment">//         |</span></span><br><span class="line"><span class="comment">//         V</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paymentTask</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    EventBits_t uxBits;</span><br><span class="line"></span><br><span class="line">    uxBits = <span class="built_in">xEventGroupWaitBits</span> (xEventPurchase,  <span class="comment">//Event Group Handler</span></span><br><span class="line">                                  ADDTOCART_0,     <span class="comment">//等待Event Group中的那个Bit(s)</span></span><br><span class="line">                                  pdFALSE,         <span class="comment">//执行后，对应的Bits是否重置为 0</span></span><br><span class="line">                                  pdTRUE,          <span class="comment">//等待的Bits判断关系 True为 AND, False为 OR</span></span><br><span class="line">                                  xTimeOut);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代表ADDTOCART_0被设置为了 1</span></span><br><span class="line">    <span class="keyword">if</span> (uxBits &amp; ADDTOCART_0) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//随机延迟, 模拟付款验证过程</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">random</span>(<span class="number">100</span>, <span class="number">200</span>); i++) <span class="built_in">vTaskDelay</span>(<span class="number">10</span>);</span><br><span class="line">      uxBits = <span class="built_in">xEventGroupSetBits</span>(xEventPurchase, PAYMENT_1); <span class="comment">// 将bit1 PAYMENT_1 设置为1</span></span><br><span class="line"></span><br><span class="line">      Serial.<span class="built_in">println</span>(<span class="string">&quot;支付宝付款完成,可以出货...&quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">print</span>(<span class="string">&quot;   Event Group Value:&quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">println</span>(uxBits, BIN);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">vTaskDelete</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//         |</span></span><br><span class="line"><span class="comment">//         |</span></span><br><span class="line"><span class="comment">//         V</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inventoryTask</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  EventBits_t uxBits;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    uxBits = <span class="built_in">xEventGroupWaitBits</span> (xEventPurchase,  <span class="comment">//Event Group Handler</span></span><br><span class="line">                                  ADDTOCART_0 | PAYMENT_1,     <span class="comment">//等待Event Group中的那个Bit(s)</span></span><br><span class="line">                                  pdFALSE,         <span class="comment">//执行后，对应的Bits是否重置为 0</span></span><br><span class="line">                                  pdTRUE,          <span class="comment">//等待的Bits判断关系 True为 AND, False为 OR</span></span><br><span class="line">                                  xTimeOut);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 Event Group 中 ADDTOCART_0 和 PAYMENT_1 是否被设置为了0</span></span><br><span class="line">    <span class="keyword">if</span> ((uxBits &amp; ADDTOCART_0) &amp;&amp; (uxBits &amp; PAYMENT_1))  &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//随机延迟, 模拟仓库出货过程</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">random</span>(<span class="number">100</span>, <span class="number">200</span>); i++) <span class="built_in">vTaskDelay</span>(<span class="number">10</span>);</span><br><span class="line">      uxBits = <span class="built_in">xEventGroupSetBits</span>(xEventPurchase, INVENTORY_2); <span class="comment">// 将bit2 INVENTORY_2 设置为1</span></span><br><span class="line"></span><br><span class="line">      Serial.<span class="built_in">println</span>(<span class="string">&quot;仓库出货完成,快递已取货...&quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">print</span>(<span class="string">&quot;   Event Group Value:&quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">println</span>(uxBits, BIN);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">vTaskDelete</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用sync"><a href="#2-使用sync" class="headerlink" title="2.使用sync"></a>2.使用sync</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BOUGHT_PAID_SENT (ADDTOCART_0 | PAYMENT_1 | INVENTORY_2)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">purchaseTask</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  EventBits_t uxBits;  <span class="comment">// Event Group 24Bits 的 值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    uxBits = <span class="built_in">xEventGroupSync</span> (xEventPurchase,  <span class="comment">//Event Group Handler</span></span><br><span class="line">                              ADDTOCART_0,     <span class="comment">// 先将这个bit(s)设置为 1,然后再等待</span></span><br><span class="line">                              BOUGHT_PAID_SENT,  <span class="comment">//等待这些bits为 1</span></span><br><span class="line">                              xTimeOut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((uxBits &amp; BOUGHT_PAID_SENT) == BOUGHT_PAID_SENT)  &#123;</span><br><span class="line">      <span class="comment">//Serial.println(&quot;purchaseTask,已经自我了断. &quot;);</span></span><br><span class="line">      <span class="built_in">xQueueSend</span>(queueMsg, &amp;<span class="string">&quot;END purchaseTask&quot;</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="built_in">vTaskDelete</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paymentTask</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  EventBits_t uxBits;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//随机延迟, 模拟付款验证过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">random</span>(<span class="number">100</span>, <span class="number">200</span>); i++) <span class="built_in">vTaskDelay</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//Serial.println(&quot;支付宝付款完成,可以出货...&quot;);</span></span><br><span class="line">    <span class="built_in">xQueueSend</span>(queueMsg, &amp;<span class="string">&quot;Payment Received&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    uxBits = <span class="built_in">xEventGroupSync</span> (xEventPurchase,  <span class="comment">//Event Group Handler</span></span><br><span class="line">                              PAYMENT_1,     <span class="comment">// 先将这个bit(s)设置为 1,然后再等待</span></span><br><span class="line">                              BOUGHT_PAID_SENT,  <span class="comment">//等待这些bits为 1</span></span><br><span class="line">                              xTimeOut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((uxBits &amp; BOUGHT_PAID_SENT) == BOUGHT_PAID_SENT)  &#123;</span><br><span class="line">      <span class="comment">//Serial.println(&quot;paymentTask,已经自我了断. &quot;);</span></span><br><span class="line">      <span class="built_in">xQueueSend</span>(queueMsg, &amp;<span class="string">&quot;END paymentTask&quot;</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="built_in">vTaskDelete</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inventoryTask</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  EventBits_t uxBits;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机延迟, 模拟仓库出货过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">random</span>(<span class="number">100</span>, <span class="number">200</span>); i++) <span class="built_in">vTaskDelay</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//Serial.println(&quot;仓库出货完成,快递已取货...&quot;);</span></span><br><span class="line">    <span class="built_in">xQueueSend</span>(queueMsg, &amp;<span class="string">&quot;Inventory Out&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    uxBits = <span class="built_in">xEventGroupSync</span> (xEventPurchase,  <span class="comment">//Event Group Handler</span></span><br><span class="line">                              INVENTORY_2,     <span class="comment">// 先将这个bit(s)设置为 1,然后再等待</span></span><br><span class="line">                              BOUGHT_PAID_SENT,  <span class="comment">//等待这些bits为 1</span></span><br><span class="line">                              xTimeOut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((uxBits &amp; BOUGHT_PAID_SENT) == BOUGHT_PAID_SENT)  &#123;</span><br><span class="line">      <span class="comment">//Serial.println(&quot;inventoryTask,已经自我了断. &quot;);</span></span><br><span class="line">      <span class="built_in">xQueueSend</span>(queueMsg, &amp;<span class="string">&quot;END inventoryTask&quot;</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="built_in">vTaskDelete</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(十一)--计数信号量</title>
      <link href="/2022/10/29/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%80-%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>/2022/10/29/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%80-%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-使用到的API"><a href="#1-使用到的API" class="headerlink" title="1.使用到的API"></a>1.使用到的API</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t xHandler; <span class="comment">//创建Handler</span></span><br><span class="line">xHandler = <span class="built_in">xSemaphoreCreateCounting</span>(uxMaxCount, uxInitialCount); <span class="comment">//创建一个计数信号量 失败返回NULL，成功返回handler</span></span><br><span class="line"><span class="built_in">xSemaphoreGive</span>(xHandler); <span class="comment">//二进制信号量+1</span></span><br><span class="line"><span class="built_in">xSemaphoreTake</span>(xHanlder, timeout); <span class="comment">//二进制信号量-1 返回pdPASS, 或者pdFAIL</span></span><br><span class="line"><span class="built_in">xSemaphoreGiveFromISR</span>(xHandler, portBASE_TYPE *pxHigherPriorityTaskWoken); <span class="comment">//中断里面用的give函数，第二个参数的官方解释如下）</span></span><br></pre></td></tr></table></figure><p><strong>pxHigherPriorityTaskWoken</strong>：对某个信号量而言,可能有不止一个任务处于阻塞态在等待其有效。调用 xSemaphoreGiveFromISR()会让信号量变为有效,所以会让其中一个等待任务切出阻塞态。如果调用 xSemaphoreGiveFromISR()使得一个任务解除阻塞,并且这个任务的优先级高于当前任务(也就是被中断的任务),那么 xSemaphoreGiveFromISR()会在 函 数 内 部 将 *pxHigherPriorityTaskWoken 设为pdTRUE。如果 xSemaphoreGiveFromISR() 将 此 值 设 为pdTRUE,则在中断退出前应当进行一次上下文切换。这样才能保证中断直接返回到就绪态任务中优先级最高的任务中。</p><h2 id="2-具体使用例"><a href="#2-具体使用例" class="headerlink" title="2.具体使用例"></a>2.具体使用例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t xSemaPhone = <span class="literal">NULL</span>;</span><br><span class="line">xSemaPhone = <span class="built_in">xSemaphoreCreateCounting</span>(<span class="number">3</span>, <span class="number">0</span>);<span class="comment">//创建一个最大为3，初始值为0的计数信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">void</span> *paParam)</span> </span>&#123; <span class="comment">//制造者 give</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">random</span>(<span class="number">100</span>, <span class="number">200</span>); i++) <span class="built_in">vTaskDelay</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">xSemaphoreGive</span>(xSemaPhone);</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;...... 手机再放出一台,&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123; <span class="comment">//消费者 take</span></span><br><span class="line">  String website = *(String *)pvParam;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">xSemaphoreTake</span>(xSemaPhone, portMAX_DELAY) == pdTRUE ) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">random</span>(<span class="number">200</span>, <span class="number">400</span>); i++) <span class="built_in">vTaskDelay</span>(<span class="number">10</span>);</span><br><span class="line">      Serial.<span class="built_in">print</span>(website);</span><br><span class="line">      Serial.<span class="built_in">println</span>(<span class="string">&quot;抢到并销售一台: &quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(十)--二进制信号量</title>
      <link href="/2022/10/27/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>/2022/10/27/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-使用到的API"><a href="#1-使用到的API" class="headerlink" title="1.使用到的API"></a>1.使用到的API</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t xHandler; <span class="comment">//创建Handler</span></span><br><span class="line">xHandler = <span class="built_in">xSemaphoreCreateBinary</span>(); <span class="comment">//创建一个二进制信号量 返回NULL，或者handler</span></span><br><span class="line"><span class="built_in">xSemaphoreGive</span>(xHandler); <span class="comment">//二进制信号量+1</span></span><br><span class="line"><span class="built_in">xSemaphoreTake</span>(xHanlder, timeout); <span class="comment">//二进制信号量-1 返回pdPASS, 或者pdFAIL</span></span><br><span class="line"><span class="built_in">xSemaphoreGiveFromISR</span>(xHandler, portBASE_TYPE *pxHigherPriorityTaskWoken); <span class="comment">//中断里面用的give函数，第二个参数的官方解释如下）</span></span><br></pre></td></tr></table></figure><p><strong>pxHigherPriorityTaskWoken</strong>：对某个信号量而言,可能有不止一个任务处于阻塞态在等待其有效。调用 xSemaphoreGiveFromISR()会让信号量变为有效,所以会让其中一个等待任务切出阻塞态。如果调用 xSemaphoreGiveFromISR()使得一个任务解除阻塞,并且这个任务的优先级高于当前任务(也就是被中断的任务),那么 xSemaphoreGiveFromISR()会在 函 数 内 部 将 *pxHigherPriorityTaskWoken 设为pdTRUE。如果 xSemaphoreGiveFromISR() 将 此 值 设 为pdTRUE,则在中断退出前应当进行一次上下文切换。这样才能保证中断直接返回到就绪态任务中优先级最高的任务中。</p><h2 id="2-使用案例（按键控制LED开关）"><a href="#2-使用案例（按键控制LED开关）" class="headerlink" title="2.使用案例（按键控制LED开关）"></a>2.使用案例（按键控制LED开关）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">flashLED</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pinMode</span>(<span class="number">23</span>, OUTPUT);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//当信号量为1时则take就会返回pdPASS，并且信号量-1变为0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">xSemaphoreTake</span>( xSemaLED, timeOut) == pdPASS )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">xTaskGetTickCount</span>() - btnDeounce) &lt; <span class="number">100</span>) &#123; <span class="comment">//用于button debounce</span></span><br><span class="line">        <span class="built_in">digitalWrite</span>(<span class="number">23</span>, !<span class="built_in">digitalRead</span>(<span class="number">23</span>));</span><br><span class="line">        <span class="built_in">vTaskDelay</span>(<span class="number">1000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readBtn</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pinMode</span>(<span class="number">22</span>, INPUT_PULLUP);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">digitalRead</span>(<span class="number">22</span>) == LOW) &#123;</span><br><span class="line">      <span class="built_in">xSemaphoreGive</span>(xSemaLED);<span class="comment">//信号量+1（1+1还是1）当信号量已经为1时还give就会返回pdFAIL</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//OR 写成中断</span></span><br><span class="line"><span class="built_in">attachInterrupt</span>(<span class="number">22</span>, ISR, FALLING);</span><br><span class="line"><span class="function"><span class="type">void</span> IRAM_ATTR <span class="title">ISR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  btnDeounce = <span class="built_in">xTaskGetTickCountFromISR</span>();</span><br><span class="line">  <span class="built_in">xSemaphoreGiveFromISR</span>(xSemaLED, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过镜像恢复方式为nanopi配置系统</title>
      <link href="/2022/10/27/%E9%80%9A%E8%BF%87%E9%95%9C%E5%83%8F%E6%81%A2%E5%A4%8D%E6%96%B9%E5%BC%8F%E4%B8%BAnanopi%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/10/27/%E9%80%9A%E8%BF%87%E9%95%9C%E5%83%8F%E6%81%A2%E5%A4%8D%E6%96%B9%E5%BC%8F%E4%B8%BAnanopi%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-请烧录如下固件"><a href="#1-请烧录如下固件" class="headerlink" title="1.请烧录如下固件"></a>1.请烧录如下固件</h2><p><code>nanopi-neo-core_eflasher_friendlycore-xenial_4.14_armhf_YYYYMMDD.img.zip</code></p><p>烧录完的SD卡将会有以下三个分区(SD必须大于16G)</p><ul><li>boot</li><li>rootfs</li><li>FriendlyARM</li></ul><p>Windows下可能需要相关软件才能读取到所有分区。</p><h2 id="2-通过串口控制nanopi"><a href="#2-通过串口控制nanopi" class="headerlink" title="2.通过串口控制nanopi"></a>2.通过串口控制nanopi</h2><p>请按照图示连接nanopi，串口请连接到UART0，波特率必须为115200</p><p><img src="https://wiki.friendlyelec.com/wiki/images/5/53/NEO_Core_pinout-02.jpg"></p><p><img src="https://wiki.friendlyelec.com/wiki/images/b/b4/USB2UART-NEO-Core.jpg"></p><p>插入SD卡，并通过串口连接到电脑进入终端（如果串口显示为空可以尝试回车几次）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">普通用户：</span><br><span class="line">用户名: pi</span><br><span class="line">密码: pi</span><br><span class="line"></span><br><span class="line">Root用户：</span><br><span class="line">用户名: root</span><br><span class="line">密码: fa</span><br></pre></td></tr></table></figure><p>在终端以超级管理员身份执行指令 <code>eflasher</code> 后有如下界面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------------</span><br><span class="line">  EFlasher v1.2 b190111 running on NanoPC-T4</span><br><span class="line">    Doc: http://wiki.friendlyelec.com/wiki/index.php/EFlasher</span><br><span class="line">    eMMC: 14.56 GB</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Select an OS to install:</span></span><br><span class="line">    1) Android 8</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Select your backup target device:</span></span><br><span class="line">     tf) [*] TF card  (/dev/mmcblk0p1 - 4.27 GB free - 5.67 GB total - fuseblk)</span><br><span class="line">    usb) [ ] USB disk  (&lt;none&gt;)</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Backup eMMC flash to TF card:</span></span><br><span class="line">    Not enough free disk space on your TF card</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Restore eMMC flash from backup file:</span></span><br><span class="line">    No backup files found</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Configure automatic job:</span></span><br><span class="line">    aui) Automatic installing (Curr:Off)</span><br><span class="line">    aur) Automatic restoring (Curr:Off)</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Format drive</span></span><br><span class="line">    ftf) Format TF card back to original size</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Enter an option (1/tf/usb/aui/aur/ftf) :</span></span><br></pre></td></tr></table></figure><p>若SD卡为第一次使用请先输入ftf，然后关机转至电脑，向SD第三个分区放入 <code>nanopi-neo-core-emmc.raw</code> 备份文件再重新开启并进入 nanopi 执行 <code>r1</code> 选项，否则直接输入 <code>r1</code> 选项并回车即可烧写镜像。</p><p>注意：烧写完后的nanopi为<code>静态ip 192.168.137.219</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> NanoPi </tag>
            
            <tag> Underwater </tag>
            
            <tag> Robot </tag>
            
            <tag> H3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(九)--队列在任务间传输数据</title>
      <link href="/2022/10/26/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B9%9D-%E9%98%9F%E5%88%97%E5%9C%A8%E4%BB%BB%E5%8A%A1%E9%97%B4%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE/"/>
      <url>/2022/10/26/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B9%9D-%E9%98%9F%E5%88%97%E5%9C%A8%E4%BB%BB%E5%8A%A1%E9%97%B4%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-队列相关的API"><a href="#1-队列相关的API" class="headerlink" title="1.队列相关的API"></a>1.队列相关的API</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个队列</span></span><br><span class="line"><span class="function">QueueHandle_t <span class="title">xQueueCreate</span><span class="params">( UBaseType_t uxQueueLength,<span class="comment">//队列数据单元深度</span></span></span></span><br><span class="line"><span class="params"><span class="function">                             UBaseType_t uxItemSize<span class="comment">//每个数据单元有多少字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">                          )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列里发数据</span></span><br><span class="line"><span class="function">BaseType_t <span class="title">xQueueSend</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                      QueueHandle_t xQueue,<span class="comment">//队列的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> <span class="type">void</span> * pvItemToQueue,<span class="comment">//要向队列写入的数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">                      TickType_t xTicksToWait<span class="comment">//最长等待时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">                      )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从队列里取数据</span></span><br><span class="line"><span class="function">BaseType_t <span class="title">xQueueReceive</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                            QueueHandle_t xQueue,<span class="comment">//队列的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">void</span> *pvBuffer,<span class="comment">//传入要用于接受数据的变量</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            TickType_t xTicksToWait<span class="comment">//最长等待时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        )</span></span>;</span><br></pre></td></tr></table></figure><h2 id="2-使用案例"><a href="#2-使用案例" class="headerlink" title="2.使用案例"></a>2.使用案例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义数据类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sensor_t</span>&#123;</span><br><span class="line">  byte deviceID;</span><br><span class="line">  <span class="type">float</span> value1;</span><br><span class="line">  <span class="type">float</span> value2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建队列</span></span><br><span class="line">QueueHandle_t queueSensor = <span class="built_in">xQueueCreate</span>(<span class="number">8</span>, <span class="built_in">sizeof</span>(<span class="type">sensor_t</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备好数据</span></span><br><span class="line"><span class="type">sensor_t</span> dht22Sensor;</span><br><span class="line">dht22Sensor.value1 = dht22.temperature;</span><br><span class="line">dht22Sensor.value2 = dht22.humidity;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列写入数据，如果返回的不是pdPASS则表示队列已满（在规定的timeOut时间内无法写入到队列内数据则会返回 errQUEUE_FULL )</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">xQueueSend</span>(queueSensor, &amp;dht22Sensor, timeOut) != pdPASS)</span><br><span class="line">&#123;</span><br><span class="line">      Serial.<span class="built_in">println</span>(<span class="string">&quot;DHT22: Queue is full.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取队列中的数据，如果队列中没有数据则返回 errQUEUE_FULL )</span></span><br><span class="line"><span class="type">sensor_t</span> data;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">xQueueReceive</span>(queueSensor, &amp;data, timeOut) == pdPASS)</span><br><span class="line">&#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(data.value1);</span><br><span class="line">    Serial.<span class="built_in">println</span>(data.value2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(八)--看门狗</title>
      <link href="/2022/10/25/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AB-%E7%9C%8B%E9%97%A8%E7%8B%97/"/>
      <url>/2022/10/25/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AB-%E7%9C%8B%E9%97%A8%E7%8B%97/</url>
      
        <content type="html"><![CDATA[<p> 需要知道的是：</p><ul><li>Arduion-ESP32 默认在 Core 0 的 IDLE 任务开启了看门狗 时间为 5000 ticks &#x3D; 5秒（若IDLE(0)无法运行，所以不能喂狗，将导致系统5秒后重启）</li><li>Core 0 和 Core 1 都运行了 FreeRTOS 的IDLE任务，优先级为 0（IDLE任务是用于清理被删除任务的内存）</li><li>Core 1 loopBack任务就是Arduino的 setup 和 loop 优先级为 1</li></ul><p>API：需要包含 <em>esp_task_wdt.h</em> 文件</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">esp_task_wdt_init</td><td align="center">初始化任务看门狗计时器</td></tr><tr><td align="center">esp_task_wdt_deinit</td><td align="center">取消初始化任务监视计时器</td></tr><tr><td align="center">esp_task_wdt_add</td><td align="center">将任务订阅到任务监视计时器</td></tr><tr><td align="center">esp_task_wdt_reset</td><td align="center">当前正在运行的任务重置任务看门狗计时器</td></tr><tr><td align="center">esp_task_wdt_delete</td><td align="center">从任务监视计时器取消订阅任务</td></tr><tr><td align="center">esp_task_wdt_status</td><td align="center">查询任务是否已订阅任务监视程序计时器</td></tr></tbody></table><p>官方使用例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_task_wdt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">a_task</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">esp_task_wdt_add</span>(<span class="literal">NULL</span>);<span class="comment">//给当前任务添加看门狗</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">esp_task_wdt_reset</span>();<span class="comment">//喂狗</span></span><br><span class="line">        <span class="built_in">vTaskDelay</span>(<span class="built_in">pdMS_TO_TICKS</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">esp_task_wdt_delete</span>(<span class="literal">NULL</span>);<span class="comment">//删除当前任务的看门狗</span></span><br><span class="line">    <span class="built_in">vTaskDelete</span>(<span class="literal">NULL</span>);<span class="comment">//删除自身任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">app_mian</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">esp_task_wdt_init</span>(TWDT_TIMEOUT_S, <span class="literal">false</span>);<span class="comment">//arduino上不需要init，因为官方已经写到你程序前面了</span></span><br><span class="line">    <span class="built_in">esp_task_wdt_add</span>(<span class="built_in">xTaskGetIdleTaskHandleForCPU</span>(<span class="number">0</span>));<span class="comment">//为IDLE开启任务看门狗</span></span><br><span class="line">    <span class="built_in">esp_task_wdt_delete</span>(<span class="built_in">xTaskGetIdleTaskHandleForCPU</span>(<span class="number">0</span>));<span class="comment">//删除IDLE任务的看门狗</span></span><br><span class="line">    <span class="built_in">esp_task_wdt_status</span>(<span class="built_in">xTaskGetIdleTaskHandleForCPU</span>(<span class="number">0</span>));<span class="comment">//因为IDLE任务看门狗被删除所以会返回ESP_ERR_NOT_FOUND</span></span><br><span class="line">    <span class="built_in">esp_task_wdt_deinit</span>();<span class="comment">//关闭任务看门狗</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面给出给所有狗喂食的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//feedTheDogInAllTasks()</span></span><br><span class="line"><span class="comment">//通过寄存器给所有任务的狗喂时</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;soc/timer_group_struct.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;soc/timer_group_reg.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">feedTheDogInAllTasks</span><span class="params">()</span> </span>&#123; <span class="comment">//通过寄存器给所有任务的狗喂时</span></span><br><span class="line">  <span class="comment">// feed dog 0</span></span><br><span class="line">  TIMERG0.wdt_wprotect = TIMG_WDT_WKEY_VALUE; <span class="comment">// write enable</span></span><br><span class="line">  TIMERG0.wdt_feed = <span class="number">1</span>;                     <span class="comment">// feed dog</span></span><br><span class="line">  TIMERG0.wdt_wprotect = <span class="number">0</span>;                 <span class="comment">// write protect</span></span><br><span class="line">  <span class="comment">// feed dog 1</span></span><br><span class="line">  TIMERG1.wdt_wprotect = TIMG_WDT_WKEY_VALUE; <span class="comment">// write enable</span></span><br><span class="line">  TIMERG1.wdt_feed = <span class="number">1</span>;                     <span class="comment">// feed dog</span></span><br><span class="line">  TIMERG1.wdt_wprotect = <span class="number">0</span>;                 <span class="comment">// write protect</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(七)--任务优先级</title>
      <link href="/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%83-%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7/"/>
      <url>/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%83-%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p> 在ESP32上的FreeRTOS上优先级越高其值越大</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">API：</span><br><span class="line">    <span class="comment">//设置优先级</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">vTaskPrioritySet</span><span class="params">( TaskHandle_t xTask, UBaseType_t uxNewPriority )</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取TashHandle任务优先级</span></span><br><span class="line">    <span class="function">UBaseType_t <span class="title">uxTaskPriorityGet</span><span class="params">( TaskHandle_t xTask )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前任务优先级</span></span><br><span class="line">    <span class="function">UBaseType_t <span class="title">uxTaskPriorityGet</span><span class="params">(<span class="literal">NULL</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退让资源，任务调度器会重新评估任务，将资源分配给同等级或者更高等级任务</span></span><br><span class="line">    <span class="comment">//注意不会把资源给低等级任务</span></span><br><span class="line">    <span class="built_in">tastYIELD</span>();</span><br></pre></td></tr></table></figure><p>当高优先级的任务没有阻塞或者挂起时，同一核心的低优先级的任务将得不到运行，这就是为什么要用 vTaskDelay 的原因了 ——— 让任务进入阻塞，而普通的delay将没有这样的效果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(六)--任务的状态和管理</title>
      <link href="/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AD-%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E7%AE%A1%E7%90%86/"/>
      <url>/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AD-%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p> 介绍了任务的全部状态和对相关任务进行管理。</p><h2 id="1-任务的状态"><a href="#1-任务的状态" class="headerlink" title="1.任务的状态"></a>1.任务的状态</h2><ul><li><p>Blocked阻塞态</p><p>任务会在进入block的函数处停止，并且不占用CPU资源</p></li><li><p>Suspended挂起态</p><p>任务会完全暂停，不占用CPU资源</p></li><li><p>Ready就绪态</p><p>准备运行该任务</p></li><li><p>Running运行态</p><p>任务运行中</p></li></ul><h2 id="2-任务的管理"><a href="#2-任务的管理" class="headerlink" title="2.任务的管理"></a>2.任务的管理</h2><p>会使用到如下函数API：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType_t <span class="title">xTaskCreate</span><span class="params">(,,,,,)</span></span>; <span class="comment">//任务创建</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vTaskDelete</span><span class="params">( TaskHandle_t xTask )</span></span>; <span class="comment">//任务删除 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vTaskSuspend</span><span class="params">( TaskHandle_t xTaskToSuspend )</span></span>; <span class="comment">//任务暂停</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vTaskResume</span><span class="params">( TaskHandle_t xTaskToResume )</span></span>; <span class="comment">//任务恢复</span></span><br><span class="line"><span class="comment">//相关参数都为要操作任务的句柄，为NULL时则操作当前任务</span></span><br></pre></td></tr></table></figure><p>下面是使用实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t theTestHandle = <span class="literal">NULL</span>; <span class="comment">//Task Handler</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">xTaskCreate</span>(radioBilibili, <span class="string">&quot;The　test code&quot;</span>, <span class="number">1024</span> * <span class="number">8</span>, <span class="literal">NULL</span>, <span class="number">1</span>, &amp;theTestHandle);<span class="comment">//创建任务</span></span><br><span class="line"><span class="built_in">vTaskSuspend</span>(theTestHandle);<span class="comment">//挂起任务</span></span><br><span class="line"><span class="built_in">vTaskDelay</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">vTaskResume</span>(theTestHandle);<span class="comment">//恢复任务</span></span><br><span class="line"><span class="built_in">vTaskDelete</span>(theTestHandle);<span class="comment">//删除任务</span></span><br><span class="line">theTestHandle = <span class="literal">NULL</span>; <span class="comment">//最后还需要手动将handler设置为空</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(五)--任务内存优化</title>
      <link href="/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%94-%E4%BB%BB%E5%8A%A1%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
      <url>/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%94-%E4%BB%BB%E5%8A%A1%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p> 介绍了如何获取剩余内存堆空间，如何准确分配内存。</p><h2 id="1-获取剩余内存堆空间"><a href="#1-获取剩余内存堆空间" class="headerlink" title="1.获取剩余内存堆空间"></a>1.获取剩余内存堆空间</h2><p>下面两个是由ESP官方提供的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ESP.<span class="built_in">getHeapSize</span>()<span class="comment">//获取ESP32的总堆空间，返回int</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ESP.<span class="built_in">getFreeHeap</span>()<span class="comment">//获取ESP32剩余堆空间，返回int</span></span><br></pre></td></tr></table></figure><p>下面介绍获取单个任务的剩余堆空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">uxTaskGetStackHighWaterMark</span><span class="params">(taskHandle)</span><span class="comment">//获取指定任务的剩余内存，参数为NULL时获取当前任务的剩余内存</span></span></span><br></pre></td></tr></table></figure><p>下面是一个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> heapSize = ESP.<span class="built_in">getHeapSize</span>();</span><br><span class="line">Serial.<span class="built_in">print</span>(<span class="string">&quot;Total Heap Size:  &quot;</span>);</span><br><span class="line">Serial.<span class="built_in">print</span>(heapSize);</span><br><span class="line">Serial.<span class="built_in">println</span>(<span class="string">&quot; Bytes&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> heapFree = ESP.<span class="built_in">getFreeHeap</span>();</span><br><span class="line">Serial.<span class="built_in">print</span>(<span class="string">&quot;Free Heap Size:  &quot;</span>);</span><br><span class="line">Serial.<span class="built_in">print</span>(heapFree);</span><br><span class="line">Serial.<span class="built_in">println</span>(<span class="string">&quot; Bytes&quot;</span>);</span><br><span class="line">Serial.<span class="built_in">println</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> taskMem = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">xTaskCreate</span>(task, <span class="string">&quot;&quot;</span>, taskMem, <span class="literal">NULL</span>, <span class="number">1</span>, &amp;taskHandle);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vTaskDelay</span>(<span class="number">2000</span>);<span class="comment">//如果在任务刚创建就获取剩余内存那么结果将会不准</span></span><br><span class="line"><span class="type">int</span> waterMark = <span class="built_in">uxTaskGetStackHighWaterMark</span>(taskHandle);</span><br><span class="line">Serial.<span class="built_in">print</span>(<span class="string">&quot;Task Free Memory: &quot;</span>);</span><br><span class="line">Serial.<span class="built_in">print</span>(waterMark);</span><br><span class="line">Serial.<span class="built_in">println</span>(<span class="string">&quot; Bytes&quot;</span>);</span><br><span class="line">Serial.<span class="built_in">print</span>(<span class="string">&quot;Task Used Memory: &quot;</span>);</span><br><span class="line">Serial.<span class="built_in">print</span>(taskMem - waterMark);</span><br><span class="line">Serial.<span class="built_in">println</span>(<span class="string">&quot; Bytes&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="2-正确分配内存"><a href="#2-正确分配内存" class="headerlink" title="2.正确分配内存"></a>2.正确分配内存</h2><p>提供获取剩余内存来算出任务使用的内存，再将xTaskCreate的对应参数设置为使用内存的2倍是较为保险的设置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(二)--MUTEX互斥量的应用</title>
      <link href="/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C-MUTEX%E4%BA%92%E6%96%A5%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C-MUTEX%E4%BA%92%E6%96%A5%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>包括任务函数使用全局变量和添加互斥量避免“冒险与竞争”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用前的准备</span></span><br><span class="line">SemaphoreHandle_t xMutextheTestTask = <span class="literal">NULL</span>; <span class="comment">//创建信号量Handler</span></span><br><span class="line">TickType_t timeOut = <span class="number">1000</span>; <span class="comment">//用于获取信号量的Timeout 1000 ticks</span></span><br><span class="line">xMutextheTestTask = <span class="built_in">xSemaphoreCreateMutex</span>(); <span class="comment">//创建MUTEX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">theTestTask</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在timeout时间内任务会block来等待获取到密钥(返回NULL则获取失败)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">xSemaphoreTake</span>(xMutextheTestTask, timeOut) == pdPASS) &#123;</span><br><span class="line">        <span class="comment">//写入被保护的数据，这个过程需要尽可能快</span></span><br><span class="line">        <span class="built_in">xSemaphoreGive</span>(xMutextheTestTask); <span class="comment">//释放钥匙</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用到的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">xSemaphoreCreateMutex</span>();</span><br><span class="line"><span class="comment">//创建信号量，返回 SemaphoreHandle_t 句柄用于调用该互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">xSemaphoreTake</span>(xMutextheTestTask, timeOut);</span><br><span class="line"><span class="comment">//获取互斥量，xMutextheTestTask为互斥量的句柄，timeOut为最长等待获取时间，等待期间任务会block</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">xSemaphoreGive</span>(xMutextheTestTask);</span><br><span class="line"><span class="comment">//释放互斥量，xMutextheTestTask为互斥量的句柄，之后别人才能获取到互斥量</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
          <category> ESP32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> ESP32 </tag>
            
            <tag> FreeRTOS </tag>
            
            <tag> 实时操作系统 </tag>
            
            <tag> 多任务 </tag>
            
            <tag> 互斥量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(三)--任务等待绝对的时间</title>
      <link href="/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89-%E4%BB%BB%E5%8A%A1%E7%AD%89%E5%BE%85%E7%BB%9D%E5%AF%B9%E7%9A%84%E6%97%B6%E9%97%B4/"/>
      <url>/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89-%E4%BB%BB%E5%8A%A1%E7%AD%89%E5%BE%85%E7%BB%9D%E5%AF%B9%E7%9A%84%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>在任务中我们可以使用 vTaskDelay(pdTICKS_TO_MS(delayTimeMS)) 来延时对应时间，但是实际上这个延迟将会有误差，如果我们的任务对频率要求更高的话就可以使用如下函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vTaskDelayUntil</span>(&amp;xLastWakeTime, xFrequency);</span><br><span class="line"><span class="comment">//xLastWakeTime为调用该函数时的tickCount，xFrequency为需要等待的tick，期间函数将会阻塞，结束时tickCount的值会为xLastWakeTime + xFrequency</span></span><br></pre></td></tr></table></figure><p>下面是使用样例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用前准备</span></span><br><span class="line"><span class="comment">//最后一次唤醒的tick count，第一次使用需要赋值</span></span><br><span class="line"><span class="comment">//以后此变量会由vTaskDelayUntil自动更新</span></span><br><span class="line">TickType_t xLastWakeTime = <span class="built_in">xTaskGetTickCount</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> TickType_t xFrequency = <span class="built_in">pdTICKS_TO_MS</span>(<span class="number">1000</span>); <span class="comment">// 间隔 1000 ms = 3 seconds</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用延迟函数</span></span><br><span class="line">Serial.<span class="built_in">println</span>(<span class="built_in">xTaskGetTickCount</span>());</span><br><span class="line"><span class="built_in">vTaskDelayUntil</span>(&amp;xLastWakeTime, xFrequency);</span><br><span class="line">Serial.<span class="built_in">println</span>(<span class="built_in">xTaskGetTickCount</span>());<span class="comment">//可以看到TickCount加了xFrequency</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
          <category> ESP32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> ESP32 </tag>
            
            <tag> FreeRTOS </tag>
            
            <tag> 实时操作系统 </tag>
            
            <tag> 任务调度 </tag>
            
            <tag> 时间管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(四)--软件定时器的应用</title>
      <link href="/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B-%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B-%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>先介绍创建软件定时器的API函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TimerHandle_t <span class="title">xTimerCreate</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcTimerName,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> TickType_t xTimerPeriodInTicks,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> UBaseType_t uxAutoReload,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">void</span> * <span class="type">const</span> pvTimerID,</span></span></span><br><span class="line"><span class="params"><span class="function">                            TimerCallbackFunction_t pxCallbackFunction )</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>pcTimerName</td><td>定时器名字，用于调试目的，方便识别不同的定时器。</td></tr><tr><td>xTimerPeriodInTicks</td><td>定时器周期，单位系统时钟Tick。</td></tr><tr><td>uxAutoReload</td><td>选择周期模式还是单次模式，若参数为pdTRUE，则表示选择周期模式，若参数为pdFALSE，则表示选择单次模式。（自动重装载值）</td></tr><tr><td>pvTimerID</td><td>是定时器ID，当创建不同的定时器，但使用相同的<a href="https://so.csdn.net/so/search?q=%E5%9B%9E%E8%B0%83&spm=1001.2101.3001.7020">回调</a>函数时，在回调函数中通过不同的ID号来区分不同的定时器。</td></tr><tr><td>pxCallbackFunction</td><td>定时器回调函数。</td></tr><tr><td>返回值</td><td>创建成功返回定时器的句柄，由于FreeRTOSCongfig.h文件中heap空间不足，或者定时器周期设置为0，会返回NULL。</td></tr></tbody></table><p>还有其他的函数配合使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">xTimerStart</span>(timerHandle, timeOutTick)</span><br><span class="line"><span class="comment">//timerHandle为需要开启的定时器的句柄</span></span><br><span class="line"><span class="comment">//timeOutTick表示如果定时器被占用时需要等待的时间，最大值为portMAX_DELAY</span></span><br><span class="line"><span class="comment">//成功开启定时器返回pdPASS</span></span><br></pre></td></tr></table></figure><p>下面是使用实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用前准备</span></span><br><span class="line">TimerHandle_t theTimerHandle;</span><br><span class="line">theTimerHandle = <span class="built_in">xTimerCreate</span>(<span class="string">&quot;the test&quot;</span>,</span><br><span class="line">                            <span class="number">2000</span>,<span class="comment">//延迟2000个Tick</span></span><br><span class="line">                            pdFALSE,<span class="comment">//不要自动重载</span></span><br><span class="line">                            (<span class="type">void</span> *)<span class="number">0</span>,<span class="comment">//定时器ID，因为要传入void指针，所以要强制转换</span></span><br><span class="line">                            theTestCallback);<span class="comment">//计时结束后要调用的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正式使用定时器</span></span><br><span class="line"><span class="built_in">xTimerStart</span>(theTimerHandle, portMAX_DELAY);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(一)--创建FreeRTOS任务</title>
      <link href="/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%88%9B%E5%BB%BAFreeRTOS%E4%BB%BB%E5%8A%A1/"/>
      <url>/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%88%9B%E5%BB%BAFreeRTOS%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>包括任务的创建和向任务传参</p><h2 id="1-创建任务"><a href="#1-创建任务" class="headerlink" title="1.创建任务"></a>1.创建任务</h2><p>任务调用的函数模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">theTestTask</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123;</span><br><span class="line"><span class="comment">//your code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任务是由 C 语言函数实现的。唯一特别的只是任务的函数原型，其必须返回 void， 而且带有一个 void 指针参数。</p><p>调用FreeRTOS提供的函数创建任务</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vportBASE_TYPE <span class="title">xTaskCreate</span><span class="params">( pdTASK_CODE pvTaskCode, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> <span class="type">signed</span> portCHAR * <span class="type">const</span> pcName, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">unsigned</span> portSHORT usStackDepth, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">void</span> *pvParameters, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">unsigned</span> portBASE_TYPE uxPriority, </span></span></span><br><span class="line"><span class="params"><span class="function">xTaskHandle *pxCreatedTask )</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th align="left">描述</th></tr></thead><tbody><tr><td>pvTaskCode</td><td align="left">指向你要运行的函数的指针</td></tr><tr><td>pcName</td><td align="left">具有描述性的任务名。这个参数不会被 FreeRTOS 使用。其只是单 纯地用于辅助调试。识别一个具有可读性的名字总是比通过句柄来 识别容易得多。</td></tr><tr><td>usStackDepth</td><td align="left">用于告诉内核为它分配多大的栈空间,单位是字节（byte）。注意，这与原版FreeRTOS不同，原版为字（word）。</td></tr><tr><td>pvParameters</td><td align="left">传向任务函数的参数</td></tr><tr><td>uxPriority</td><td align="left">指定任务执行的优先级。优先级的取值范围可以从最低优先级 0 到 最高优先级(configMAX_PRIORITIES – 1)。需要注意的是值越大优先级越高。</td></tr><tr><td>pxCreatedTask</td><td align="left">用于传出任务的句柄。这个句柄将在 API 调用中对 该创建出来的任务进行引用，比如改变任务优先级，或者删除任务。不需要则可以为NULL。</td></tr><tr><td>返回值</td><td align="left">成功创建则为 pdTRUE , 若为errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY 则表示栈空间不足无法创建。</td></tr></tbody></table><p>因为ESP32为双核MCU，所以还提供了 xTaskCreatePinnedToCore 函数用于指定在哪个核心上运行，只需在正常 xTaskCreate 最后参数后面再加个 const BaseType_t xCoreID 参数，函数名改为 xTaskCreatePinnedToCore 即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">xTaskCreatePinnedToCore</span>(theTestTask, <span class="string">&quot;For test&quot;</span>, <span class="number">1024</span>, <span class="literal">NULL</span>, <span class="number">1</span>, &amp;theTaskHandle, <span class="number">1</span>);<span class="comment">//指定到了CORE1运行该任务</span></span><br></pre></td></tr></table></figure><p>需要知道的是,ESP32的WiFi相关程序会运行在CORE0，如果在连续使用WiFi时又在CORE0跑任务将会导致WiFi出现各种问题。第二点，Arduino的setup函数和loop函数是运行在CORE1的一个FreeRTOS任务，如果并不需要使用到这几个函数，则也可以删除该任务。</p><h2 id="2-向任务函数传参"><a href="#2-向任务函数传参" class="headerlink" title="2.向任务函数传参"></a>2.向任务函数传参</h2><p>举一个向任务函数传递结构体的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LEDFLASH</span>&#123;</span><br><span class="line">  byte pin;</span><br><span class="line">  <span class="type">int</span> delayTime;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义任务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ledFlash</span><span class="params">(<span class="type">void</span> *pt)</span> </span>&#123;</span><br><span class="line">  LEDFLASH * ptLedFlash = (LEDFLASH *)pt;<span class="comment">//将void指针转为结构体指针</span></span><br><span class="line">  byte pin = ptLedFlash-&gt;pin;</span><br><span class="line">  <span class="type">int</span> delayTime = ptLedFlash-&gt;delayTime;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pinMode</span>(pin,OUTPUT);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">digitalWrite</span>(pin, !<span class="built_in">digitalRead</span>(pin));</span><br><span class="line">    <span class="built_in">vTaskDelay</span>(delayTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建任务线程</span></span><br><span class="line">LEDFLASH led1;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">xTaskCreate</span>(ledFlash,</span><br><span class="line">                  <span class="string">&quot;FLASH LED&quot;</span>,</span><br><span class="line">                  <span class="number">1024</span>,</span><br><span class="line">                  (<span class="type">void</span> *)&amp;led1,</span><br><span class="line">                  <span class="number">1</span>,</span><br><span class="line">                  <span class="literal">NULL</span>) == pdPASS)</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;led1 flash task Created.&quot;</span>);</span><br></pre></td></tr></table></figure><p>其中出现了 vTaskDelay(delayTick) 函数，表示任务block阻塞指定时间，在ESP32上一个Tick等于一个ms，但是我依然推荐规范写法 vTaskDelay(delayTimeMS &#x2F; portTICK_RATE_MS) 或者 vTaskDelay(pdTICKS_TO_MS(delayTimeMS))</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
          <category> ESP32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> ESP32 </tag>
            
            <tag> FreeRTOS </tag>
            
            <tag> 任务创建 </tag>
            
            <tag> 实时操作系统 </tag>
            
            <tag> 多任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下给单片机烧录程序时提示没有权限</title>
      <link href="/2022/09/21/linux%E4%B8%8B%E7%BB%99%E5%8D%95%E7%89%87%E6%9C%BA%E7%83%A7%E5%BD%95%E7%A8%8B%E5%BA%8F%E6%97%B6%E6%8F%90%E7%A4%BA%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90/"/>
      <url>/2022/09/21/linux%E4%B8%8B%E7%BB%99%E5%8D%95%E7%89%87%E6%9C%BA%E7%83%A7%E5%BD%95%E7%A8%8B%E5%BA%8F%E6%97%B6%E6%8F%90%E7%A4%BA%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<p>  这是因为该用户所在的用户组不包含USB的相关权限，我们可以将用户添加到有权限的用户组，或者将对应串口开放给所有人使用。</p><h2 id="添加到dialout用户组"><a href="#添加到dialout用户组" class="headerlink" title="添加到dialout用户组"></a>添加到dialout用户组</h2><p>打开终端输入:<code>sudo usermod -aG dialout USERNAME</code></p><h2 id="开放串口权限"><a href="#开放串口权限" class="headerlink" title="开放串口权限"></a>开放串口权限</h2><p>添加如下内容到 <em>&#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;</em> 下的rules文件:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KERNEL==“ttyACM[0-9]*”, MODE=“0666”</span><br><span class="line">KERNEL==“ttyUSB[0-9]*”, MODE=“0666”</span><br></pre></td></tr></table></figure><p>最好自己创建一个新文件,名称要符合规范。</p><h2 id="单独给串口开放权限"><a href="#单独给串口开放权限" class="headerlink" title="单独给串口开放权限"></a>单独给串口开放权限</h2><p>使用管理员权限:</p><p><code>sudo chmod 777 /dev/ttyACM0</code></p><p>缺点是每次插拔设备后都需要重新更改权限。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
            <tag> Linux </tag>
            
            <tag> Arduino </tag>
            
            <tag> PlatformIO </tag>
            
            <tag> 权限管理 </tag>
            
            <tag> USB串口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++下返回引用类型的函数</title>
      <link href="/2022/09/17/C-%E4%B8%8B%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0/"/>
      <url>/2022/09/17/C-%E4%B8%8B%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-先申明一个类"><a href="#1-先申明一个类" class="headerlink" title="1. 先申明一个类"></a>1. 先申明一个类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> a, <span class="type">int</span> b);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Test&amp; <span class="title">addA</span><span class="params">(Test &amp;t)</span></span>;<span class="comment">//返回值为Test类的引用，传入参数为Test的引用</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setA</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setB</span><span class="params">(<span class="type">int</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-定义一个函数"><a href="#2-定义一个函数" class="headerlink" title="2. 定义一个函数"></a>2. 定义一个函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Test&amp; <span class="title">Test::addA</span><span class="params">(Test&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = t.<span class="built_in">getA</span>();</span><br><span class="line">    <span class="keyword">this</span> -&gt; a += a;<span class="comment">//即使两个变量名称一样，但this指针区分了这两个变量</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回整个对象本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-具体应用"><a href="#3-具体应用" class="headerlink" title="3. 具体应用"></a>3. 具体应用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> A, <span class="type">int</span> B):<span class="built_in">a</span>(A), <span class="built_in">b</span>(B)&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Test&amp; <span class="title">addA</span><span class="params">(Test &amp;t)</span></span>;<span class="comment">//返回值为Test类的引用，传入参数为Test的引用</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getA</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span> -&gt; a;&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getB</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span> -&gt; b;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test&amp; <span class="title">Test::addA</span><span class="params">(Test&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = t.<span class="built_in">getA</span>();</span><br><span class="line">    <span class="keyword">this</span> -&gt; a += a;<span class="comment">//即使两个变量名称一样，但this指针区分了这两个变量</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回整个对象本身</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;before: &quot;</span> &lt;&lt; t1.<span class="built_in">getA</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    t1.<span class="built_in">addA</span>(t2).<span class="built_in">addA</span>(t2).<span class="built_in">addA</span>(t2);  </span><br><span class="line">    <span class="comment">//t1的a加了3次t2的a，最后等于1+3+3+3 = 10,如果没有返回引用则只能加一次，就不能像这样套娃了</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;after: &quot;</span> &lt;&lt; t1.<span class="built_in">getA</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 函数 </tag>
            
            <tag> 引用 </tag>
            
            <tag> 编程技巧 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Aroma香气(阿罗马)安装教程</title>
      <link href="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-判断你的机器状态"><a href="#1-判断你的机器状态" class="headerlink" title="1.判断你的机器状态"></a>1.判断你的机器状态</h2><ul><li>是否已经破解？<ul><li>提拉米苏破解<ol><li>则直接拷贝增量包至SD卡根目录,提示覆盖则选择覆盖</li><li>将SD卡插入机器后,如果你的机器已经设置了开机启动提拉米苏,则在开机的同时按住<em><strong>X</strong></em>键进入选单选择<em><strong>aroma</strong></em>即可进入阿罗马系统.</li></ol></li><li>脑锻炼破解，网页(固化)破解,冷启动破解等等<ol><li>进入下面的破解步骤(如果为冷启动要先卸载冷启动)</li></ol></li></ul></li></ul><h2 id="2-破解前的准备"><a href="#2-破解前的准备" class="headerlink" title="2. 破解前的准备"></a>2. 破解前的准备</h2><ul><li>容量大于4GB的SD卡</li><li>带有PAD的WIIU</li><li>良好的网络</li><li>提前备份好机器的NAND</li></ul><ol><li>以FAT32格式化SD卡后下载<em><strong>Aroma(阿罗马)整合包</strong></em>的压缩文件并解压到SD卡根目录.</li><li>保证SD卡根目录有<em><strong>wiiu</strong></em>文件夹.</li><li>将SD卡插入机器并开机.</li><li>在桌面选择进入浏览器,这将会有两种情况:<ul><li>如果你为脑锻炼固化破解,则需要手动输入<em><strong>wiiuexploit.xyz</strong></em>这个网址并进入,待网页完全加载完之后后点击<strong>Run Exploit</strong>按钮即可.</li><li>如果你为网页破解(固化),则按照正常进入破解的方式即可.</li></ul></li><li>这时你应该能成功进入<em><strong>Environment Loader</strong></em>选单(黑色界面如下),如果卡死请强制重启之后继续尝试.</li></ol><p><img src="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/1.jpg"></p><ol start="6"><li>选择第二项<em><strong>installer</strong></em>,并进入到如下界面.</li></ol><p><img src="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/2.jpg"></p><ol start="7"><li>点击<em><strong>check</strong></em>,并进入如下界面.</li></ol><p><img src="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/3.jpg"></p><ol start="8"><li>点击<em><strong>Install &#x2F; update</strong></em>,并进入如下界面.</li></ol><p><img src="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/4.jpg"></p><ol start="9"><li>点击<em><strong>Install</strong></em>,并进入如下界面.</li></ol><p><img src="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/5.jpg"></p><ol start="10"><li>按<em><strong>A</strong></em>即可关闭主机.</li><li>待主机完全关闭后再打开主机.</li><li>在桌面上找到<strong>健康与安全程序</strong>(⚠️)如下,点击进入.</li></ol><p><img src="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/6.jpg"></p><p>14.在如下选单中光标移动到<em><strong>aroma</strong></em>后按<strong>Y</strong>,后移动到<em><strong>install</strong></em>上按<strong>A</strong>.</p><p><img src="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/1.jpg"></p><p>15.进入到如下界面后点击<em><strong>check</strong></em>.</p><p><img src="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/2.jpg"></p><ol start="16"><li>下图选择<em><strong>Boot options</strong></em>,然后按照提示按<strong>A</strong>,最后机器自动关机.</li></ol><p><img src="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/3.jpg"></p><p>17.再次开启机器后应该会直接进入到如下界面,请移动到<em><strong>Wii U Menu</strong></em>选项后先按<strong>Y</strong>后按<strong>A</strong>.</p><p><img src="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/9.jpg"></p><p>如果为红色警告页面如下,请按<strong>B</strong>忽略.</p><p><img src="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/8.jpg"></p><ol start="18"><li>然后你应该就已经顺利进入桌面了,破解到此结束.</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> WiiU </tag>
            
            <tag> Aroma </tag>
            
            <tag> Game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在C语言下在结构体内加入函数</title>
      <link href="/2022/09/08/%E5%9C%A8C%E8%AF%AD%E8%A8%80%E4%B8%8B%E5%9C%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%8A%A0%E5%85%A5%E5%87%BD%E6%95%B0/"/>
      <url>/2022/09/08/%E5%9C%A8C%E8%AF%AD%E8%A8%80%E4%B8%8B%E5%9C%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%8A%A0%E5%85%A5%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h2><p>Class类与Struct结构体最大的区别可能就是内部能不能有函数，在C语言下结构体虽然不能直接加入函数，但是我们可以通过指针曲线救国。</p><p>先来看一个函数指针的例子(来自c++ primer plus):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">betsy</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">pam</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">estimate</span><span class="params">(<span class="type">int</span> lines,<span class="type">double</span> (*pf)(<span class="type">int</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> code;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;line of code : &quot;</span>;</span><br><span class="line">cin &gt;&gt; code;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;betsy time : &quot;</span>;</span><br><span class="line"><span class="built_in">estimate</span>(code, betsy);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pam time : &quot;</span>;</span><br><span class="line"><span class="built_in">estimate</span>(code, pam);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">betsy</span><span class="params">(<span class="type">int</span> lns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.05</span> * lns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">pam</span><span class="params">(<span class="type">int</span> lns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.03</span> *lns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">estimate</span><span class="params">(<span class="type">int</span> lines, <span class="type">double</span> (*pf)(<span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">cout &lt;&lt; lines &lt;&lt; <span class="string">&quot; lines will take &quot;</span>;</span><br><span class="line">cout &lt;&lt; (*pf)(lines) &lt;&lt; <span class="string">&quot; hours \n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="开始实例"><a href="#开始实例" class="headerlink" title="开始实例"></a>开始实例</h2><p>现在开始我们的实例先创建下面的这个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name;</span><br><span class="line">    <span class="type">void</span> (*show)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以像这样初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fxf</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> <span class="title">test1</span>=</span>&#123;<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, *fxf&#125;;</span><br></pre></td></tr></table></figure><p>最后贴上完整代码，代码最终运行了一个结构体“中”的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name;</span><br><span class="line">    <span class="type">void</span> (*show)();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (*cur_task)();</span><br><span class="line"><span class="type">void</span> <span class="title function_">fxf</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fxf&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> <span class="title">test1</span>;</span></span><br><span class="line">test1.show = fxf;<span class="comment">//函数名就是指针</span></span><br><span class="line">cur_task = test1.show;</span><br><span class="line">(*cur_task)();<span class="comment">//最终运行了fxf这个函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个函数指针 <em><strong>cur_task</strong></em> 和 <em><strong>show</strong></em> 后面的参数不必与 <em><strong>fxf</strong></em> 函数的一样。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
