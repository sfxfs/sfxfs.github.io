<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiao&#39;s Tech Blog</title>
  
  <subtitle>探索技术的无限可能</subtitle>
  <link href="https://sfxfs.github.io/atom.xml" rel="self"/>
  
  <link href="https://sfxfs.github.io/"/>
  <updated>2025-10-01T02:24:04.197Z</updated>
  <id>https://sfxfs.github.io/</id>
  
  <author>
    <name>Fu Xiaofeng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FreeRTOS 的多任务实现、调度机制与内存管理</title>
    <link href="https://sfxfs.github.io/2025/10/01/FreeRTOS-%E7%9A%84%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0%E3%80%81%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://sfxfs.github.io/2025/10/01/FreeRTOS-%E7%9A%84%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0%E3%80%81%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2025-10-01T02:22:34.000Z</published>
    <updated>2025-10-01T02:24:04.197Z</updated>
    
    <content type="html"><![CDATA[<p>一、整体架构概览</p><ul><li>FreeRTOS 是单核、基于固定优先级的抢占式实时内核（也支持协作式）。</li><li>任务由内核维护的任务控制块 TCB 与任务栈组成；TCB 里保存任务上下文与调度元数据。</li><li>核心数据结构是多组就绪链表、延时链表、挂起链表和事件链表；调度器按“最高优先级就绪任务先运行”的规则选择任务。</li><li>上下文切换由定时节拍中断（tick）或事件唤醒触发，在各体系结构的移植层（portable&#x2F;portmacro.h）通过汇编&#x2F;内联汇编保存与恢复寄存器。</li></ul><p>二、任务与上下文</p><ul><li>TCB 关键字段（不同端口略有差异）：<ul><li>pxTopOfStack：当前栈顶（保存寄存器的上下文帧）。</li><li>pxStack&#x2F;pxEndOfStack：任务栈起止。</li><li>uxPriority：任务优先级（0..configMAX_PRIORITIES-1）。</li><li>xStateListItem：把任务挂到就绪&#x2F;延时等链表用的节点。</li><li>xEventListItem：等待队列&#x2F;信号量等事件列表的节点。</li></ul></li><li>任务状态：Running、Ready、Blocked（延时或等待事件）、Suspended、Deleted。</li><li>任务创建：xTaskCreate&#x2F;xTaskCreateStatic，动态或静态分配 TCB 与栈；入口是任务函数（无限循环），退出一般不返回。</li></ul><p>三、调度器与就绪列表</p><ul><li>算法：固定优先级抢占。<ul><li>configUSE_PREEMPTION&#x3D;1：高优先级就绪时立即抢占。</li><li>同优先级任务可时间片轮转（configUSE_TIME_SLICING&#x3D;1）。</li><li>configUSE_PORT_OPTIMISED_TASK_SELECTION 可用位图快速找到最高优先级。</li></ul></li><li>核心链表：<ul><li>pxReadyTasksLists[]：每个优先级一个就绪链表。</li><li>xDelayedTaskList1&#x2F;xDelayedTaskList2：延时任务的两条时间轮链表（处理 tick 计数溢出）。</li><li>xSuspendedTaskList：挂起任务。</li><li>每个队列&#x2F;信号量&#x2F;事件组都有一个或多个等待任务的事件链表（按优先级有序）。</li></ul></li><li>触发调度的时机：<ul><li>周期性：tick 中断（系统心跳）。</li><li>任务主动让出或阻塞：taskYIELD、vTaskDelay、xQueueReceive 等。</li><li>中断使更高优先级任务就绪：FromISR API 设置 xHigherPriorityTaskWoken 并触发 yield。</li><li>变更优先级&#x2F;任务就绪状态：vTaskPrioritySet、xTaskResume 等。</li></ul></li></ul><p>四、上下文切换过程（以 Cortex-M 为例）</p><ul><li>时钟：通常用 SysTick 产生 tick；在中断里决定是否需要切换。</li><li>机制：<ul><li>在中断里将“需要切换”的请求转成挂起 PendSV（最低优先级的异常），避免与其他 ISR 竞争。</li><li>PendSV 入口执行保存当前任务上下文（R4-R11 等）到其任务栈，更新当前 TCB-&gt;pxTopOfStack。</li><li>选择下一个任务（最高优先级 ready 列表的链表头）。</li><li>从新任务的栈恢复上下文，退出异常返回到新任务。</li></ul></li><li>关键宏&#x2F;函数：portYIELD_FROM_ISR、portEND_SWITCHING_ISR、portSET_INTERRUPT_MASK_FROM_ISR&#x2F;portCLEAR…、vTaskSwitchContext、portSAVE_CONTEXT&#x2F;portRESTORE_CONTEXT。</li><li>临界区：taskENTER_CRITICAL&#x2F;taskEXIT_CRITICAL（Cortex-M 常用 BASEPRI 屏蔽优先级阈值）。</li></ul><p>五、阻塞与事件同步</p><ul><li>延时：vTaskDelay&#x2F;xTaskDelayUntil 将任务移入延时链表，tick 递减到期后移回就绪链表。</li><li>等待队列&#x2F;信号量&#x2F;互斥量&#x2F;事件组：<ul><li>任务进入 Blocked 并挂到对应对象的事件链表，支持超时。</li><li>释放事件时按优先级唤醒一个或多个任务。</li></ul></li><li>互斥的优先级继承：configUSE_MUTEXES&#x3D;1 且 configUSE_PRIORITY_INHERITANCE&#x3D;1 时生效，减少优先级反转。</li><li>软件定时器：单独的定时器服务任务处理回调（deferred execution）。</li></ul><p>六、时间片与低功耗</p><ul><li>同优先级时间片：tick 到来时轮转链表头到尾；使同优先级公平。</li><li>Tickless Idle：configUSE_TICKLESS_IDLE&#x3D;1，空闲时暂停节拍定时器，设定低功耗定时器在下一个唤醒点触发，醒来补偿丢失的 tick，显著降功耗。</li></ul><p>七、内存管理</p><ol><li>任务栈与 TCB</li></ol><ul><li>动态分配：xTaskCreate 使用 pvPortMalloc 为 TCB 和栈分配内存。</li><li>静态分配：xTaskCreateStatic 由用户提供 TCB 与栈缓冲（configSUPPORT_STATIC_ALLOCATION&#x3D;1）。</li><li>栈大小以“栈宽度单位”（StackType_t）指定，依端口是 4&#x2F;8 字节。</li><li>栈溢出检测：configCHECK_FOR_STACK_OVERFLOW（模式 1&#x2F;2）+ vApplicationStackOverflowHook。</li></ul><ol start="2"><li>内核对象</li></ol><ul><li>队列、信号量、事件组、定时器等均可动态或静态创建（如 xQueueCreateStatic、xSemaphoreCreateBinaryStatic）。</li><li>定时器服务任务与空闲任务可由应用提供静态内存：vApplicationGetTimerTaskMemory&#x2F;vApplicationGetIdleTaskMemory。</li></ul><ol start="3"><li>堆实现（heap_1..heap_5）</li></ol><ul><li>heap_1：仅分配不释放，最简单、无碎片，适合启动期一次性分配。</li><li>heap_2：带释放，简单空闲链表，不合并相邻空闲块，易碎片。</li><li>heap_3：封装标准库 malloc&#x2F;free，线程安全由 FreeRTOS 临界区保护，但实时性取决于 libc。</li><li>heap_4：最佳适配 + 合并相邻空闲块，通用、实时性较好，推荐默认。</li><li>heap_5：多内存区域版本的 heap_4，可配置多个不连续内存段（适合分散 RAM）。</li><li>选择方式：在 FreeRTOSConfig.h 通过包含相应的 portable&#x2F;MemMang&#x2F;heap_x.c 实现一个 pvPortMalloc&#x2F;vPortFree。</li><li>线程安全：内核通过临界区保护 pvPortMalloc&#x2F;vPortFree，使其在任务&#x2F;中断上下文安全（FromISR 不允许分配）。</li></ul><ol start="4"><li>注意与建议</li></ol><ul><li>中断上下文禁止调用会触发阻塞或动态分配的 API；ISR 使用 FromISR 变体，且不能调用 pvPortMalloc。</li><li>控制碎片：优先使用静态创建或集中在系统初始化阶段一次性动态创建；若需运行期创建&#x2F;删除，选择 heap_4&#x2F;5。</li><li>监控：启用 configUSE_MALLOC_FAILED_HOOK 与 vApplicationMallocFailedHook；配置 uxTaskGetStackHighWaterMark 监控栈余量。</li></ul><p>八、常用配置项速览</p><ul><li>configUSE_PREEMPTION、configUSE_TIME_SLICING、configTICK_RATE_HZ、configMAX_PRIORITIES</li><li>configSUPPORT_STATIC_ALLOCATION、configSUPPORT_DYNAMIC_ALLOCATION</li><li>configCHECK_FOR_STACK_OVERFLOW、configUSE_IDLE_HOOK、configUSE_TICK_HOOK、configUSE_TICKLESS_IDLE</li><li>configUSE_MUTEXES、configUSE_RECURSIVE_MUTEXES、configUSE_COUNTING_SEMAPHORES、configUSE_TASK_NOTIFICATIONS</li><li>configQUEUE_REGISTRY_SIZE（队列注册调试）、configASSERT（断言）</li><li>端口相关：configCPU_CLOCK_HZ、configPRIO_BITS、configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY、configKERNEL_INTERRUPT_PRIORITY、configMAX_SYSCALL_INTERRUPT_PRIORITY</li></ul><p>九、常见排障思路</p><ul><li>任务不切换：检查中断优先级配置（尤其 Cortex-M 的 BASEPRI）、SysTick&#x2F;PendSV 使能、portYIELD_FROM_ISR 的使用。</li><li>高优先级“饿死”低优先级：确认是否需要 time slicing 或在高优先级任务里适当阻塞&#x2F;让出。</li><li>栈溢出&#x2F;硬 Fault：开启栈溢出检测、增大疑似任务栈、检查递归&#x2F;大数组。</li><li>内存不足&#x2F;碎片：切换到 heap_4&#x2F;5，改为静态分配或对象池，合并创建&#x2F;删除路径。</li><li>优先级反转：使用互斥量而非二值信号量并开启优先级继承。</li></ul><p>如果你有目标平台（如 Cortex-M、RISC-V、Xtensa）或具体 FreeRTOS 版本&#x2F;配置，我可以结合该端口画出更具体的上下文切换序列图与关键寄存器保存&#x2F;恢复细节，并给出 FreeRTOSConfig.h 的参考配置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、整体架构概览&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FreeRTOS 是单核、基于固定优先级的抢占式实时内核（也支持协作式）。&lt;/li&gt;
&lt;li&gt;任务由内核维护的任务控制块 TCB 与任务栈组成；TCB 里保存任务上下文与调度元数据。&lt;/li&gt;
&lt;li&gt;核心数据结构是多组就绪链表、</summary>
      
    
    
    
    
    <category term="FreeRTOS" scheme="https://sfxfs.github.io/tags/FreeRTOS/"/>
    
    <category term="Task" scheme="https://sfxfs.github.io/tags/Task/"/>
    
    <category term="Memory" scheme="https://sfxfs.github.io/tags/Memory/"/>
    
  </entry>
  
  <entry>
    <title>FreeRTOS中的SysTick、SVCall和Pend</title>
    <link href="https://sfxfs.github.io/2025/09/30/FreeRTOS%E4%B8%AD%E7%9A%84SysTick%E3%80%81SVCall%E5%92%8CPend/"/>
    <id>https://sfxfs.github.io/2025/09/30/FreeRTOS%E4%B8%AD%E7%9A%84SysTick%E3%80%81SVCall%E5%92%8CPend/</id>
    <published>2025-09-30T07:53:23.000Z</published>
    <updated>2025-09-30T09:34:02.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-SysTick"><a href="#1-SysTick" class="headerlink" title="1. SysTick"></a>1. <strong>SysTick</strong></h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><strong>SysTick</strong> 是 Cortex-M 系列专用的系统定时器中断。</li><li>通常用于周期性地触发中断，时间间隔可以配置（比如每 1ms）。</li><li>优先级可以设置，通常高于 PendSV。</li></ul><h3 id="在-FreeRTOS-中的用途"><a href="#在-FreeRTOS-中的用途" class="headerlink" title="在 FreeRTOS 中的用途"></a>在 FreeRTOS 中的用途</h3><ul><li><strong>系统时钟节拍</strong>（tick）：FreeRTOS 用 SysTick 定时器生成操作系统节拍（OS Tick），即系统“心跳”。</li><li>每当 SysTick 中断发生时，FreeRTOS 增加 tick 计数器，判断是否有延时任务需要唤醒，并决定是否触发任务切换（如果有高优先级任务就绪）。</li><li>主要代码位于 <code>SysTick_Handler</code>，会调用 <code>xPortSysTickHandler()</code>。</li></ul><hr><h2 id="2-SVCall"><a href="#2-SVCall" class="headerlink" title="2. SVCall"></a>2. <strong>SVCall</strong></h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul><li><strong>SVCall</strong>（Supervisor Call）是一个软件触发的中断，通过执行 SVC 指令产生。</li><li>用于实现特权级操作或系统服务调用。</li></ul><h3 id="在-FreeRTOS-中的用途-1"><a href="#在-FreeRTOS-中的用途-1" class="headerlink" title="在 FreeRTOS 中的用途"></a>在 FreeRTOS 中的用途</h3><ul><li>在一些 FreeRTOS 端口（如 ARM Cortex-M）中，SVCall 可用于进入或退出特权级模式，实现系统调用。</li><li>比如在支持 MPU（内存保护单元）的端口，FreeRTOS 通过 SVC 切换任务的权限级别。</li><li>在多数基础 FreeRTOS 用法中，SVCall用得较少，主要用于安全相关或特权切换场景。</li></ul><hr><h2 id="3-PendSV"><a href="#3-PendSV" class="headerlink" title="3. PendSV"></a>3. <strong>PendSV</strong></h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><ul><li><strong>PendSV</strong>（Pendable Service Call）是 Cortex-M 专有的、优先级最低的系统异常。</li><li>只能由软件设置挂起，不能被硬件自动触发。</li><li>设计目标：专用于 RTOS 的任务上下文切换。</li></ul><h3 id="在-FreeRTOS-中的用途-2"><a href="#在-FreeRTOS-中的用途-2" class="headerlink" title="在 FreeRTOS 中的用途"></a>在 FreeRTOS 中的用途</h3><ul><li><strong>任务切换（上下文切换）</strong>：FreeRTOS 通过挂起 PendSV （<code>SCB-&gt;ICSR |= SCB_ICSR_PENDSVSET_Msk</code>），实现任务切换的时机控制。</li><li>当需要切换任务时（如更高优先级任务就绪或主动 yield），调度器会触发 PendSV。</li><li>PendSV 的异常处理函数会保存当前任务现场、恢复下一个任务现场，完成任务切换。</li></ul><hr><h2 id="总结表格"><a href="#总结表格" class="headerlink" title="总结表格"></a>总结表格</h2><table><thead><tr><th>异常名</th><th>Cortex-M作用</th><th>FreeRTOS用途</th></tr></thead><tbody><tr><td>SysTick</td><td>周期性定时器中断</td><td>产生OS节拍，管理任务延时和唤醒</td></tr><tr><td>SVCall</td><td>软件触发的系统调用</td><td>进入&#x2F;退出特权级，安全相关</td></tr><tr><td>PendSV</td><td>挂起服务异常</td><td>任务上下文切换（切换任务）</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-SysTick&quot;&gt;&lt;a href=&quot;#1-SysTick&quot; class=&quot;headerlink&quot; title=&quot;1. SysTick&quot;&gt;&lt;/a&gt;1. &lt;strong&gt;SysTick&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; </summary>
      
    
    
    
    
    <category term="FreeRTOS" scheme="https://sfxfs.github.io/tags/FreeRTOS/"/>
    
    <category term="ARM" scheme="https://sfxfs.github.io/tags/ARM/"/>
    
  </entry>
  
  <entry>
    <title>array、vector、list的区别</title>
    <link href="https://sfxfs.github.io/2025/09/30/array%E3%80%81vector%E3%80%81list%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://sfxfs.github.io/2025/09/30/array%E3%80%81vector%E3%80%81list%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2025-09-30T07:30:33.000Z</published>
    <updated>2025-09-30T07:31:34.740Z</updated>
    
    <content type="html"><![CDATA[<p>下面分别介绍 C++ 标准库中的 <code>array</code>、<code>vector</code> 和 <code>list</code> 的区别：</p><hr><h3 id="array-和-vector-的区别"><a href="#array-和-vector-的区别" class="headerlink" title="array 和 vector 的区别"></a>array 和 vector 的区别</h3><table><thead><tr><th>特性</th><th>array</th><th>vector</th></tr></thead><tbody><tr><td>定义方式</td><td><code>std::array&lt;T, N&gt;</code></td><td><code>std::vector&lt;T&gt;</code></td></tr><tr><td>容量</td><td>固定（编译期已知大小）</td><td>动态（运行时可扩展）</td></tr><tr><td>内存分配</td><td>通常在栈上（连续空间）</td><td>在堆上（连续空间）</td></tr><tr><td>能否改变大小</td><td>不能，创建后大小固定</td><td>可以自动扩容&#x2F;缩小</td></tr><tr><td>性能</td><td>访问速度快（和原生数组一样）</td><td>访问速度快，扩容时有开销</td></tr><tr><td>用途</td><td>大小已知且固定的数组</td><td>需频繁增删元素的场景</td></tr></tbody></table><p><strong>举例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;     <span class="comment">// 固定长度，不能扩容</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;       <span class="comment">// 可动态扩容</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">6</span>);                             <span class="comment">// 支持动态插入</span></span><br></pre></td></tr></table></figure><hr><h3 id="vector-和-list-的区别"><a href="#vector-和-list-的区别" class="headerlink" title="vector 和 list 的区别"></a>vector 和 list 的区别</h3><table><thead><tr><th>特性</th><th>vector</th><th>list</th></tr></thead><tbody><tr><td>底层结构</td><td>数组（连续内存）</td><td>双向链表</td></tr><tr><td>访问速度</td><td>随机访问快（O(1)）</td><td>随机访问慢（O(n)）</td></tr><tr><td>插入&#x2F;删除</td><td>尾部效率高，头部&#x2F;中间慢</td><td>任意位置插入&#x2F;删除都快</td></tr><tr><td>内存使用</td><td>连续空间，内存碎片少</td><td>每个节点有额外指针开销</td></tr><tr><td>适用场景</td><td>需频繁随机访问或尾部操作</td><td>需频繁在中间插入&#x2F;删除</td></tr></tbody></table><p><strong>举例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">4</span>);   <span class="comment">// 插入效率低，可能整体搬移</span></span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; l = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = l.<span class="built_in">begin</span>();</span><br><span class="line">std::<span class="built_in">advance</span>(it, <span class="number">1</span>);          <span class="comment">// 移动到第二个元素</span></span><br><span class="line">l.<span class="built_in">insert</span>(it, <span class="number">4</span>);              <span class="comment">// 插入效率高</span></span><br></pre></td></tr></table></figure><hr><p><strong>总结：</strong></p><ul><li><code>array</code>：大小固定，适合已知长度的数组。</li><li><code>vector</code>：动态数组，适合大量随机访问和尾部插入。</li><li><code>list</code>：链表，适合频繁在任意位置插入&#x2F;删除，但不适合随机访问。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面分别介绍 C++ 标准库中的 &lt;code&gt;array&lt;/code&gt;、&lt;code&gt;vector&lt;/code&gt; 和 &lt;code&gt;list&lt;/code&gt; 的区别：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;array-和-vector-的区别&quot;&gt;&lt;a href=&quot;#array-和-v</summary>
      
    
    
    
    
    <category term="C++" scheme="https://sfxfs.github.io/tags/C/"/>
    
    <category term="STL" scheme="https://sfxfs.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>Linux下软链接和硬链接区别</title>
    <link href="https://sfxfs.github.io/2025/09/30/Linux%E4%B8%8B%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%8C%BA%E5%88%AB/"/>
    <id>https://sfxfs.github.io/2025/09/30/Linux%E4%B8%8B%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%8C%BA%E5%88%AB/</id>
    <published>2025-09-30T01:55:13.000Z</published>
    <updated>2025-09-30T02:15:10.653Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-定义和原理"><a href="#1-定义和原理" class="headerlink" title="1. 定义和原理"></a>1. 定义和原理</h3><ul><li><strong>硬链接</strong>：是对文件的一个直接引用。多个硬链接指向同一个 inode（即文件的唯一标识），它们是等价的，每一个都像原始文件一样。</li><li><strong>软链接</strong>：是一个特殊的文件，内容是指向目标文件路径的字符串，相当于 Windows 下的快捷方式。</li></ul><h3 id="2-inode-和文件数据块"><a href="#2-inode-和文件数据块" class="headerlink" title="2. inode 和文件数据块"></a>2. inode 和文件数据块</h3><ul><li><strong>硬链接</strong>：与原文件共享 inode 号。删除任意一个硬链接，其他硬链接和数据仍然存在，只有所有硬链接都删除后，文件数据才会被释放。</li><li><strong>软链接</strong>：有自己独立的 inode，存储的是目标文件路径，不直接指向数据块。</li></ul><h3 id="3-跨文件系统"><a href="#3-跨文件系统" class="headerlink" title="3. 跨文件系统"></a>3. 跨文件系统</h3><ul><li><strong>硬链接</strong>：只能在同一个文件系统（分区）内创建，不能跨分区。</li><li><strong>软链接</strong>：可以跨文件系统或分区，只要路径能访问即可。</li></ul><h3 id="4-对目录的支持"><a href="#4-对目录的支持" class="headerlink" title="4. 对目录的支持"></a>4. 对目录的支持</h3><ul><li><strong>硬链接</strong>：普通用户不能对目录创建硬链接（防止循环和混乱），只有超级用户可以在特定情况下创建。</li><li><strong>软链接</strong>：可以对文件和目录都创建软链接。</li></ul><h3 id="5-断链问题"><a href="#5-断链问题" class="headerlink" title="5. 断链问题"></a>5. 断链问题</h3><ul><li><strong>硬链接</strong>：只要有一个硬链接在，文件数据就能访问。</li><li><strong>软链接</strong>：如果目标文件删除或移动，软链接就“失效”变成死链（Broken Link）。</li></ul><h3 id="6-显示方式"><a href="#6-显示方式" class="headerlink" title="6. 显示方式"></a>6. 显示方式</h3><ul><li>使用 <code>ls -l</code> 命令：<ul><li>硬链接：和普通文件一样显示。</li><li>软链接：显示为 <code>目标文件 -&gt; 源文件</code> 的形式，如 <code>link.txt -&gt; target.txt</code></li></ul></li></ul><h3 id="7-创建方式"><a href="#7-创建方式" class="headerlink" title="7. 创建方式"></a>7. 创建方式</h3><ul><li><strong>硬链接</strong>：<code>ln 源文件 硬链接文件</code></li><li><strong>软链接</strong>：<code>ln -s 源文件 软链接文件</code></li></ul><hr><h4 id="总结对比表"><a href="#总结对比表" class="headerlink" title="总结对比表"></a>总结对比表</h4><table><thead><tr><th>类型</th><th>是否跨分区</th><th>是否可对目录</th><th>inode关系</th><th>删除原文件影响</th><th>创建命令</th></tr></thead><tbody><tr><td>硬链接</td><td>否</td><td>否</td><td>相同</td><td>无影响</td><td>ln 源 目标</td></tr><tr><td>软链接</td><td>是</td><td>是</td><td>不同</td><td>链接失效</td><td>ln -s 源 目标</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-定义和原理&quot;&gt;&lt;a href=&quot;#1-定义和原理&quot; class=&quot;headerlink&quot; title=&quot;1. 定义和原理&quot;&gt;&lt;/a&gt;1. 定义和原理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;硬链接&lt;/strong&gt;：是对文件的一个直接引用。多个硬链接指向同一</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://sfxfs.github.io/tags/Linux/"/>
    
    <category term="File Link" scheme="https://sfxfs.github.io/tags/File-Link/"/>
    
  </entry>
  
  <entry>
    <title>move和forward的区别和应用场景</title>
    <link href="https://sfxfs.github.io/2025/09/30/move%E5%92%8Cforward%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://sfxfs.github.io/2025/09/30/move%E5%92%8Cforward%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2025-09-30T01:36:46.000Z</published>
    <updated>2025-09-30T01:54:41.998Z</updated>
    
    <content type="html"><![CDATA[<p>在 C++ 中，<code>std::move</code> 和 <code>std::forward</code> 都涉及到“右值引用”和“资源移动”，但应用场景不同：</p><hr><h2 id="1-std-move"><a href="#1-std-move" class="headerlink" title="1. std::move"></a>1. <code>std::move</code></h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><ul><li><strong>强制把对象变成右值</strong>，用于触发移动语义（如移动构造、移动赋值）。</li><li>适用于你已经不再需要原对象，可以“搬走”其资源。</li><li>常用于容器插入、函数返回、资源转移等场景。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;std::string&gt; v;</span><br><span class="line">std::string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 s 的内容“搬”到容器里，而不是拷贝</span></span><br><span class="line">v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(s)); <span class="comment">// s 变为空</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-std-forward"><a href="#2-std-forward" class="headerlink" title="2. std::forward"></a>2. <code>std::forward</code></h2><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><ul><li>用于<strong>完美转发</strong>（perfect forwarding），保持参数的原始类型（左值&#x2F;右值）。</li><li>通常在<strong>模板函数</strong>中，将参数原样“传递”到另一个函数。</li><li>适用于写通用包装函数、工厂函数等场景。</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保持 arg 的左值/右值属性，完美转发到目标函数</span></span><br><span class="line">    <span class="built_in">target_func</span>(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 <code>wrapper(s)</code>，<code>std::forward&lt;T&gt;(arg)</code> 会是左值。</li><li>如果 <code>wrapper(std::move(s))</code>，<code>std::forward&lt;T&gt;(arg)</code> 会是右值。</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>std::move</code>：将对象变成右值，触发移动语义。<strong>适合你已经不再需要原对象的场景。</strong></li><li><code>std::forward</code>：保持参数原始属性，用于模板中的完美转发。<strong>适合泛型代码和包装&#x2F;转发调用。</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 C++ 中，&lt;code&gt;std::move&lt;/code&gt; 和 &lt;code&gt;std::forward&lt;/code&gt; 都涉及到“右值引用”和“资源移动”，但应用场景不同：&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1-std-move&quot;&gt;&lt;a href=&quot;#1-std-move&quot; </summary>
      
    
    
    
    
    <category term="C++" scheme="https://sfxfs.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>变量内存对齐</title>
    <link href="https://sfxfs.github.io/2025/09/30/%E5%8F%98%E9%87%8F%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    <id>https://sfxfs.github.io/2025/09/30/%E5%8F%98%E9%87%8F%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</id>
    <published>2025-09-30T01:36:19.000Z</published>
    <updated>2025-10-02T03:38:19.252Z</updated>
    
    <content type="html"><![CDATA[<p>有如下C代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">char</span> c1 = <span class="number">3</span>;</span><br><span class="line"><span class="type">char</span> c2 = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a: %p\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c1:%p\n&quot;</span>,&amp;c1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c2:%p\n&quot;</span>,&amp;c2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出类似这样的地址顺序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c1: 0xaaaac23d1010</span><br><span class="line">c2: 0xaaaac23d1011</span><br><span class="line">a: 0xaaaac23d1014</span><br><span class="line">b: 0xaaaac23d1018</span><br></pre></td></tr></table></figure><p>这是为什么呢？</p><h3 id="1-变量分布与对齐"><a href="#1-变量分布与对齐" class="headerlink" title="1. 变量分布与对齐"></a>1. 变量分布与对齐</h3><ul><li><code>char c1</code>、<code>char c2</code> 连续存放，占用1字节，地址递增。</li><li><code>int a</code>、<code>int b</code> 分别占4字节（假设int为4字节），并且一般要求<strong>4字节对齐</strong>。</li><li>变量在内存中的排列顺序以及对齐方式由<strong>编译器</strong>决定，但通常遵循“定义顺序+对齐优化”。</li></ul><h3 id="2-变量排列推测（假设编译器按定义顺序分配）"><a href="#2-变量排列推测（假设编译器按定义顺序分配）" class="headerlink" title="2. 变量排列推测（假设编译器按定义顺序分配）"></a>2. 变量排列推测（假设编译器按定义顺序分配）</h3><p>假设变量以定义顺序排列在全局数据区（静态区）：</p><ol><li><code>int b</code>  </li><li><code>char c1</code>  </li><li><code>char c2</code>  </li><li><code>int a</code></li></ol><p>输出顺序说明了变量实际排列：</p><ul><li><code>c1</code> 先于 <code>c2</code>，相差1字节（0x1010→0x1011）</li><li><code>a</code> 地址比 <code>c2</code> 高3字节（0x1011→0x1014），说明<code>a</code>被<strong>4字节对齐</strong></li><li><code>b</code> 地址比 <code>a</code>高4字节（0x1014→0x1018）</li></ul><h4 id="变量内存分布（假设起始地址为0x1010）："><a href="#变量内存分布（假设起始地址为0x1010）：" class="headerlink" title="变量内存分布（假设起始地址为0x1010）："></a>变量内存分布（假设起始地址为0x1010）：</h4><table><thead><tr><th>变量</th><th>地址</th><th>占用</th></tr></thead><tbody><tr><td>c1</td><td>0x1010</td><td>1字节</td></tr><tr><td>c2</td><td>0x1011</td><td>1字节</td></tr><tr><td>[填充]</td><td>0x1012-0x1013</td><td>2字节（对齐a）</td></tr><tr><td>a</td><td>0x1014</td><td>4字节</td></tr><tr><td>b</td><td>0x1018</td><td>4字节</td></tr></tbody></table><h3 id="3-为什么要填充（Padding）"><a href="#3-为什么要填充（Padding）" class="headerlink" title="3. 为什么要填充（Padding）"></a>3. 为什么要填充（Padding）</h3><ul><li><code>int</code> 需要4字节对齐，否则CPU访问会慢甚至出错。</li><li>因此在<code>c2</code>之后，编译器自动填充2字节，使<code>a</code>地址是4的倍数（0x1014）。</li><li>同样，<code>b</code> 紧跟在<code>a</code>之后，地址为0x1018。</li></ul><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul><li><strong>变量按定义顺序排列</strong>（全局变量&#x2F;静态变量）。</li><li><strong>char类型紧挨着，int类型由于对齐要求，可能有填充字节。</strong></li><li>打印出的地址正好反映了这种内存布局和对齐。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有如下C代码：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;</summary>
      
    
    
    
    
    <category term="C++" scheme="https://sfxfs.github.io/tags/C/"/>
    
    <category term="Memory" scheme="https://sfxfs.github.io/tags/Memory/"/>
    
    <category term="C" scheme="https://sfxfs.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Linux和裸机程序内存布局</title>
    <link href="https://sfxfs.github.io/2025/09/30/Linux%E5%92%8C%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
    <id>https://sfxfs.github.io/2025/09/30/Linux%E5%92%8C%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</id>
    <published>2025-09-30T01:18:08.000Z</published>
    <updated>2025-09-30T01:48:34.877Z</updated>
    
    <content type="html"><![CDATA[<p>所谓的“进程的内存”通常指的是进程的<strong>虚拟地址空间（Virtual Address Space）</strong>，而不是直接的物理内存。</p><p>每个进程都有一个独立、私有的虚拟地址空间，操作系统（如 Linux）会将这个空间划分为几个主要区域，并进行特定的排列。</p><hr><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="进程虚拟地址空间的主要分区"><a href="#进程虚拟地址空间的主要分区" class="headerlink" title="进程虚拟地址空间的主要分区"></a>进程虚拟地址空间的主要分区</h2><p>一个进程的虚拟地址空间通常从低地址向高地址延伸，主要被划分为以下几个区域：</p><h3 id="1-代码段（Text-Segment-Code-Segment）"><a href="#1-代码段（Text-Segment-Code-Segment）" class="headerlink" title="1. 代码段（Text Segment &#x2F; Code Segment）"></a>1. <strong>代码段（Text Segment &#x2F; Code Segment）</strong></h3><ul><li><strong>内容</strong>：存放进程执行的<strong>机器指令</strong>（程序代码）。</li><li><strong>特性</strong>：通常是<strong>只读</strong>的，以防止程序意外地修改自身的指令。它可以被多个进程共享（例如多个进程运行同一个程序）。</li><li><strong>排布</strong>：位于虚拟地址空间的<strong>低端</strong>。</li></ul><h3 id="2-数据段（Data-Segment）"><a href="#2-数据段（Data-Segment）" class="headerlink" title="2. 数据段（Data Segment）"></a>2. <strong>数据段（Data Segment）</strong></h3><ul><li><strong>内容</strong>：存放<strong>已初始化</strong>的<strong>全局变量</strong>和<strong>静态变量</strong>。</li><li><strong>特性</strong>：<strong>可读写</strong>。这些变量的值在程序启动时就已经确定。</li></ul><h3 id="3-BSS-段（Block-Started-by-Symbol-Segment）"><a href="#3-BSS-段（Block-Started-by-Symbol-Segment）" class="headerlink" title="3. BSS 段（Block Started by Symbol Segment）"></a>3. <strong>BSS 段（Block Started by Symbol Segment）</strong></h3><ul><li><strong>内容</strong>：存放<strong>未初始化</strong>的<strong>全局变量</strong>和<strong>静态变量</strong>。</li><li><strong>特性</strong>：<strong>可读写</strong>。在程序加载时，操作系统会将其初始化为 <code>0</code> 或空指针。</li><li><strong>名称由来</strong>：BSS 段在程序文件中不占实际空间，只是记录了所需内存的大小，这有助于减小可执行文件体积。</li></ul><h3 id="4-堆（Heap）"><a href="#4-堆（Heap）" class="headerlink" title="4. 堆（Heap）"></a>4. <strong>堆（Heap）</strong></h3><ul><li><strong>内容</strong>：用于程序运行时的<strong>动态内存分配</strong>（如使用 <code>malloc</code>、<code>calloc</code>、<code>realloc</code> 等函数申请的内存）。</li><li><strong>特性</strong>：<strong>可读写</strong>。</li><li><strong>增长方向</strong>：从低地址向高地址<strong>增长</strong>。</li><li><strong>管理</strong>：由C标准库中的分配器（如 <code>malloc</code> 的实现）管理，它通过 <strong><code>brk</code> &#x2F; <code>sbrk</code></strong> 或 <strong><code>mmap</code></strong> 系统调用向操作系统申请更大的虚拟地址空间。</li></ul><h3 id="5-内存映射区（Memory-Mapping-Segment）"><a href="#5-内存映射区（Memory-Mapping-Segment）" class="headerlink" title="5. 内存映射区（Memory Mapping Segment）"></a>5. <strong>内存映射区（Memory Mapping Segment）</strong></h3><ul><li><strong>内容</strong>：<ul><li>动态链接库（如 <code>.so</code> 文件）映射到此区域（<strong>数据并没有真正从磁盘加载到物理内存</strong>，它只是建立了一个<strong>虚拟地址</strong>到<strong>文件页</strong>的映射关系）。</li><li>使用 <strong><code>mmap</code></strong> 系统调用进行文件 I&#x2F;O 映射的区域。</li><li>分配<strong>大块</strong>动态内存（<code>malloc</code> 超过一定阈值时会使用 <code>mmap</code>）。</li></ul></li><li><strong>特性</strong>：灵活，可读写。</li><li><strong>增长方向</strong>：通常从高地址向低地址<strong>增长</strong>。</li></ul><h3 id="6-栈（Stack）"><a href="#6-栈（Stack）" class="headerlink" title="6. 栈（Stack）"></a>6. <strong>栈（Stack）</strong></h3><ul><li><strong>内容</strong>：用于存放<strong>局部变量</strong>、函数<strong>参数</strong>、<strong>返回值</strong>以及函数调用所需的<strong>上下文</strong>信息（如返回地址）。</li><li><strong>特性</strong>：<strong>可读写</strong>。</li><li><strong>增长方向</strong>：从高地址向低地址<strong>增长</strong>。</li><li><strong>管理</strong>：由编译器和操作系统自动管理，遵循 <strong>后进先出（LIFO）</strong> 的原则。</li></ul><hr><h2 id="内存排布和地址增长方向"><a href="#内存排布和地址增长方向" class="headerlink" title="内存排布和地址增长方向"></a>内存排布和地址增长方向</h2><p>进程的虚拟地址空间通常呈现出以下<strong>排布规律</strong>（以典型的 Linux 系统为例）：</p><ol><li><strong>内核空间（Kernel Space）</strong>：位于虚拟地址的<strong>最高端</strong>。这部分内存为操作系统内核保留，用户程序通常无法直接访问。</li><li><strong>栈（Stack）</strong>：紧挨着内核空间下方，从<strong>高地址向低地址</strong>增长。</li><li><strong>内存映射区</strong>：位于栈和堆之间，通常也从<strong>高地址向低地址</strong>增长。</li><li><strong>堆（Heap）</strong>：位于代码段和数据段上方，从<strong>低地址向高地址</strong>增长。<ul><li><strong>堆和栈的“相遇”</strong>：在设计上，堆和栈的增长方向是相反的，它们之间通常会预留一大块未映射的区域。如果堆或栈增长过快，导致它们各自的边界相遇或越过对方，就会导致内存溢出或段错误。</li></ul></li><li><strong>BSS 段 &#x2F; 数据段 &#x2F; 代码段</strong>：这三个静态区域位于虚拟地址的<strong>低端</strong>。</li></ol><h3 id="简化示意图（从低地址到高地址）"><a href="#简化示意图（从低地址到高地址）" class="headerlink" title="简化示意图（从低地址到高地址）"></a>简化示意图（从低地址到高地址）</h3><table><thead><tr><th>虚拟地址（高）</th><th>区域名称</th><th>增长方向</th><th>内存用途</th></tr></thead><tbody><tr><td>↑</td><td><strong>内核空间</strong></td><td>-</td><td>操作系统内核使用</td></tr><tr><td></td><td><strong>栈 (Stack)</strong></td><td>↓ (向低地址增长)</td><td>局部变量、函数调用</td></tr><tr><td></td><td><strong>未分配区域</strong></td><td>-</td><td>-</td></tr><tr><td></td><td><strong>内存映射区 (mmap)</strong></td><td>↓ (向低地址增长)</td><td>动态库、大块内存</td></tr><tr><td></td><td><strong>未分配区域</strong></td><td>-</td><td>-</td></tr><tr><td></td><td><strong>堆 (Heap)</strong></td><td>↑ (向高地址增长)</td><td>动态分配内存 (<code>malloc</code>)</td></tr><tr><td></td><td><strong>BSS 段</strong></td><td>-</td><td>未初始化全局&#x2F;静态变量</td></tr><tr><td></td><td><strong>数据段</strong></td><td>-</td><td>已初始化全局&#x2F;静态变量</td></tr><tr><td>↓</td><td><strong>代码段 (Text)</strong></td><td>-</td><td>程序的机器指令</td></tr><tr><td>虚拟地址（低）</td><td></td><td></td><td></td></tr></tbody></table><h3 id="按需分页（Demand-Paging）"><a href="#按需分页（Demand-Paging）" class="headerlink" title="按需分页（Demand Paging）"></a>按需分页（Demand Paging）</h3><p>真正的效率提升在于**按需分页（Demand Paging）**机制：</p><ul><li><strong>初始状态</strong>：动态库被映射后，其对应的虚拟地址并没有实际的物理内存页与之对应。</li><li><strong>首次访问</strong>：当程序第一次试图执行动态库中的某个函数或访问某个数据时，CPU 会根据虚拟地址去查找<strong>页表</strong>。此时发现该页还没有加载到物理内存，会触发一个<strong>缺页中断（Page Fault）</strong>。</li><li><strong>加载页面</strong>：操作系统内核捕获到缺页中断后，会从磁盘上的动态库文件找到对应的**页面（Page）**内容，将其加载到一个**物理内存帧**中，并更新页表，建立虚拟地址与物理地址的映射。</li><li><strong>继续执行</strong>：程序随后在中断处恢复执行，就能够顺利访问该内存了。</li></ul><h1 id="裸机（STM32）"><a href="#裸机（STM32）" class="headerlink" title="裸机（STM32）"></a>裸机（STM32）</h1><p>这是一个从通用计算机（如 Linux 进程）转移到<strong>嵌入式系统</strong>（如 <strong>STM32 微控制器</strong>）的精彩问题！</p><p>STM32 微控制器<strong>没有</strong>操作系统提供的复杂的<strong>虚拟内存</strong>机制，也没有进程的概念。它的内存布局直接对应于其<strong>物理内存</strong>和<strong>片上外设</strong>的地址空间。</p><p>STM32 的内存布局是<strong>固定</strong>的，由其内部架构（基于 ARM Cortex-M 内核）决定，主要分为以下几个关键区域：</p><hr><h2 id="STM32-微控制器的内存布局"><a href="#STM32-微控制器的内存布局" class="headerlink" title="STM32 微控制器的内存布局"></a>STM32 微控制器的内存布局</h2><p><img src="/2025/09/30/Linux%E5%92%8C%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/1.png"></p><p>STM32 采用**哈佛结构（Harvard Architecture）*<em>或*<em>改进的冯·诺依曼结构</em></em>，其中代码和数据可以分开访问。其内存空间被划分为几个主要区域，每个区域都有一个固定的地址范围。</p><h3 id="1-闪存（Flash-Memory）-CODE-区"><a href="#1-闪存（Flash-Memory）-CODE-区" class="headerlink" title="1. 闪存（Flash Memory） - CODE 区"></a>1. 闪存（Flash Memory） - CODE 区</h3><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td><strong>地址范围</strong></td><td>通常从 <code>0x0800 0000</code> 开始</td></tr><tr><td><strong>内容</strong></td><td>存放程序<strong>代码</strong>（指令）和<strong>常量数据</strong>（如字符串字面量、<code>const</code> 变量）。</td></tr><tr><td><strong>特性</strong></td><td><strong>非易失性</strong>（掉电不丢失）。这是程序烧录的主要目标区域。程序启动时，CPU 从这里取指令执行。</td></tr></tbody></table><h3 id="2-SRAM（Static-RAM）-DATA-HEAP-STACK-区"><a href="#2-SRAM（Static-RAM）-DATA-HEAP-STACK-区" class="headerlink" title="2. SRAM（Static RAM） - DATA&#x2F;HEAP&#x2F;STACK 区"></a>2. SRAM（Static RAM） - DATA&#x2F;HEAP&#x2F;STACK 区</h3><p>SRAM 是 STM32 的主要<strong>工作内存</strong>，<strong>易失性</strong>（掉电丢失）。它被细分为我们熟悉的数据、堆和栈等区域。</p><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td><strong>地址范围</strong></td><td>通常从 <code>0x2000 0000</code> 开始</td></tr><tr><td><strong>内容</strong></td><td></td></tr><tr><td><strong>数据段</strong>(<code>.data</code>)</td><td>存放<strong>已初始化</strong>的<strong>全局&#x2F;静态变量</strong>。程序启动时，这些数据会从 Flash <strong>复制</strong>到 SRAM。</td></tr><tr><td><strong>BSS 段</strong>(<code>.bss</code>)</td><td>存放<strong>未初始化</strong>的<strong>全局&#x2F;静态变量</strong>。程序启动时，这部分空间会被<strong>清零</strong>。</td></tr><tr><td><strong>堆（Heap）</strong></td><td>用于程序运行时的<strong>动态内存分配</strong>（如 <code>malloc</code>）。<strong>从低地址向高地址增长</strong>。</td></tr><tr><td><strong>栈（Stack）</strong></td><td>用于存放<strong>局部变量</strong>、函数<strong>参数</strong>和<strong>返回地址</strong>。<strong>从高地址向低地址增长</strong>。</td></tr><tr><td><strong>注意</strong></td><td>在 STM32 上，堆和栈的空间是<strong>静态预留</strong>的，在链接脚本（Linker Script）中定义它们的大小和位置。堆和栈的增长如果互相侵占，会导致程序崩溃。</td></tr></tbody></table><h3 id="3-外设（Peripherals）-外设寄存器区"><a href="#3-外设（Peripherals）-外设寄存器区" class="headerlink" title="3. 外设（Peripherals） - 外设寄存器区"></a>3. 外设（Peripherals） - 外设寄存器区</h3><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td><strong>地址范围</strong></td><td>通常从 <code>0x4000 0000</code> 或 <code>0x5000 0000</code> 开始</td></tr><tr><td><strong>内容</strong></td><td>存放所有片上<strong>外设的控制寄存器</strong>（如 GPIO、定时器、ADC 等）。</td></tr><tr><td><strong>特性</strong></td><td>程序员通过<strong>读写特定地址的内存</strong>来控制硬件。例如，向某个地址写入 <code>1</code> 就可以点亮一个 LED 灯。这就是所谓的<strong>内存映射 I&#x2F;O (MMIO)</strong>。</td></tr></tbody></table><h3 id="4-启动区域（Boot-Memory）"><a href="#4-启动区域（Boot-Memory）" class="headerlink" title="4. 启动区域（Boot Memory）"></a>4. 启动区域（Boot Memory）</h3><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td><strong>地址范围</strong></td><td>从 <code>0x0000 0000</code> 开始</td></tr><tr><td><strong>内容</strong></td><td>包含了<strong>重映射</strong>的地址。STM32 在启动时，会将这个低地址区域映射到 Flash、系统存储器（System Memory，用于 Bootloader）或 SRAM 中的某一个。</td></tr><tr><td><strong>特性</strong></td><td>决定了微控制器<strong>启动后执行的第一条指令</strong>来自哪里。</td></tr></tbody></table><hr><h2 id="与-PC-内存模型的关键区别"><a href="#与-PC-内存模型的关键区别" class="headerlink" title="与 PC 内存模型的关键区别"></a>与 PC 内存模型的关键区别</h2><table><thead><tr><th>特性</th><th>PC &#x2F; Linux 进程</th><th>STM32 &#x2F; 嵌入式系统</th></tr></thead><tbody><tr><td><strong>内存类型</strong></td><td><strong>虚拟内存</strong>（抽象层）</td><td><strong>物理内存</strong>（直接访问）</td></tr><tr><td><strong>内存管理</strong></td><td>复杂，由 OS 动态管理和分配，使用<strong>分页</strong>和<strong>页表</strong>。</td><td>简单，<strong>静态分配</strong>，内存由<strong>链接器脚本</strong>预先分配。</td></tr><tr><td><strong>动态库&#x2F;mmap</strong></td><td>大量使用 <code>mmap</code> 加载动态库，实现<strong>按需分页</strong>。</td><td>不存在动态库概念，所有代码和数据在编译时就确定了位置。</td></tr><tr><td><strong>堆&#x2F;栈</strong></td><td>堆和栈之间的空间巨大且包含 <code>mmap</code> 区。</td><td>堆和栈的空间是<strong>有限且相邻</strong>的，由链接脚本严格划分。</td></tr><tr><td><strong>外设</strong></td><td>通过系统调用或驱动访问硬件。</td><td>通过<strong>内存映射 I&#x2F;O</strong>（直接读写内存地址）来控制硬件。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;所谓的“进程的内存”通常指的是进程的&lt;strong&gt;虚拟地址空间（Virtual Address Space）&lt;/strong&gt;，而不是直接的物理内存。&lt;/p&gt;
&lt;p&gt;每个进程都有一个独立、私有的虚拟地址空间，操作系统（如 Linux）会将这个空间划分为几个主要区域，并进行</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://sfxfs.github.io/tags/Linux/"/>
    
    <category term="STM32" scheme="https://sfxfs.github.io/tags/STM32/"/>
    
    <category term="MCU" scheme="https://sfxfs.github.io/tags/MCU/"/>
    
  </entry>
  
  <entry>
    <title>C11 新特性和示例代码</title>
    <link href="https://sfxfs.github.io/2025/09/19/C11-%E6%96%B0%E7%89%B9%E6%80%A7%E5%92%8C%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/"/>
    <id>https://sfxfs.github.io/2025/09/19/C11-%E6%96%B0%E7%89%B9%E6%80%A7%E5%92%8C%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/</id>
    <published>2025-09-19T02:44:48.000Z</published>
    <updated>2025-09-24T06:28:27.877Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://cppreference.cn/w/c/11">参考文档</a>，还可进一步了解<a href="https://cppreference.cn/w/c/23">c23</a>（但是测试了安装的gcc和clang (2025.9.19) 编译器没有支持）</p><h2 id="对齐处理（Alignment）的标准化"><a href="#对齐处理（Alignment）的标准化" class="headerlink" title="对齐处理（Alignment）的标准化"></a>对齐处理（Alignment）的标准化</h2><h4 id="Alignas-标识符"><a href="#Alignas-标识符" class="headerlink" title="_Alignas 标识符"></a><code>_Alignas</code> 标识符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdalign.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">_Alignas</span>(<span class="number">16</span>) <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Alignment of struct S: %zu\n&quot;</span>, <span class="keyword">alignof</span>(<span class="keyword">struct</span> S));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="alignof-运算符"><a href="#alignof-运算符" class="headerlink" title="alignof 运算符"></a><code>alignof</code> 运算符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdalign.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Alignment of double: %zu\n&quot;</span>, <span class="keyword">alignof</span>(<span class="type">double</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="aligned-alloc-函数"><a href="#aligned-alloc-函数" class="headerlink" title="aligned_alloc 函数"></a><code>aligned_alloc</code> 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> alignment = <span class="number">32</span>;</span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">128</span>;</span><br><span class="line">    <span class="type">void</span>* ptr = aligned_alloc(alignment, size);</span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Aligned allocation succeeded.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="头文件"><a href="#头文件" class="headerlink" title="&lt;stdalign.h&gt; 头文件"></a><code>&lt;stdalign.h&gt;</code> 头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdalign.h&gt;</span></span></span><br><span class="line"><span class="keyword">alignas</span>(<span class="number">16</span>) <span class="type">int</span> x;</span><br></pre></td></tr></table></figure><hr><h2 id="Noreturn-函数标记"><a href="#Noreturn-函数标记" class="headerlink" title="_Noreturn 函数标记"></a><code>_Noreturn</code> 函数标记</h2><p><code>_Noreturn</code> 函数标记，类似于 gcc 的 <code>__attribute__((noreturn))</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">_Noreturn</span> <span class="type">void</span> <span class="title function_">fatal</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fatal error: %s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Generic-泛型宏关键字"><a href="#Generic-泛型宏关键字" class="headerlink" title="_Generic 泛型宏关键字"></a><code>_Generic</code> 泛型宏关键字</h2><p>字符串例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如：若x为int类型，则替换 type_name(x) 为 int 类型后面的值，即 &quot;int&quot; 这个字符串</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> type_name(x) _Generic((x), \</span></span><br><span class="line"><span class="meta">    int: <span class="string">&quot;int&quot;</span>, \</span></span><br><span class="line"><span class="meta">    float: <span class="string">&quot;float&quot;</span>, \</span></span><br><span class="line"><span class="meta">    double: <span class="string">&quot;double&quot;</span>, \</span></span><br><span class="line"><span class="meta">    default: <span class="string">&quot;other&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, type_name(<span class="number">3.14</span>)); <span class="comment">// 输出 double</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, type_name(<span class="number">42</span>));   <span class="comment">// 输出 int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“函数重载”例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo_int</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am int type !!~\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo_double</span><span class="params">(<span class="type">double</span> x)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am double type !!~\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> foo(x) _Generic(x, int : foo_int, \</span></span><br><span class="line"><span class="meta">                          double : foo_double)(x)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    foo(<span class="number">123</span>);  <span class="comment">// foo_int(123) // I am int type !!~</span></span><br><span class="line">    foo(<span class="number">1.23</span>);  <span class="comment">// foo_double(1.23) // I am double type !!~</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="多线程（Multithreading）支持"><a href="#多线程（Multithreading）支持" class="headerlink" title="多线程（Multithreading）支持"></a>多线程（Multithreading）支持</h2><p>注意：无法在 Darwin clang 环境下使用</p><h4 id="Thread-local-存储类型标识符-和-头文件"><a href="#Thread-local-存储类型标识符-和-头文件" class="headerlink" title="_Thread_local 存储类型标识符 和 &lt;threads.h&gt; 头文件"></a><code>_Thread_local</code> 存储类型标识符 和 <code>&lt;threads.h&gt;</code> 头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;threads.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITER 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">_Thread_local</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">incrementCounter</span><span class="params">(<span class="type">void</span> *thr_id)</span> &#123;</span><br><span class="line">  <span class="type">int</span> tid = (<span class="type">int</span>)thr_id;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;thread %d started incrementing ID - %lu\n&quot;</span>, tid, thrd_current());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_ITER; ++i)</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *)counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">thrd_t</span> threads[NUM_THREADS];</span><br><span class="line">  <span class="type">int</span> rc, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">    rc = thrd_create(&amp;threads[i], (<span class="type">thrd_start_t</span>)incrementCounter, (<span class="type">void</span> *)i);</span><br><span class="line">    <span class="keyword">if</span> (rc == thrd_error) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;ERORR; thrd_create() call failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> retval;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">    thrd_join(threads[i], &amp;retval);</span><br><span class="line">    sum += retval;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">  thrd_exit(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread 0 started incrementing ID - 281473108406528</span><br><span class="line">thread 3 started incrementing ID - 281472963440896</span><br><span class="line">thread 1 started incrementing ID - 281473099952384</span><br><span class="line">thread 2 started incrementing ID - 281473091498240</span><br><span class="line">count = 40000</span><br></pre></td></tr></table></figure><p>若<strong>不加</strong>的输出（各个线程在竞争数据）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread 0 started incrementing ID - 281473865281824</span><br><span class="line">thread 2 started incrementing ID - 281473848373536</span><br><span class="line">thread 1 started incrementing ID - 281473856827680</span><br><span class="line">thread 3 started incrementing ID - 281473768747296</span><br><span class="line">count = 55938</span><br></pre></td></tr></table></figure><hr><h2 id="Atomic-类型修饰符和-头文件"><a href="#Atomic-类型修饰符和-头文件" class="headerlink" title="_Atomic 类型修饰符和 &lt;stdatomic.h&gt; 头文件"></a><code>_Atomic</code> 类型修饰符和 <code>&lt;stdatomic.h&gt;</code> 头文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdatomic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">_Atomic</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    atomic_fetch_add(&amp;count, <span class="number">1</span>); <span class="comment">// 原子量加一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="增强的-Unicode-支持"><a href="#增强的-Unicode-支持" class="headerlink" title="增强的 Unicode 支持"></a>增强的 Unicode 支持</h2><h4 id="char16-t-和-char32-t"><a href="#char16-t-和-char32-t" class="headerlink" title="char16_t 和 char32_t"></a><code>char16_t</code> 和 <code>char32_t</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char16_t</span> utf16_str[] = <span class="string">u&quot;你好&quot;</span>;</span><br><span class="line"><span class="type">char32_t</span> utf32_str[] = <span class="string">U&quot;世界&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="头文件-1"><a href="#头文件-1" class="headerlink" title="&lt;uchar.h&gt; 头文件"></a><code>&lt;uchar.h&gt;</code> 头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char16_t</span> str[] = <span class="string">u&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(str));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="删除-gets-，新增-gets-s"><a href="#删除-gets-，新增-gets-s" class="headerlink" title="删除 gets()，新增 gets_s()"></a>删除 <code>gets()</code>，新增 <code>gets_s()</code></h2><ul><li><code>gets()</code> 已被删除，不再安全。</li><li><code>gets_s()</code> 是 C11 增加的安全替代：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gets_s 在部分实现中可用</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">gets_s(buf, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="边界检查函数接口（如-fopen-s、strcat-s-等）"><a href="#边界检查函数接口（如-fopen-s、strcat-s-等）" class="headerlink" title="边界检查函数接口（如 fopen_s、strcat_s 等）"></a>边界检查函数接口（如 <code>fopen_s</code>、<code>strcat_s</code> 等）</h2><p>增加了<a href="https://zh.wikipedia.org/wiki/%E8%BE%B9%E7%95%8C%E6%A3%80%E6%9F%A5">边界检查</a>函数接口，定义了新的安全的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE* fp;</span><br><span class="line">    <span class="keyword">if</span> (fopen_s(&amp;fp, <span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 成功打开</span></span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="浮点处理宏的增强"><a href="#浮点处理宏的增强" class="headerlink" title="浮点处理宏的增强"></a>浮点处理宏的增强</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;float.h&gt;</span></span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Decimal digits of precision: %d\n&quot;</span>, DECIMAL_DIG);</span><br></pre></td></tr></table></figure><p>输出：<code>Decimal digits of precision: 36</code></p><hr><h2 id="匿名结构体-联合体支持"><a href="#匿名结构体-联合体支持" class="headerlink" title="匿名结构体&#x2F;联合体支持"></a>匿名结构体&#x2F;联合体支持</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">float</span> f;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; var;</span><br><span class="line">var.i = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="静态断言（Static-Assertion）-Static-assert"><a href="#静态断言（Static-Assertion）-Static-assert" class="headerlink" title="静态断言（Static Assertion）_Static_assert"></a>静态断言（Static Assertion）<code>_Static_assert</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">_Static_assert</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) == <span class="number">4</span>, <span class="string">&quot;int must be 4 bytes&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="新的-fopen-模式（“…x”）"><a href="#新的-fopen-模式（“…x”）" class="headerlink" title="新的 fopen 模式（“…x”）"></a>新的 fopen 模式（“…x”）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;wx&quot;</span>); <span class="comment">// 仅当文件不存在才创建并写入</span></span><br></pre></td></tr></table></figure><hr><h2 id="新增-quick-exit-函数"><a href="#新增-quick-exit-函数" class="headerlink" title="新增 quick_exit() 函数"></a>新增 quick_exit() 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 仅被 quick_exit 调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    at_quick_exit(cleanup);</span><br><span class="line">    quick_exit(<span class="number">0</span>); <span class="comment">// 快速退出，不执行普通 atexit 注册的清理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://cppreference.cn/w/c/11&quot;&gt;参考文档&lt;/a&gt;，还可进一步了解&lt;a href=&quot;https://cppreference.cn/w/c/23&quot;&gt;c23&lt;/a&gt;（但是测试了安装的gcc和clang (2025.9.19) 编</summary>
      
    
    
    
    
    <category term="C语言" scheme="https://sfxfs.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C-11" scheme="https://sfxfs.github.io/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>奇异递归模板模式 CRTP</title>
    <link href="https://sfxfs.github.io/2025/09/02/%E5%A5%87%E5%BC%82%E9%80%92%E5%BD%92%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F-CRTP/"/>
    <id>https://sfxfs.github.io/2025/09/02/%E5%A5%87%E5%BC%82%E9%80%92%E5%BD%92%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F-CRTP/</id>
    <published>2025-09-02T07:17:50.000Z</published>
    <updated>2025-10-15T16:13:39.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CRTP-的用途"><a href="#CRTP-的用途" class="headerlink" title="CRTP 的用途"></a>CRTP 的用途</h2><p>CRTP (Curiously Recurring Template Pattern) 主要用于实现<strong>静态多态</strong>。与 C++ 中常见的虚函数（virtual function）实现的动态多态不同，CRTP 在编译时解析函数调用，因此没有运行时开销。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>假设我们想创建一个通用的基类，它可以计算任何派生类的面积，只要派生类提供一个 <code>getArea()</code> 方法。</p><h3 id="例子：计算几何图形的面积"><a href="#例子：计算几何图形的面积" class="headerlink" title="例子：计算几何图形的面积"></a>例子：计算几何图形的面积</h3><p>首先，我们定义一个<strong>CRTP基类模板</strong> <code>Shape</code>。这个基类有一个方法 <code>calculateAndPrintArea()</code>，它的任务是调用派生类中实现的 <code>getArea()</code> 方法，并打印结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculateAndPrintArea</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 static_cast 将基类指针转换为派生类指针。</span></span><br><span class="line">        <span class="comment">// 这就是 CRTP 的核心：基类“知道”派生类的类型，</span></span><br><span class="line">        <span class="comment">// 从而可以静态调用派生类的成员函数。</span></span><br><span class="line">        <span class="type">const</span> Derived&amp; derived = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> Derived&amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用派生类中实现的 getArea() 方法</span></span><br><span class="line">        <span class="type">double</span> area = derived.<span class="built_in">getArea</span>();</span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The area is: &quot;</span> &lt;&lt; area &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>接下来，我们创建两个具体的<strong>派生类</strong>：<code>Circle</code> 和 <code>Rectangle</code>。它们都继承自 <code>Shape</code>，并以自己作为模板参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape&lt;Circle&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> radius) : <span class="built_in">m_radius</span>(radius) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 派生类必须实现 getArea() 方法</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14159</span> * m_radius * m_radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> m_radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape&lt;Rectangle&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">double</span> width, <span class="type">double</span> height) : <span class="built_in">m_width</span>(width), <span class="built_in">m_height</span>(height) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 派生类必须实现 getArea() 方法</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_width * m_height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> m_width;</span><br><span class="line">    <span class="type">double</span> m_height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>在 <code>main</code> 函数中，我们可以创建 <code>Circle</code> 和 <code>Rectangle</code> 对象，并直接调用基类中定义的 <code>calculateAndPrintArea()</code>方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Circle <span class="title">circle</span><span class="params">(<span class="number">5.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Rectangle <span class="title">rectangle</span><span class="params">(<span class="number">4.0</span>, <span class="number">6.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用基类的方法，但实际上会调用派生类中实现的 getArea()</span></span><br><span class="line">    circle.<span class="built_in">calculateAndPrintArea</span>();      <span class="comment">// 输出: The area is: 78.5397</span></span><br><span class="line">    rectangle.<span class="built_in">calculateAndPrintArea</span>();   <span class="comment">// 输出: The area is: 24</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么这个例子体现了-CRTP？"><a href="#为什么这个例子体现了-CRTP？" class="headerlink" title="为什么这个例子体现了 CRTP？"></a>为什么这个例子体现了 CRTP？</h3><p>在这个例子中，<code>Shape</code> 基类模板利用<strong>奇异递归模板模式</strong>实现了<strong>静态多态</strong>。</p><ol><li><p><strong>静态类型信息</strong>：当 <code>Circle</code> 继承 <code>Shape&lt;Circle&gt;</code> 时，<code>Shape</code> 类在编译时就知道了它所操作的对象类型是 <code>Circle</code>。</p></li><li><p><strong>静态绑定</strong>：在 <code>Shape::calculateAndPrintArea()</code> 方法中，<code>static_cast&lt;const Derived&amp;&gt;(*this)</code> 将 <code>Shape</code> 对象的引用转换为一个<strong>编译时已知的派生类引用</strong>。</p></li><li><p><strong>无运行时开销</strong>：<code>derived.getArea()</code> 的调用是一个<strong>普通的函数调用</strong>，而不是虚函数表查找。这使得代码在运行时更加高效。</p></li></ol><p>通过这个模式，我们为所有派生类提供了通用的接口 (<code>calculateAndPrintArea()</code>)，同时将具体实现 (<code>getArea()</code>) 留给每个派生类自己完成，所有这些都在<strong>编译时</strong>完成，没有任何运行时多态的开销。</p><hr><h3 id="进阶：与-Deducing-this-的结合"><a href="#进阶：与-Deducing-this-的结合" class="headerlink" title="进阶：与 Deducing this 的结合"></a>进阶：与 Deducing this 的结合</h3><p>在刚才的例子中，为了在基类里调用派生类的方法，我们必须显式地将 <code>this</code> 指针进行 <code>static_cast</code>，这既不美观，也增加了出错的风险。</p><p>C++<strong>23</strong> 引入了“显式 <code>this</code> 对象参数”（explicit <code>this</code> object parameter），通常称为 “Deducing <code>this</code>“。它允许你将 <code>this</code> 作为一个明确的函数参数来声明，并可以将其模板化。</p><p>它看起来像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyType</span> &#123;</span><br><span class="line">    <span class="comment">// &#x27;self&#x27; 的类型会被推导为 *this 对象的实际类型</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Self&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">my_method</span><span class="params">(<span class="keyword">this</span> Self&amp;&amp; self, <span class="comment">/* ... other args ... */</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的 <code>Self</code> 会被推导为 <code>MyType&amp;</code>, <code>const MyType&amp;</code>, <code>MyType&amp;&amp;</code>, <code>const MyType&amp;&amp;</code> 等等，完美地保留了对象的 <code>const</code>&#x2F;<code>volatile</code> 限定和值类别。</p><p>当我们将 Deducing <code>this</code> 应用于 CRTP 模式时，上述所有痛点都迎刃而解。基类的实现变得异常简洁和优雅。</p><p><strong>结合后的现代化实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Self&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculateAndPrintArea</span><span class="params">(<span class="keyword">this</span> Self&amp;&amp; self)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 直接就可调用派生类中实现的 getArea() 方法</span></span><br><span class="line">        <span class="type">double</span> area = self.<span class="built_in">getArea</span>();</span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The area is: &quot;</span> &lt;&lt; area &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="如果去掉-template-会怎样？"><a href="#如果去掉-template-会怎样？" class="headerlink" title="如果去掉 template &lt;typename Derived&gt; 会怎样？"></a>如果去掉 <code>template &lt;typename Derived&gt;</code> 会怎样？</h4><p>如果我们去掉它，代码依然是合法的，但这就不再是 CRTP 模式了。它会变成一种不同的、更简单的模式，可以称之为 <strong>“Deducing <code>this</code> Mixin”</strong>。刚才的例子就可以去掉，因为我们并没有用到它，但是有些情况下不能去掉：</p><p>因为 <code>Derived</code> 在整个类定义中都有效，所以它能做到许多 <code>Self</code> 做不到的事情。这些事情正是 CRTP 模式强大功能的核心。</p><p><strong>示例1：实现静态工厂函数或克隆</strong></p><p>基类可以定义一个创建或复制派生类实例的接口，因为它在编译期就知道 <code>Derived</code> 的具体类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Clonable</span> &#123;</span><br><span class="line">    <span class="comment">// 只有知道 Derived 类型，才能返回 Derived 对象</span></span><br><span class="line">    <span class="function">Derived <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用派生类的拷贝构造函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Derived</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> Derived&amp;&gt;(*<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态工厂函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Derived <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Derived</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyType</span> : <span class="keyword">public</span> Clonable&lt;MyType&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">MyType obj1;</span><br><span class="line">MyType obj2 = obj1.<span class="built_in">clone</span>();       <span class="comment">// 正确</span></span><br><span class="line">MyType obj3 = MyType::<span class="built_in">create</span>();   <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>如果只用 <code>deducing this</code>，<code>clone</code> 函数的返回类型无法确定为 <code>Derived</code>，因为它在函数签名中不可用。</p><p><strong>示例2：访问派生类的类型别名或静态成员</strong></p><p>基类可以访问派生类中定义的 <code>static</code> 成员或类型别名（<code>using</code> &#x2F; <code>typedef</code>）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 访问派生类的静态成员</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Component ID: &quot;</span> &lt;&lt; Derived::COMPONENT_ID &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sensor</span> : <span class="keyword">public</span> Component&lt;Sensor&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> COMPONENT_ID = <span class="number">101</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Actuator</span> : <span class="keyword">public</span> Component&lt;Actuator&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> COMPONENT_ID = <span class="number">205</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Sensor s;</span><br><span class="line">s.<span class="built_in">print_info</span>(); <span class="comment">// 输出: Component ID: 101</span></span><br></pre></td></tr></table></figure><p><code>Self</code> 是在函数调用时才具象化的实例类型，所以无法用于在<strong>函数签名之外</strong>访问类型的静态属性**（也就是说之内的话也是可以的）。</p>]]></content>
    
    
    <summary type="html">详解C++奇异递归模板模式(CRTP)的原理和应用，实现零开销静态多态的高级编程技巧</summary>
    
    
    
    <category term="编程语言" scheme="https://sfxfs.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="https://sfxfs.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"/>
    
    
    <category term="C++" scheme="https://sfxfs.github.io/tags/C/"/>
    
    <category term="编程技巧" scheme="https://sfxfs.github.io/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    <category term="CRTP" scheme="https://sfxfs.github.io/tags/CRTP/"/>
    
    <category term="模板编程" scheme="https://sfxfs.github.io/tags/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/"/>
    
    <category term="静态多态" scheme="https://sfxfs.github.io/tags/%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81/"/>
    
    <category term="设计模式" scheme="https://sfxfs.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="高级C++" scheme="https://sfxfs.github.io/tags/%E9%AB%98%E7%BA%A7C/"/>
    
  </entry>
  
  <entry>
    <title>this auto&amp;&amp; self 详解</title>
    <link href="https://sfxfs.github.io/2025/09/02/this-auto-self-%E8%AF%A6%E8%A7%A3/"/>
    <id>https://sfxfs.github.io/2025/09/02/this-auto-self-%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-09-02T07:17:29.000Z</published>
    <updated>2025-10-15T15:32:48.746Z</updated>
    
    <content type="html"><![CDATA[<p>这句代码定义了一个类的下标操作符（<code>operator[]</code>），但它使用了两个 C++23 的新特性，使其变得非常通用和强大：</p><ol><li><p><strong>显式 <code>this</code> 参数 (<code>this auto&amp;&amp; self</code>)</strong> 即 <strong>Deducing this</strong></p></li><li><p><strong>推导返回类型 (<code>auto&amp;&amp;</code>)</strong></p></li></ol><p>让我们一步步分解来理解。</p><h3 id="核心功能：定义下标操作符"><a href="#核心功能：定义下标操作符" class="headerlink" title="核心功能：定义下标操作符 []"></a>核心功能：定义下标操作符 <code>[]</code></h3><p>首先，这句代码的本质是重载（overload）下标操作符 <code>[]</code>。这允许类的对象可以像数组一样使用方括号来访问成员。例如，如果你有一个名为 <code>MyArray</code> 的类，定义了这个操作符后，你就可以这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyArray arr;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">auto</span> value = arr[<span class="number">5</span>]; <span class="comment">// 这会调用 MyArray::operator[]</span></span><br></pre></td></tr></table></figure><h3 id="1-this-auto-self：显式-this-对象参数"><a href="#1-this-auto-self：显式-this-对象参数" class="headerlink" title="1. this auto&amp;&amp; self：显式 this 对象参数"></a>1. <code>this auto&amp;&amp; self</code>：显式 <code>this</code> 对象参数</h3><p>这是 C++23 引入的一个重要特性，被称为 “Deducing <code>this</code>“。</p><p>在<strong>传统</strong>的 C++ 中，成员函数有一个隐式的 <code>this</code> 指针，指向调用该函数的对象。你可以根据 <code>const</code> 或 <code>&amp;</code>&#x2F;<code>&amp;&amp;</code> 限定符来为不同类型的对象（<code>const</code> 对象、<a href="./%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E8%AF%A6%E8%A7%A3.md">左值对象、右值对象</a>）重载成员函数。</p><p>例如，为了同时支持 <code>arr[i]</code> 和 <code>const_arr[i]</code>，你可能需要写两个版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++23 之前</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 版本 1: non-const 左值对象</span></span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) &amp; &#123;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 版本 2: const 左值对象</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span>&amp; &#123;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可能还需要为右值对象写更多版本...</span></span><br><span class="line">    <span class="comment">// int&amp;&amp; operator[](int index) &amp;&amp;;</span></span><br><span class="line">    <span class="comment">// const int&amp;&amp; operator[](int index) const&amp;&amp;;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方式非常繁琐。</p><p><strong><code>this auto&amp;&amp; self</code></strong> 通过将隐式的 <code>this</code> 指针变成一个显式的、可推导的函数参数，完美地解决了这个问题。</p><ul><li><p><strong><code>this</code></strong>: 关键字，表明这个参数是用来捕获 <code>*this</code> 对象（即调用该成员函数的对象实例）的。</p></li><li><p><strong><code>auto&amp;&amp;</code></strong>: 这是个“转发 (forward) 引用”或“通用引用”。它可以接收任何类型的对象（<code>const</code>、<code>non-const</code>、左值、右值），并保持其原始的类型和值类别（value category）。</p></li><li><p><strong><code>self</code></strong>: 这是我们给这个参数起的<em>名字</em>，就像普通的函数参数一样。</p></li></ul><p><strong><code>self</code> 的类型会根据调用对象的状态自动推导：</strong></p><table><thead><tr><th>如果这样调用…</th><th><code>self</code> 的类型会被推导为…</th></tr></thead><tbody><tr><td><code>MyArray arr; arr[0];</code></td><td><code>MyArray&amp;</code> (左值引用)</td></tr><tr><td><code>const MyArray arr; arr[0];</code></td><td><code>const MyArray&amp;</code> (<code>const</code> 左值引用)</td></tr><tr><td><code>MyArray{}; arr[0];</code></td><td><code>MyArray&amp;&amp;</code> (右值引用)</td></tr><tr><td><code>const MyArray{}; arr[0];</code></td><td><code>const MyArray&amp;&amp;</code> (<code>const</code> 右值引用)</td></tr></tbody></table><p>这样，你<strong>只需要写一个函数</strong>，编译器就会自动为你处理所有情况，极大地简化了代码。</p><h3 id="2-auto-：推导返回类型"><a href="#2-auto-：推导返回类型" class="headerlink" title="2. auto&amp;&amp;：推导返回类型"></a>2. <code>auto&amp;&amp;</code>：推导返回类型</h3><p>这里的 <code>auto&amp;&amp;</code> 作为返回类型，同样是一个“转发引用”。它的作用是<strong>完美转发</strong>（perfectly forward）<code>self</code> 对象内部的数据成员。</p><ul><li><p><strong>目标</strong>: <code>operator[]</code> 的返回值类型应该与 <code>self</code> 的类型相匹配。</p><ul><li><p>如果 <code>self</code> 是 <code>const</code> 的，返回的也应该是 <code>const</code> 引用。</p></li><li><p>如果 <code>self</code> 是 <code>non-const</code> 的，返回的应该是 <code>non-const</code> 引用，这样我们才能修改它（例如 <code>arr[0] = 100;</code>）。</p></li><li><p>如果 <code>self</code> 是一个右值（临时对象），我们可能希望返回一个右值引用。</p></li></ul></li></ul><p><code>auto&amp;&amp;</code> 配合 <code>std::forward</code> 就能轻松实现这一点。</p><h3 id="完整示例与解释"><a href="#完整示例与解释" class="headerlink" title="完整示例与解释"></a>完整示例与解释</h3><p>下面是一个完整的例子，展示了这句代码在实际类中的应用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// for std::forward</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// C++23 的统一下标操作符</span></span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; <span class="keyword">operator</span>[](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> index) &#123;</span><br><span class="line">        <span class="comment">// self 会被推导为 MyArray&amp;, const MyArray&amp;, MyArray&amp;&amp; 等</span></span><br><span class="line">        <span class="comment">// 我们使用 std::forward 来保持 self 的值类别</span></span><br><span class="line">        <span class="comment">// 并返回其内部 data 成员的相应引用类型</span></span><br><span class="line">        <span class="keyword">return</span> std::forward&lt;<span class="keyword">decltype</span>(self)&gt;(self).data[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyArray&lt;<span class="type">int</span>, <span class="number">5</span>&gt; arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. non-const 左值对象: self 推导为 MyArray&amp;</span></span><br><span class="line">    <span class="comment">// 返回类型为 int&amp;，可以修改</span></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;arr[0] = &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. const 左值对象: self 推导为 const MyArray&amp;</span></span><br><span class="line">    <span class="comment">// 返回类型为 const int&amp;，不能修改</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; const_arr = arr;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;const_arr[0] = &quot;</span> &lt;&lt; const_arr[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// const_arr[0] = 20; // 这行会编译错误，符合预期</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 右值（临时）对象: self 推导为 MyArray&amp;&amp;</span></span><br><span class="line">    <span class="comment">// 返回类型为 int&amp;&amp;</span></span><br><span class="line">    <span class="keyword">auto</span> value = MyArray&lt;<span class="type">int</span>, <span class="number">5</span>&gt;&#123;&#125;[<span class="number">0</span>]; <span class="comment">// 从一个临时对象取值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value from temporary = &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><p><code>std::forward&lt;decltype(self)&gt;(self)</code> 是关键。它确保如果 <code>self</code> 是一个左值引用（<code>MyArray&amp;</code>），那么 <code>self.data[index]</code> 也会被当作左值返回（类型为 <code>int&amp;</code>）。如果 <code>self</code> 是一个右值引用（<code>MyArray&amp;&amp;</code>），那么 <code>self.data[index]</code> 也会被当作右值返回（类型为 <code>int&amp;&amp;</code>）。</p></li><li><p><code>decltype(self)</code> 获取 <code>self</code> 被推导出的精确类型。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这句 <code>auto&amp;&amp; operator[](this auto&amp;&amp; self, int index)</code> 是 C++23 中一种极其现代、简洁且强大的方式来定义类的下标操作符。</p><p><strong>它的核心意思是：</strong></p><blockquote><p><strong>“定义一个通用的下标操作符，它能接受任何类型（<code>const</code>、<code>non-const</code>、左值、右值）的对象实例。它会根据调用对象的类型，自动推导出最合适的返回类型（<code>T&amp;</code>, <code>const T&amp;</code>, <code>T&amp;&amp;</code>等），从而允许我们用一套代码完美地处理所有情况，无论是读取、修改还是从临时对象中取值。”</strong></p></blockquote><p>它通过将 <code>this</code> 显式化和利用类型推导，彻底解决了旧版本 C++ 中需要为不同对象状态编写多个重载版本的繁琐问题。</p>]]></content>
    
    
    <summary type="html">深入解析C++23新特性中的显式this参数和推导返回类型，理解现代C++的高级语法特性</summary>
    
    
    
    <category term="编程语言" scheme="https://sfxfs.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="https://sfxfs.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"/>
    
    
    <category term="C++" scheme="https://sfxfs.github.io/tags/C/"/>
    
    <category term="C++23" scheme="https://sfxfs.github.io/tags/C-23/"/>
    
    <category term="显式this" scheme="https://sfxfs.github.io/tags/%E6%98%BE%E5%BC%8Fthis/"/>
    
    <category term="新特性" scheme="https://sfxfs.github.io/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    <category term="操作符重载" scheme="https://sfxfs.github.io/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
    <category term="现代C++" scheme="https://sfxfs.github.io/tags/%E7%8E%B0%E4%BB%A3C/"/>
    
    <category term="语法特性" scheme="https://sfxfs.github.io/tags/%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>引用包装器</title>
    <link href="https://sfxfs.github.io/2025/09/02/%E5%BC%95%E7%94%A8%E5%8C%85%E8%A3%85%E5%99%A8/"/>
    <id>https://sfxfs.github.io/2025/09/02/%E5%BC%95%E7%94%A8%E5%8C%85%E8%A3%85%E5%99%A8/</id>
    <published>2025-09-02T07:16:59.000Z</published>
    <updated>2025-09-24T06:28:27.887Z</updated>
    
    <content type="html"><![CDATA[<p><code>std::reference_wrapper</code> 是 C++ 标准库 <code>&lt;functional&gt;</code> 头文件中的一个类模板，它的主要作用是<strong>将引用包装成一个可拷贝、可赋值的对象</strong>。</p><h3 id="什么是-std-reference-wrapper？"><a href="#什么是-std-reference-wrapper？" class="headerlink" title="什么是 std::reference_wrapper？"></a>什么是 <code>std::reference_wrapper</code>？</h3><p>在 C++ 中，引用（reference）本身不能被重新赋值，也不能作为容器的元素，因为它们不符合大多数标准库容器和算法对**可拷贝（Copyable）<strong>或</strong>可赋值（Assignable）**的要求。</p><p><code>std::reference_wrapper&lt;T&gt;</code> 解决了这个问题。它内部持有一个 <code>T</code> 类型的引用，但它本身是一个对象，可以像普通对象一样被拷贝和赋值。当你拷贝一个 <code>std::reference_wrapper</code> 对象时，你拷贝的是对<strong>同一个</strong>原始对象的引用，而不是拷贝原始对象本身。</p><h3 id="为什么需要它？"><a href="#为什么需要它？" class="headerlink" title="为什么需要它？"></a>为什么需要它？</h3><p><code>std::reference_wrapper</code> 的主要用途是<strong>让引用能够与标准库容器和算法协同工作</strong>。</p><p>许多标准库组件，比如 <code>std::vector</code>、<code>std::list</code>、<code>std::thread</code>、<code>std::sort</code> 等，要求其操作的对象是可拷贝的。如果你直接尝试将引用放入这些容器或传递给这些函数，编译器会报错。</p><p>例如，下面的代码无法编译，因为 <code>std::vector</code> 不允许存储引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例：不能直接存储引用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// std::vector&lt;int&amp;&gt; my_vec; // 编译错误！</span></span><br></pre></td></tr></table></figure><p>通过使用 <code>std::reference_wrapper</code>，你可以绕过这个限制，将引用“伪装”成一个可存储在容器中的对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// 必须包含此头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// std::vector&lt;std::reference_wrapper&lt;int&gt;&gt; 允许存储对 int 对象的引用</span></span><br><span class="line">    std::vector&lt;std::reference_wrapper&lt;<span class="type">int</span>&gt;&gt; my_vec;</span><br><span class="line">    </span><br><span class="line">    my_vec.<span class="built_in">push_back</span>(std::<span class="built_in">ref</span>(a)); <span class="comment">// std::ref 是一个辅助函数，用于创建 std::reference_wrapper</span></span><br><span class="line">    my_vec.<span class="built_in">push_back</span>(std::<span class="built_in">ref</span>(b));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改容器中的第一个元素，实际上是修改了原始变量 a</span></span><br><span class="line">    my_vec[<span class="number">0</span>].<span class="built_in">get</span>() = <span class="number">100</span>; <span class="comment">// 使用 .get() 来获取被包装的引用</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original value of a: &quot;</span> &lt;&lt; a &lt;&lt; std::endl; <span class="comment">// 输出: Original value of a: 100</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original value of b: &quot;</span> &lt;&lt; b &lt;&lt; std::endl; <span class="comment">// 输出: Original value of b: 20</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>std::ref</code> 和 <code>std::cref</code> 辅助函数：</strong></p><p>为了方便使用，C++ 标准库提供了两个辅助函数：</p><ul><li><p><code>std::ref(T&amp; obj)</code>：创建一个 <code>std::reference_wrapper&lt;T&gt;</code> 对象。</p></li><li><p><code>std::cref(const T&amp; obj)</code>：创建一个 <code>std::reference_wrapper&lt;const T&gt;</code> 对象，用于常量引用。</p></li></ul><h3 id="std-reference-wrapper-的常见用途"><a href="#std-reference-wrapper-的常见用途" class="headerlink" title="std::reference_wrapper 的常见用途"></a><code>std::reference_wrapper</code> 的常见用途</h3><ul><li><p><strong>容器存储引用：</strong> 如上例所示，将引用放入 <code>std::vector</code>、<code>std::map</code> 等容器中。</p></li><li><p><strong>多线程传递可变对象：</strong> 当使用 <code>std::thread</code> 启动新线程时，如果你希望线程函数能够修改一个外部变量，你需要通过 <code>std::ref</code> 传递引用。直接传递变量会发生拷贝。</p></li><li><p><strong>泛型编程与算法：</strong> 在使用如 <code>std::bind</code> 或 <code>std::sort</code> 等算法时，如果你想让它们操作原始对象而不是拷贝，<code>std::reference_wrapper</code> 是一个重要的工具。</p></li></ul><p><strong>例子：<code>std::sort</code> 的应用</strong></p><p>假设你有一个自定义对象的向量，你想根据其中一个成员变量对它们进行排序，但你不想拷贝整个对象。你可以创建一个存储 <code>std::reference_wrapper</code> 的向量来对原始对象进行间接排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="built_in">MyObject</span>(<span class="type">int</span> i, <span class="type">const</span> std::string&amp; n) : <span class="built_in">id</span>(i), <span class="built_in">name</span>(n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;MyObject&gt; objs;</span><br><span class="line">    objs.<span class="built_in">emplace_back</span>(<span class="number">2</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">    objs.<span class="built_in">emplace_back</span>(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">    objs.<span class="built_in">emplace_back</span>(<span class="number">3</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个包含对原始对象引用的向量</span></span><br><span class="line">    std::vector&lt;std::reference_wrapper&lt;MyObject&gt;&gt; refs;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; obj : objs) &#123;</span><br><span class="line">        refs.<span class="built_in">push_back</span>(std::<span class="built_in">ref</span>(obj));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 sort 对引用进行排序，比较器通过 .get() 访问原始对象</span></span><br><span class="line">    std::<span class="built_in">sort</span>(refs.<span class="built_in">begin</span>(), refs.<span class="built_in">end</span>(), [](<span class="type">const</span> std::reference_wrapper&lt;MyObject&gt;&amp; a, <span class="type">const</span> std::reference_wrapper&lt;MyObject&gt;&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">get</span>().id &lt; b.<span class="built_in">get</span>().id;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原始向量 objs 保持不变，但 refs 向量已经排序</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted references:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ref : refs) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; ref.<span class="built_in">get</span>().id &lt;&lt; <span class="string">&quot;, Name: &quot;</span> &lt;&lt; ref.<span class="built_in">get</span>().name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p><code>std::reference_wrapper</code> 是一种“引用对象”，它解决了 C++ 中引用不能被拷贝、不能被赋值、不能作为容器元素的问题。它的核心价值在于<strong>让引用能够无缝地融入 C++ 标准库的容器和算法生态系统</strong>，从而在需要传递引用而非拷贝时提供了强大的支持。</p>]]></content>
    
    
    <summary type="html">详解C++ std::reference_wrapper的原理和应用，解决引用不能存储在容器中的问题</summary>
    
    
    
    <category term="编程语言" scheme="https://sfxfs.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="https://sfxfs.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"/>
    
    
    <category term="C++" scheme="https://sfxfs.github.io/tags/C/"/>
    
    <category term="STL" scheme="https://sfxfs.github.io/tags/STL/"/>
    
    <category term="引用包装器" scheme="https://sfxfs.github.io/tags/%E5%BC%95%E7%94%A8%E5%8C%85%E8%A3%85%E5%99%A8/"/>
    
    <category term="标准库" scheme="https://sfxfs.github.io/tags/%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
    <category term="容器" scheme="https://sfxfs.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="泛型编程" scheme="https://sfxfs.github.io/tags/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>移动语义</title>
    <link href="https://sfxfs.github.io/2025/09/02/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/"/>
    <id>https://sfxfs.github.io/2025/09/02/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/</id>
    <published>2025-09-02T07:16:42.000Z</published>
    <updated>2025-09-24T06:28:27.887Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-移动语义：深入解析核心概念与优势"><a href="#C-移动语义：深入解析核心概念与优势" class="headerlink" title="C++ 移动语义：深入解析核心概念与优势"></a>C++ 移动语义：深入解析核心概念与优势</h2><p>在 C++11 标准中，<strong>移动语义 (Move Semantics)</strong> 是一项革命性的新增特性，其核心思想在于<strong>避免不必要的内存拷贝</strong>，通过“窃取”或“转移”资源的所有权来提升程序性能。这在处理大型数据结构，如容器、字符串或任何持有动态分配内存的类时，效果尤为显著。</p><h3 id="为何需要移动语义？问题的根源：深拷贝"><a href="#为何需要移动语义？问题的根源：深拷贝" class="headerlink" title="为何需要移动语义？问题的根源：深拷贝"></a>为何需要移动语义？问题的根源：深拷贝</h3><p>在 C++11 之前，对象的复制是通过<strong>拷贝构造函数</strong>和<strong>拷贝赋值运算符</strong>完成的。当对象内部含有指针，指向动态分配的资源（如堆内存）时，为了确保新旧对象各自拥有一份独立的资源，必须进行<strong>深拷贝</strong>。</p><p>例如，考虑一个简单的字符串类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* s = <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        size_ = <span class="built_in">strlen</span>(s);</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">char</span>[size_ + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data_, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数 (深拷贝)</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">char</span>[size_ + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data_, other.data_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data_;</span><br><span class="line">    <span class="type">size_t</span> size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>深拷贝的问题在于，当源对象是一个**临时对象（右值）**时，这种拷贝就显得非常浪费。临时对象在表达式结束后就会被立即销毁，我们花费了大量资源去复制它，然后又马上释放这些资源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyString <span class="title">a</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">MyString <span class="title">b</span><span class="params">(a)</span></span>; <span class="comment">// 调用拷贝构造函数，有必要</span></span><br><span class="line"><span class="function">MyString <span class="title">c</span><span class="params">(MyString(<span class="string">&quot;World&quot;</span>))</span></span>; <span class="comment">// 调用拷贝构造函数，但源对象是临时对象，拷贝是浪费</span></span><br></pre></td></tr></table></figure><p>在第三行中，<code>MyString(&quot;World&quot;)</code> 创建了一个临时对象，它的内容被深拷贝到 <code>c</code> 中，然后这个临时对象被销assed，其内部的 <code>data_</code> 被释放。如果能直接将临时对象的 <code>data_</code> “转移”给 <code>c</code>，就可以避免这次昂贵的内存分配和拷贝。</p><h3 id="核心概念：右值引用-Rvalue-Reference"><a href="#核心概念：右值引用-Rvalue-Reference" class="headerlink" title="核心概念：右值引用 (Rvalue Reference)"></a>核心概念：右值引用 (Rvalue Reference)</h3><p>为了解决上述问题，C++11 引入了<strong>右值引用</strong>，其语法为 <code>T&amp;&amp;</code>。右值引用专门用于“绑定”到右值（临时对象、函数返回值等）。</p><ul><li><p><strong>左值 (Lvalue)</strong>：可以出现在赋值语句左侧的表达式，通常拥有持久的内存地址，可以被取地址。例如，变量名。</p></li><li><p><strong>右值 (Rvalue)</strong>：只能出现在赋值语句右侧的表达式，通常是临时的，即将消亡。例如，字面量、函数返回的临时对象。</p></li></ul><p>通过重载接受右值引用的函数，我们就可以区分出传递的是左值还是右值，并为右值提供一种不同的、更高效的处理方式。</p><h3 id="实现移动语义：移动构造函数与移动赋值运算符"><a href="#实现移动语义：移动构造函数与移动赋值运算符" class="headerlink" title="实现移动语义：移动构造函数与移动赋值运算符"></a>实现移动语义：移动构造函数与移动赋值运算符</h3><p>移动语义主要通过两个特殊的成员函数来实现：</p><ol><li><p><strong>移动构造函数 (Move Constructor)</strong></p></li><li><p><strong>移动赋值运算符 (Move Assignment Operator)</strong></p></li></ol><p>它们的参数都是一个<strong>右值引用</strong>。其核心逻辑是“窃取”源对象的资源，并将源对象置于一个有效的、可析构的状态（通常是将其内部指针设为 <code>nullptr</code>）。</p><p>为 <code>MyString</code> 类添加移动构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动构造函数</span></span><br><span class="line"><span class="built_in">MyString</span>(MyString&amp;&amp; other) <span class="keyword">noexcept</span> &#123; <span class="comment">// noexcept 很重要</span></span><br><span class="line">    <span class="comment">// 1. 窃取资源</span></span><br><span class="line">    data_ = other.data_;</span><br><span class="line">    size_ = other.size_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将源对象置于有效状态</span></span><br><span class="line">    other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    other.size_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，当用一个右值初始化 <code>MyString</code> 对象时，编译器会优先选择移动构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyString <span class="title">c</span><span class="params">(MyString(<span class="string">&quot;World&quot;</span>))</span></span>; <span class="comment">// 调用移动构造函数，非常高效</span></span><br></pre></td></tr></table></figure><p>这个过程没有新的内存分配，也没有数据拷贝，仅仅是几个指针的赋值操作。</p><h3 id="std-move：将左值转换为右值"><a href="#std-move：将左值转换为右值" class="headerlink" title="std::move：将左值转换为右值"></a><code>std::move</code>：将左值转换为右值</h3><p>有时候，我们希望强制对一个左值（例如一个即将不再使用的具名变量）也进行移动操作。这时就需要使用 <code>std::move</code>。</p><p><code>std::move</code> 本身<strong>并不执行任何移动操作</strong>，它的唯一作用是<strong>将一个左值强制转换为右值引用</strong>，从而让编译器能够调用移动构造函数或移动赋值运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// MyString s2(s1); // 调用拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我确定 s1 不再需要了，可以安全地移动它的资源</span></span><br><span class="line"><span class="function">MyString <span class="title">s2</span><span class="params">(std::move(s1))</span></span>; <span class="comment">// 调用移动构造函数，s1 的资源被转移给 s2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时，s1 内部的 data_ 已经为 nullptr，处于有效但不可用的状态</span></span><br></pre></td></tr></table></figure><p><strong>警告</strong>：在使用 <code>std::move</code> 之后，必须假定原始对象（上例中的 <code>s1</code>）的状态是未知的，不应再使用它，除非重新给它赋值。</p><h3 id="移动语义的优势"><a href="#移动语义的优势" class="headerlink" title="移动语义的优势"></a>移动语义的优势</h3><ol><li><p><strong>性能提升</strong>：通过避免不必要的深拷贝和内存分配，极大地提高了涉及资源转移场景的运行效率。</p></li><li><p><strong>资源所有权的清晰转移</strong>：使得资源（如文件句柄、网络套接字、智能指针 <code>std::unique_ptr</code>）的独占所有权模型得以实现。<code>std::unique_ptr</code> 禁止拷贝，但允许移动，就是移动语义的最佳实践之一。</p></li><li><p><strong>标准库的广泛应用</strong>：C++ 标准库中的许多组件，如 <code>std::vector</code>, <code>std::string</code>, <code>std::thread</code> 等都充分利用了移动语义。例如，当 <code>std::vector</code> 空间不足需要扩容时，如果其元素类型支持移动，它会移动旧内存中的元素到新内存，而不是逐一拷贝，从而显著优化性能。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>C++ 移动语义是现代C++编程的基石之一。它通过引入右值引用，并配合移动构造函数和移动赋值运算符，允许编译器在适当的时候（当源对象是即将消亡的右值时）选择“资源转移”而非“资源拷贝”。<code>std::move</code> 则为开发者提供了手动触发这种优化的能力。深刻理解并正确使用移动语义，是编写高效、现代的C++代码的关键。</p>]]></content>
    
    
    <summary type="html">深入解析C++11移动语义的核心概念，理解右值引用、移动构造函数和std::move的原理和应用</summary>
    
    
    
    <category term="编程语言" scheme="https://sfxfs.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="https://sfxfs.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"/>
    
    
    <category term="C++" scheme="https://sfxfs.github.io/tags/C/"/>
    
    <category term="现代C++" scheme="https://sfxfs.github.io/tags/%E7%8E%B0%E4%BB%A3C/"/>
    
    <category term="内存管理" scheme="https://sfxfs.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="性能优化" scheme="https://sfxfs.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="移动语义" scheme="https://sfxfs.github.io/tags/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/"/>
    
    <category term="右值引用" scheme="https://sfxfs.github.io/tags/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>左值和右值详解</title>
    <link href="https://sfxfs.github.io/2025/09/02/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E8%AF%A6%E8%A7%A3/"/>
    <id>https://sfxfs.github.io/2025/09/02/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-09-02T07:16:27.000Z</published>
    <updated>2025-09-24T06:28:27.887Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 的左值（lvalue）和右值（rvalue）是 C++ 语言中一个非常基础但又极其重要的概念。它们是 C++ 表达式（expression）的两种基本属性，深刻地影响着代码的性能和写法，尤其是在 C++11 标准引入“移动语义”（Move Semantics）之后。</p><p>简单来说，区分左值和右值的核心标准是：<strong>这个表达式所代表的数据，我们还能不能在后面的代码里再次访问到它。</strong></p><ul><li><p><strong>左值 (lvalue - locator value)</strong>：指那些在内存中<strong>有固定地址</strong>、<strong>可以被取地址</strong>（用 <code>&amp;</code> 运算符）并且<strong>在表达式结束后依然存在</strong>的表达式。你可以把它想象成一个有名字、有固定地址的“容器”。</p></li><li><p><strong>右值 (rvalue - read value)</strong>：指那些<strong>临时的</strong>、<strong>没有固定地址</strong>、在表达式结束后就会被销毁的表达式。你只能读取它的值，但不能对它取地址（通常情况下）。可以把它看作一个“即用即弃”的临时数据。</p></li></ul><hr><h3 id="从“赋值操作符”的左右看起（经典-C-98-时代）"><a href="#从“赋值操作符”的左右看起（经典-C-98-时代）" class="headerlink" title="从“赋值操作符”的左右看起（经典 C++98 时代）"></a>从“赋值操作符”的左右看起（经典 C++98 时代）</h3><p>在 C++ 的早期，最简单的区分方法是看它能否出现在赋值操作符 <code>=</code> 的左边：</p><ul><li><p><strong>能放在 <code>=</code> 左边的，就是左值。</strong> 因为放在左边意味着你要给它赋值，它必须有一个明确的、持久的存储位置。</p></li><li><p><strong>不能放在 <code>=</code> 左边的，就是右值。</strong> 因为它们是临时的，给一个即将销毁的东西赋值是毫无意义的。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>; <span class="comment">// &#x27;a&#x27; 是左值，因为它有内存地址，我们可以反复使用它。&#x27;10&#x27; 是右值，它是一个字面量，没有固定地址。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>; <span class="comment">// &#x27;b&#x27; 是左值。</span></span><br><span class="line"></span><br><span class="line">a = b;      <span class="comment">// 正确：&#x27;a&#x27; 和 &#x27;b&#x27; 都是左值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的都是错误的，因为等号左边不是一个合法的左值</span></span><br><span class="line"><span class="comment">// 10 = a;         // 错误！10 是一个右值（字面量）。</span></span><br><span class="line"><span class="comment">// (a + b) = 30;   // 错误！(a + b) 的计算结果是一个临时值，是右值。</span></span><br></pre></td></tr></table></figure><p><strong>常见的左值：</strong></p><ul><li><p>变量名 (<code>a</code>, <code>b</code>)</p></li><li><p>数组元素 (<code>arr[0]</code>)</p></li><li><p>返回左值引用的函数调用 (<code>get_a_reference()</code>)</p></li><li><p>解引用的指针 (<code>*p</code>)</p></li></ul><p><strong>常见的右值：</strong></p><ul><li><p>字面量 (<code>10</code>, <code>true</code>, <code>&#39;c&#39;</code>)</p></li><li><p>算术表达式的结果 (<code>a + b</code>)</p></li><li><p>返回非引用类型的函数返回值 (<code>get_a_value()</code>)</p></li><li><p>Lambda 表达式</p></li></ul><hr><h3 id="C-11-的革命：右值引用的诞生与移动语义"><a href="#C-11-的革命：右值引用的诞生与移动语义" class="headerlink" title="C++11 的革命：右值引用的诞生与移动语义"></a>C++11 的革命：右值引用的诞生与<a href="%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89.md">移动语义</a></h3><p>到了 C++11 标准，情况变得更加有趣和重要。为了解决临时对象产生的深拷贝（deep copy）带来的巨大性能开销，C++11 引入了<strong>右值引用（Rvalue Reference）和移动语义（Move Semantics）</strong>。</p><hr><h3 id="三、现代-C-的值类别（C-11-及以后）"><a href="#三、现代-C-的值类别（C-11-及以后）" class="headerlink" title="三、现代 C++ 的值类别（C++11 及以后）"></a>三、现代 C++ 的值类别（C++11 及以后）</h3><p>为了更精确地描述表达式的属性，C++11 以后将值的类别划分得更细，分为五个类别：</p><ol><li><p><strong>左值 (lvalue)</strong>: 传统的左值，有固定身份和位置。</p></li><li><p><strong>纯右值 (prvalue - pure rvalue)</strong>: 传统的右值，比如字面量 <code>10</code>、<code>true</code>，以及函数返回的非引用临时对象。它们是“纯粹”的值，不与任何具体对象相关联。</p></li><li><p><strong>将亡值 (xvalue - expiring value)</strong>: 这是 C++11 新增的概念。它代表那些生命周期即将结束的对象，通常是 <code>std::move</code> 的结果或返回右值引用的函数调用。它虽然像右值一样资源可以被窃取，但它又和某个具体的对象（曾经是左值）相关联。</p></li></ol><p>这五个类别之间有如下关系：</p><ul><li><p><strong>广义左值 (glvalue - generalized lvalue)</strong> &#x3D; <strong>左值</strong> + <strong>将亡值</strong>。（表示有身份的对象）</p></li><li><p><strong>右值 (rvalue)</strong> &#x3D; <strong>纯右值</strong> + <strong>将亡值</strong>。（表示可以被移动的对象）</p></li></ul><p>对大多数开发者而言，你不需要每天都去记忆这五个类别的精确定义。你只需要理解核心思想：</p><ul><li><p><strong>左值</strong>：有名字、能取地址、持久的对象。</p></li><li><p><strong>右值</strong>：临时的、即将销毁的、可以被“移动”的对象。</p></li><li><p><strong><code>std::move</code></strong>：一个“授权”，允许编译器将一个左值当作右值来处理，以便触发移动语义。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>特性</th><th>左值 (lvalue)</th><th>右值 (rvalue)</th></tr></thead><tbody><tr><td><strong>核心含义</strong></td><td>持久的对象，有固定内存地址</td><td>临时的值，表达式结束后即销毁</td></tr><tr><td><strong>能否取地址 (<code>&amp;</code>)</strong></td><td>可以</td><td>通常不可以（将亡值是例外）</td></tr><tr><td><strong>能否在 <code>=</code> 左边</strong></td><td>可以</td><td>不可以</td></tr><tr><td><strong>绑定到引用类型</strong></td><td>左值引用 (<code>T&amp;</code>)</td><td>右值引用 (<code>T&amp;&amp;</code>)</td></tr><tr><td><strong>与性能的关系</strong></td><td>通常涉及拷贝（Copy）</td><td>允许移动（Move），性能更高</td></tr><tr><td><strong>典型例子</strong></td><td>变量名、数组元素</td><td>字面量、表达式结果、<code>std::move</code>的结果</td></tr></tbody></table><p>理解左值和右值的区别是掌握现代 C++ 内存管理和性能优化的关键。它不仅是理论知识，更是编写高效、优雅代码的基石。</p>]]></content>
    
    
    <summary type="html">深入解析C++中左值和右值的概念，理解移动语义的基础，掌握现代C++内存管理和性能优化的关键知识</summary>
    
    
    
    <category term="编程语言" scheme="https://sfxfs.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="https://sfxfs.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"/>
    
    
    <category term="C++" scheme="https://sfxfs.github.io/tags/C/"/>
    
    <category term="编程基础" scheme="https://sfxfs.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    <category term="现代C++" scheme="https://sfxfs.github.io/tags/%E7%8E%B0%E4%BB%A3C/"/>
    
    <category term="内存管理" scheme="https://sfxfs.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="性能优化" scheme="https://sfxfs.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>组合和聚合的区别</title>
    <link href="https://sfxfs.github.io/2025/09/02/%E7%BB%84%E5%90%88%E5%92%8C%E8%81%9A%E5%90%88%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://sfxfs.github.io/2025/09/02/%E7%BB%84%E5%90%88%E5%92%8C%E8%81%9A%E5%90%88%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2025-09-02T07:16:08.000Z</published>
    <updated>2025-09-24T06:28:27.887Z</updated>
    
    <content type="html"><![CDATA[<h3 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h3><p>组合是一种<strong>强拥有</strong>关系，表示“部分”是“整体”的<strong>生命周期的一部分</strong>。如果整体被销毁，那么它的所有部分也会被自动销毁。</p><p>可以把组合想象成一个房子和它的墙壁。你不能把墙壁从房子里拿出来，让它们独立存在。如果房子被拆除，墙壁也就不复存在了。</p><p><strong>主要特点：</strong></p><ul><li><p><strong>强生命周期依赖：</strong> 部分对象的生命周期由整体对象控制。</p></li><li><p><strong>独占拥有：</strong> 一个部分只能属于一个整体。</p></li><li><p><strong>创建关系：</strong> 通常，整体对象负责创建其部分对象。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分类：引擎</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Engine</span>(std::string t) : <span class="built_in">type</span>(t) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Engine (&quot;</span> &lt;&lt; type &lt;&lt; <span class="string">&quot;) created.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Engine</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Engine (&quot;</span> &lt;&lt; type &lt;&lt; <span class="string">&quot;) destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体类：汽车</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 组合关系：Car 拥有一个 Engine 对象</span></span><br><span class="line">    <span class="comment">// Engine 对象的生命周期由 Car 控制</span></span><br><span class="line">    Engine engine;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Car 构造函数负责创建 Engine 对象</span></span><br><span class="line">    <span class="built_in">Car</span>(std::string engine_type) : <span class="built_in">engine</span>(engine_type) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Car created.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Car</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Car destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// Engine 对象在 Car 析构时自动销毁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">myCar</span><span class="params">(<span class="string">&quot;V8&quot;</span>)</span></span>; </span><br><span class="line">    <span class="comment">// 当 myCar 对象离开作用域或被销毁时，它所拥有的 Engine 对象也会被销毁。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Engine (V8) created.</span><br><span class="line">Car created.</span><br><span class="line">Car destroyed.</span><br><span class="line">Engine (V8) destroyed.</span><br></pre></td></tr></table></figure><hr><h3 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h3><p>聚合是一种<strong>弱拥有</strong>关系，表示“部分”可以<strong>独立于</strong>“整体”存在。即使整体被销毁，部分仍然可以继续存在。</p><p>可以把聚合想象成一个部门和它的员工。员工可以加入或离开一个部门，但他们仍然是独立的个体。即使部门解散了，员工并不会消失。</p><p><strong>主要特点：</strong></p><ul><li><p><strong>弱生命周期依赖：</strong> 部分对象的生命周期不依赖于整体对象。</p></li><li><p><strong>共享拥有：</strong> 一个部分可以被多个整体共享。</p></li><li><p><strong>引用关系：</strong> 通常通过指针或引用来建立关系。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分类：员工</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Employee</span>(std::string n) : <span class="built_in">name</span>(n) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Employee (&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;) created.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Employee</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Employee (&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;) destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体类：部门</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 聚合关系：Department 包含指向 Employee 对象的指针</span></span><br><span class="line">    <span class="comment">// Department 不拥有 Employee 对象的生命周期</span></span><br><span class="line">    std::vector&lt;Employee*&gt; employees;</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Department</span>(std::string n) : <span class="built_in">name</span>(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEmployee</span><span class="params">(Employee* emp)</span> </span>&#123;</span><br><span class="line">        employees.<span class="built_in">push_back</span>(emp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Department</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Department (&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;) destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 注意：Department 析构时，不会销毁 Employee 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Employee 对象独立创建，其生命周期不受 Department 控制</span></span><br><span class="line">    Employee* emp1 = <span class="keyword">new</span> <span class="built_in">Employee</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    Employee* emp2 = <span class="keyword">new</span> <span class="built_in">Employee</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Department <span class="title">sales_dept</span><span class="params">(<span class="string">&quot;Sales&quot;</span>)</span></span>;</span><br><span class="line">        sales_dept.<span class="built_in">addEmployee</span>(emp1);</span><br><span class="line">        sales_dept.<span class="built_in">addEmployee</span>(emp2);</span><br><span class="line">    &#125; <span class="comment">// sales_dept 离开作用域，被销毁，但 emp1 和 emp2 仍然存在</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时，部门对象已经销毁，但员工对象仍然存在</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Alice&#x27;s status: Still exists.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 必须手动释放 Employee 对象</span></span><br><span class="line">    <span class="keyword">delete</span> emp1;</span><br><span class="line">    <span class="keyword">delete</span> emp2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Employee (Alice) created.</span><br><span class="line">Employee (Bob) created.</span><br><span class="line">Department (Sales) destroyed.</span><br><span class="line">Alice&#x27;s status: Still exists.</span><br><span class="line">Employee (Alice) destroyed.</span><br><span class="line">Employee (Bob) destroyed.</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>特性</th><th>组合（Composition）</th><th>聚合（Aggregation）</th></tr></thead><tbody><tr><td><strong>关系</strong></td><td>“部分”是“整体”的一部分</td><td>“部分”<strong>是</strong>一个“整体”的成员</td></tr><tr><td><strong>生命周期</strong></td><td>强依赖，整体销毁部分也销毁</td><td>弱依赖，整体销毁部分可继续存在</td></tr><tr><td><strong>拥有关系</strong></td><td>独占拥有</td><td>共享拥有</td></tr><tr><td><strong>实现方式</strong></td><td>通常是成员变量</td><td>通常是指针或引用成员变量</td></tr><tr><td><strong>类比</strong></td><td>房子和墙壁</td><td>部门和员工</td></tr><tr><td><strong>适用场景</strong></td><td>当部分没有整体就无意义时</td><td>当部分可以独立存在或被共享时</td></tr></tbody></table><p>在实际编程中，区分这两种关系对于正确管理内存和设计类之间的耦合至关重要。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;组合（Composition）&quot;&gt;&lt;a href=&quot;#组合（Composition）&quot; class=&quot;headerlink&quot; title=&quot;组合（Composition）&quot;&gt;&lt;/a&gt;组合（Composition）&lt;/h3&gt;&lt;p&gt;组合是一种&lt;strong&gt;强拥有&lt;/</summary>
      
    
    
    
    
    <category term="C++" scheme="https://sfxfs.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本基础</title>
    <link href="https://sfxfs.github.io/2025/08/25/Shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"/>
    <id>https://sfxfs.github.io/2025/08/25/Shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/</id>
    <published>2025-08-25T12:29:40.000Z</published>
    <updated>2025-09-24T06:28:27.886Z</updated>
    
    <content type="html"><![CDATA[<p>注意：在本文中，不以 <code> #!/bin/bash</code> 开头的代码均为伪代码或命令，仅供示意。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 上面一行称为 shabang，为的是直接执行脚本的时候能使用正确的解释器</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, world!&quot;</span></span><br></pre></td></tr></table></figure><p>使用以下命令来检查语法错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -n ./xxx.sh</span><br></pre></td></tr></table></figure><p>没有错误将不会有任何输出，执行脚本可以通过以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash ./xxx.sh <span class="comment"># 直接指定解释器来执行</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="built_in">chmod</span> +x ./xxx.sh &amp;&amp; ./xxx.sh <span class="comment"># 把脚本赋予可执行权限后直接执行</span></span><br></pre></td></tr></table></figure><h2 id="使用变量和注释"><a href="#使用变量和注释" class="headerlink" title="使用变量和注释"></a>使用变量和注释</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一个注释，不会被执行</span></span><br></pre></td></tr></table></figure><p>获取变量的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BASH</span> <span class="comment"># &#x27;$&#x27;加变量名用于获取变量值</span></span><br><span class="line"><span class="comment"># 全大写的一般为系统变量，用户自行定义的变量一般写成全小写形式</span></span><br><span class="line"><span class="comment"># 如 &#x27;$HOME $PATH $PWD&#x27;</span></span><br></pre></td></tr></table></figure><p>定义一个变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=Mark</span><br></pre></td></tr></table></figure><p>使用这个变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> The name is <span class="variable">$name</span></span><br></pre></td></tr></table></figure><h2 id="读取用户输入"><a href="#读取用户输入" class="headerlink" title="读取用户输入"></a>读取用户输入</h2><p>单一变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Enter name: &quot;</span></span><br><span class="line"><span class="built_in">read</span> name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your name is <span class="variable">$name</span>.&quot;</span></span><br></pre></td></tr></table></figure><p>多个变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Enter name: &quot;</span></span><br><span class="line"><span class="built_in">read</span> name1 name2 name3</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your name is <span class="variable">$name1</span>, <span class="variable">$name2</span>, <span class="variable">$name3</span>.&quot;</span></span><br></pre></td></tr></table></figure><p>太麻烦了，使用数组来读取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -a names <span class="comment"># array</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Names: <span class="variable">$&#123;names[0]&#125;</span>, ...&quot;</span></span><br></pre></td></tr></table></figure><p>输入时请在每个名字间加入空格。如果我们想在同一行打印和输入或者在输密码的时候保证隐私：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&#x27;Enter username: &#x27;</span> user_name</span><br><span class="line"><span class="built_in">read</span> -sp <span class="string">&#x27;Enter password: &#x27;</span> user_password <span class="comment"># 输入将不会有任何回显</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;name is <span class="variable">$user_name</span>&quot;</span></span><br></pre></td></tr></table></figure><p>如果你不想定义变量来存储：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Enter name: &quot;</span></span><br><span class="line"><span class="built_in">read</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your name is <span class="variable">$REPLY</span>.&quot;</span></span><br><span class="line"><span class="comment"># read 会把读取到的都存进 $REPLY，这是个系统变量</span></span><br></pre></td></tr></table></figure><h2 id="向脚本传入参数"><a href="#向脚本传入参数" class="headerlink" title="向脚本传入参数"></a>向脚本传入参数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$0</span> <span class="variable">$1</span> <span class="variable">$2</span></span><br></pre></td></tr></table></figure><p>如果是通过下面指令执行的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./xxx.sh -qwq 123</span><br></pre></td></tr></table></figure><p>将会打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./xxx.sh -qwq 123</span><br></pre></td></tr></table></figure><p>将参数作为数组存储：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">args=(<span class="string">&quot;<span class="variable">$@</span>&quot;</span>) <span class="comment"># &#x27;$@&#x27;作为数组</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arg[0]&#125;</span> ...</span><br><span class="line"><span class="comment"># 但是请注意，arg[0] 等效 $1 而不是 $0</span></span><br></pre></td></tr></table></figure><p>打印一共传入了多少个参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$#</span> <span class="comment"># 同样，不包括 $0</span></span><br></pre></td></tr></table></figure><h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">count=10</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$count</span> -eq 10 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;cond is true&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;cond is false&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="整型数对比"><a href="#整型数对比" class="headerlink" title="整型数对比"></a>整型数对比</h3><table><thead><tr><th>语句</th><th>效果</th></tr></thead><tbody><tr><td>-eq</td><td>等于</td></tr><tr><td>-ne</td><td>不等于</td></tr><tr><td>-gt or &gt; if ((  ))</td><td>大于</td></tr><tr><td>-ge or &gt;&#x3D; if ((  ))</td><td>大于等于</td></tr><tr><td>-lt or &lt; if ((  ))</td><td>小于</td></tr><tr><td>-le or &lt;&#x3D; if ((  ))</td><td>小于等于</td></tr></tbody></table><p><code>if((  ))</code> 代表语句要包括在里面，于正常的 <code>if[  ]</code> 不同。</p><h3 id="字符串对比"><a href="#字符串对比" class="headerlink" title="字符串对比"></a>字符串对比</h3><table><thead><tr><th>语句</th><th>效果</th></tr></thead><tbody><tr><td>&#x3D; or &#x3D;&#x3D;</td><td>等于</td></tr><tr><td>!&#x3D;</td><td>不等于</td></tr><tr><td>&lt; if [[  ]]</td><td>ASCII码表来比大小</td></tr><tr><td>&gt; if [[  ]]</td><td>同上</td></tr><tr><td>-z</td><td>null，长度为0</td></tr></tbody></table><p><code>if[[  ]]</code> 代表语句要包括在里面，于正常的 <code>if[  ]</code> 不同。</p><h2 id="文件操作符"><a href="#文件操作符" class="headerlink" title="文件操作符"></a>文件操作符</h2><table><thead><tr><th align="left">操作符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">-b file</td><td align="left">检测文件是否是块设备文件，如果是，则返回 true。</td><td align="left">[ -b $file ] 返回 false。</td></tr><tr><td align="left">-c file</td><td align="left">检测文件是否是字符设备文件，如果是，则返回 true。</td><td align="left">[ -c $file ] 返回 false。</td></tr><tr><td align="left">-d file</td><td align="left">检测文件是否是目录，如果是，则返回 true。</td><td align="left">[ -d $file ] 返回 false。</td></tr><tr><td align="left">-f file</td><td align="left">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td><td align="left">[ -f $file ] 返回 true。</td></tr><tr><td align="left">-g file</td><td align="left">检测文件是否设置了 SGID 位，如果是，则返回 true。</td><td align="left">[ -g $file ] 返回 false。</td></tr><tr><td align="left">-k file</td><td align="left">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td><td align="left">[ -k $file ] 返回 false。</td></tr><tr><td align="left">-p file</td><td align="left">检测文件是否是有名管道，如果是，则返回 true。</td><td align="left">[ -p $file ] 返回 false。</td></tr><tr><td align="left">-u file</td><td align="left">检测文件是否设置了 SUID 位，如果是，则返回 true。</td><td align="left">[ -u $file ] 返回 false。</td></tr><tr><td align="left">-r file</td><td align="left">检测文件是否可读，如果是，则返回 true。</td><td align="left">[ -r $file ] 返回 true。</td></tr><tr><td align="left">-w file</td><td align="left">检测文件是否可写，如果是，则返回 true。</td><td align="left">[ -w $file ] 返回 true。</td></tr><tr><td align="left">-x file</td><td align="left">检测文件是否可执行，如果是，则返回 true。</td><td align="left">[ -x $file ] 返回 true。</td></tr><tr><td align="left">-s file</td><td align="left">检测文件是否为空（文件大小是否大于0），不为空返回 true。</td><td align="left">[ -s $file ] 返回 true。</td></tr><tr><td align="left">-e file</td><td align="left">检测文件（包括目录）是否存在，如果是，则返回 true。</td><td align="left">[ -e $file ] 返回 true。</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">Shell脚本编程基础教程，从Hello World开始学习Shell脚本的基本语法和编程技巧</summary>
    
    
    
    <category term="操作系统" scheme="https://sfxfs.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux" scheme="https://sfxfs.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
    
    <category term="Linux" scheme="https://sfxfs.github.io/tags/Linux/"/>
    
    <category term="Shell" scheme="https://sfxfs.github.io/tags/Shell/"/>
    
    <category term="脚本编程" scheme="https://sfxfs.github.io/tags/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"/>
    
    <category term="自动化" scheme="https://sfxfs.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="命令行" scheme="https://sfxfs.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
    <category term="Bash" scheme="https://sfxfs.github.io/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>CAN理论基础</title>
    <link href="https://sfxfs.github.io/2025/08/21/CAN%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <id>https://sfxfs.github.io/2025/08/21/CAN%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</id>
    <published>2025-08-21T04:32:11.000Z</published>
    <updated>2025-09-24T06:28:27.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>CAN 定义了物理层（Physical）和数据链路层（DataLink）</p><ul><li>物理层：规定引脚数、如何定义0和1等等</li><li>数据链路层：如何定义一个CAN帧</li></ul><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>特性包括</p><ul><li>包括 CAN_Low 和 CAN_High 两个线</li><li>逐位总线仲裁</li><li>双绞线，差分信号</li></ul><p><img src="/2025/08/21/CAN%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/1.png"></p><h3 id="电平"><a href="#电平" class="headerlink" title="电平"></a>电平</h3><p><img src="/2025/08/21/CAN%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2.png"></p><p>0为显性，1为隐性，即0可以把1覆盖了</p><h3 id="按位仲裁"><a href="#按位仲裁" class="headerlink" title="按位仲裁"></a>按位仲裁</h3><p><img src="/2025/08/21/CAN%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/3.png"></p><p>可以理解0的优先级比1高，即数字越小优先级越高；节点A它发送了1却检测到了0，那它就会停止发送了，因为有优先级更高的设备在传输</p><h2 id="数据链路层（帧）"><a href="#数据链路层（帧）" class="headerlink" title="数据链路层（帧）"></a>数据链路层（帧）</h2><p>共有三种类型：</p><p>其中**<code>错误帧</code><strong>、</strong><code>过载帧</code><strong>、</strong><code>帧间隔</code>**都是由硬件完成的，没有办法用软件来控制。</p><p>数据帧和遥控帧有**<code>标准格式</code><strong>与</strong><code>扩展格式</code><strong>。标准格式有</strong><code>11位</code><strong>标识符，扩展格式有</strong><code>29位</code>**标识符。</p><ul><li>数据帧</li><li>远程帧</li><li>错误帧</li></ul><h3 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h3><p><img src="/2025/08/21/CAN%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/4.png"></p><p><img src="/2025/08/21/CAN%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/5.png"></p><p>包括</p><table><thead><tr><th>1</th><th>帧起始</th><th>表示帧的开始，产生一个bit的显性电平。</th></tr></thead><tbody><tr><td>2</td><td>仲裁段</td><td>表示帧的优先级， 由标识符（ID）和传送帧类型(RTR)组成。</td></tr><tr><td>3</td><td>控制端</td><td>表示数据的字节数，由6个bit构成（4bits为DLC 0～8bytes）。IDE位用于表明此帧是标准帧还是扩展帧。</td></tr><tr><td>4</td><td>数据段</td><td>数据的具体内容，可发送0～8 个字节的数据。</td></tr><tr><td>5</td><td>CRC段</td><td>用于校验传输是否正确。</td></tr><tr><td>6</td><td>ACK段</td><td>表示确认是否正常接收。</td></tr><tr><td>7</td><td>帧结束</td><td>表示此帧结束。</td></tr></tbody></table><h3 id="远程帧"><a href="#远程帧" class="headerlink" title="远程帧"></a>远程帧</h3><p>用于请求数据</p><p>不包括数据区</p><h3 id="错误帧"><a href="#错误帧" class="headerlink" title="错误帧"></a>错误帧</h3><p>Transmitted when a node detects a fault and cause all other nodes to detect a fault</p><p>包括</p><ul><li>错误标志</li><li>错误分割（留时间给其他设备发错误帧）</li></ul><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><ul><li><p>配置波特率</p></li><li><p>配置过滤器：<strong>CAN过滤器有两种工作模式</strong>：<strong><code>列表模式</code></strong> 与 <strong><code>掩码模式</code></strong>。</p><ul><li>列表：列出ID名字，过滤器通过判断报文ID与其是否一致来决定是接受还是舍弃这份报文。</li><li>掩码：通过确定ID特定位的值来判断报文的接受与丢弃。</li></ul></li><li><p>之后就可以发送和接收了</p></li></ul>]]></content>
    
    
    <summary type="html">详解CAN总线的理论基础，包括物理层和数据链路层的详细说明，深入理解CAN通信协议</summary>
    
    
    
    <category term="嵌入式开发" scheme="https://sfxfs.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="通信协议" scheme="https://sfxfs.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="CAN" scheme="https://sfxfs.github.io/tags/CAN/"/>
    
    <category term="通信协议" scheme="https://sfxfs.github.io/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="总线" scheme="https://sfxfs.github.io/tags/%E6%80%BB%E7%BA%BF/"/>
    
    <category term="嵌入式" scheme="https://sfxfs.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="物理层" scheme="https://sfxfs.github.io/tags/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    
    <category term="数据链路层" scheme="https://sfxfs.github.io/tags/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    
    <category term="理论基础" scheme="https://sfxfs.github.io/tags/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言细枝末节</title>
    <link href="https://sfxfs.github.io/2025/08/21/C%E8%AF%AD%E8%A8%80%E7%BB%86%E6%9E%9D%E6%9C%AB%E8%8A%82/"/>
    <id>https://sfxfs.github.io/2025/08/21/C%E8%AF%AD%E8%A8%80%E7%BB%86%E6%9E%9D%E6%9C%AB%E8%8A%82/</id>
    <published>2025-08-21T03:05:25.000Z</published>
    <updated>2025-09-24T06:28:27.883Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h2><pre><code>16位操作系统：long：4字节，int：2字节32位操作系统：long：4字节，int：4字节64位操作系统：long：8字节，int：4字节</code></pre><p>所以最好使用 stdint 内的指定位数的定义（如int8、int32等）保证移植的兼容性</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul><li>用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化（告诉编译器对该变量不做优化，都会直接从变量内存地址中读取数据）</li></ul><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p><strong>全局（静态）存储区</strong>：分为 DATA 段和 BSS 段。DATA 段（全局初始化区）存放初始化的全局变量和静态变量；BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。</p><ul><li>在修饰变量的时候，static 修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。</li><li>static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。</li><li>static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。</li><li>不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。</li><li>考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。</li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h3><p>核心特性</p><ul><li>自动分配与释放：由编译器自动管理，函数调用时分配栈帧，函数返回时自动释放。</li><li>后进先出（LIFO）</li><li>高速访问</li><li>空间有限</li></ul><p>存储内容</p><ul><li>局部变量：函数内部定义的变量。</li><li>返回地址：函数执行完毕后返回的位置。</li><li>函数参数：调用函数时传递的参数。</li><li>寄存器值：保存调用前的寄存器状态，以便恢复。</li></ul><p>优缺点</p><ul><li>优点：无需手动管理内存，速度快，不会内存泄漏。</li><li>缺点：生命周期固定（函数结束即释放），空间有限。</li></ul><h3 id="堆（heap）"><a href="#堆（heap）" class="headerlink" title="堆（heap）"></a>堆（heap）</h3><p>核心特性</p><ul><li>手动分配与释放：使用malloc&#x2F;calloc&#x2F;realloc分配，free释放。</li><li>动态生命周期：内存块的生命周期由程序员控制，可跨函数使用。</li><li>碎片化问题：频繁分配和释放可能导致内存碎片，降低空间利用率。</li><li>慢速访问：需通过指针间接访问，效率低于栈。</li></ul><p>存储内容</p><ul><li>动态分配的对象：如malloc返回的内存块。</li><li>大型数据结构：如数组、链表、树等需要动态调整大小的结构。</li><li>跨函数数据：需要在函数调用结束后继续存在的数据。</li></ul><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p><strong>空指针</strong>：指针变量指向内存中编号为0的空间</p><p><strong>野指针</strong>：指针变量指向非法的内存空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针指向的值是不可以更改的</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * p1 = &amp;a; </span><br><span class="line"></span><br><span class="line"><span class="comment">//指针指向是不可以改的</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p2 = &amp;a;</span><br></pre></td></tr></table></figure><h2 id="数据集合"><a href="#数据集合" class="headerlink" title="数据集合"></a>数据集合</h2><h3 id="共用体（union）"><a href="#共用体（union）" class="headerlink" title="共用体（union）"></a>共用体（union）</h3><p>所有成员共用一块内存，大小取决于最大大小成员</p><h3 id="枚举（enum）"><a href="#枚举（enum）" class="headerlink" title="枚举（enum）"></a>枚举（enum）</h3><p>默认从 0 开始递增</p><h3 id="位域（Bit-Field）"><a href="#位域（Bit-Field）" class="headerlink" title="位域（Bit Field）"></a>位域（Bit Field）</h3><p>位域用于结构体中，定义每个字段占用的比特位数；越前面定义的在内存的越高位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Flags</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ready : <span class="number">1</span>;<span class="comment">// 1bit</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> error : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mode  : <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>位域不能取地址（&amp;f.ready 不合法）</li><li>字段数值不能超过位数范围（2^n - 1）</li><li>与具体编译器实现密切相关（跨平台需小心）</li></ul><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LED_PIN (1 &lt;&lt; 2)</span></span><br><span class="line"></span><br><span class="line">PORT |= LED_PIN;   <span class="comment">// 置位</span></span><br><span class="line">PORT &amp;= ~LED_PIN;  <span class="comment">// 清零</span></span><br><span class="line">PORT ^= LED_PIN;   <span class="comment">// 翻转</span></span><br></pre></td></tr></table></figure><h2 id="编译和调试"><a href="#编译和调试" class="headerlink" title="编译和调试"></a>编译和调试</h2><h3 id="四阶段"><a href="#四阶段" class="headerlink" title="四阶段"></a>四阶段</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -E main.c -o main.i   # 预处理</span><br><span class="line">gcc -S main.c -o main.s   # 编译为汇编</span><br><span class="line">gcc -c main.c -o main.o   # 汇编为目标文件</span><br><span class="line">gcc main.o -o main        # 链接生成可执行文件</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">C语言编程中容易忽略的细节和技巧，包括数据类型、内存管理和跨平台兼容性问题</summary>
    
    
    
    <category term="编程语言" scheme="https://sfxfs.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C语言" scheme="https://sfxfs.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="编程技巧" scheme="https://sfxfs.github.io/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    <category term="C语言" scheme="https://sfxfs.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="数据类型" scheme="https://sfxfs.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    <category term="跨平台" scheme="https://sfxfs.github.io/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
    <category term="编程基础" scheme="https://sfxfs.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>UART理论基础</title>
    <link href="https://sfxfs.github.io/2025/08/20/UART%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <id>https://sfxfs.github.io/2025/08/20/UART%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</id>
    <published>2025-08-20T14:22:23.000Z</published>
    <updated>2025-09-24T06:28:27.887Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p>串行通信：数据一位一位按时间顺序发送（与并行通信相对）。</p></li><li><p>异步（Asynchronous）：发送端和接收端不共享时钟线，而是通过预先约定的波特率（baud rate）和帧格式来同步数据采样。</p></li></ul><h2 id="物理连接与信号"><a href="#物理连接与信号" class="headerlink" title="物理连接与信号"></a>物理连接与信号</h2><ul><li><p>常见的信号线：TX（发）和 RX（收），通常两设备交叉连接（A的TX接B的RX）。</p></li><li><p>电平标准：常见TTL电平（0V ~ 5V 或 0V ~ 3.3V）和RS-232（-3～-15V表示 1 ，+3～+15V表示 0 ）等。不同电平不可直接连接，需电平转换器（如 MAX232）。</p></li><li><p>差分连接：RS485差分连接（TX 包括 TXD-、TXD+，以此类推），当两条差分线之间压差为正时（如+2V～+6V）为逻辑1，反之</p></li></ul><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p><img src="/2025/08/20/UART%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/1.png"></p><ul><li><p>起始位：通信以发送方发送逻辑0为开始（空闲时为高电平），同时这也是为了同步采样周期。</p></li><li><p>数据位：可以为 5～8 bit，最低位优先</p></li><li><p>奇偶校验位：可以为</p><ul><li><p>关闭（0 bit）</p></li><li><p>奇校验（odd parity）：数据位的1的个数为偶，则该位为1，反之</p></li><li><p>偶校验（even parity）：数据位的1的个数为偶，则该位为0，反之</p></li></ul></li><li><p>停止位：是逻辑1，高电平，长度可以为1 bit、1.5 bit、2 bit</p></li></ul><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p><strong>1.RTS （Require ToSend，发送请求）为输出信号，用于指示本设备准备好可接收数据，低电平有效，低电平说明本设备可以接收数据。</strong></p><p><strong>2.CTS （Clear ToSend，发送允许）为输入信号，用于判断是否可以向对方发送数据，低电平有效，低电平说明本设备可以向对方发送数据。</strong></p><p>因此流控制可以控制数据传输的进程，防止数据的丢失。</p>]]></content>
    
    
    <summary type="html">深入讲解UART串行通信协议的基础理论，包括异步通信原理、波特率、帧格式和物理连接方式</summary>
    
    
    
    <category term="嵌入式开发" scheme="https://sfxfs.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="通信协议" scheme="https://sfxfs.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="通信协议" scheme="https://sfxfs.github.io/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="嵌入式" scheme="https://sfxfs.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="理论基础" scheme="https://sfxfs.github.io/tags/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="串行通信" scheme="https://sfxfs.github.io/tags/%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1/"/>
    
    <category term="UART" scheme="https://sfxfs.github.io/tags/UART/"/>
    
    <category term="异步通信" scheme="https://sfxfs.github.io/tags/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>SPI理论基础</title>
    <link href="https://sfxfs.github.io/2025/08/20/SPI%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <id>https://sfxfs.github.io/2025/08/20/SPI%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</id>
    <published>2025-08-20T14:22:12.000Z</published>
    <updated>2025-09-24T06:28:27.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SPI-协议简介"><a href="#SPI-协议简介" class="headerlink" title="SPI 协议简介"></a>SPI 协议简介</h2><p>SPI（Serial Peripheral Interface）协议是一种主从式的通信协议，主设备可以同时控制多个从设备，但每个从设备只能被一个主设备控制。SPI 协议的主要特点是通信速度快，但通信线路较多，常用于短距离的板内通信。  </p><p>SPI 通信必须由主机发起通信（无论是发送还是接收），从机被动接受。从机不能主动发送数据。  </p><h2 id="SPI-接口形式"><a href="#SPI-接口形式" class="headerlink" title="SPI 接口形式"></a>SPI 接口形式</h2><p>SPI 接口有如下几个引脚：</p><ul><li>SCLK（Serial Clock）：时钟信号</li><li>MOSI（Master Output &#x2F; Slave Input）：主设备输出、从设备输入</li><li>MISO（Master Input &#x2F; Slave Output）：主设备输入、从设备输出</li><li>CS（Chip Select）：片选信号，用于选择从设备</li></ul><p><strong>此处只讨论标准 SPI，不讨论 Dual SPI、Qual SPI 等扩展协议。</strong></p><h2 id="SPI-时序"><a href="#SPI-时序" class="headerlink" title="SPI 时序"></a>SPI 时序</h2><h3 id="片选信号"><a href="#片选信号" class="headerlink" title="片选信号"></a>片选信号</h3><p>SPI 传输过程中，输出 CS 为低电平，选择从设备。从设备只有在 CS 为低电平时，才会响应主设备的时钟信号。</p><p>在多个从设备的情况下，可以使用多个 CS 引脚，每个 CS 引脚对应一个从设备。在每次传输开始前，主设备需要先拉低对应的 CS 引脚，然后再传输数据。传输结束后，主设备需要拉高对应的 CS 引脚，释放从设备。</p><p>在单个从设备的情况下，可以直接将从设备的 CS 引脚接地，省去了主设备控制 CS 引脚的步骤。也可以使用硬件 NSS 信号作为从设备的 CS 引脚。</p><h3 id="协议参数"><a href="#协议参数" class="headerlink" title="协议参数"></a>协议参数</h3><p>SPI 协议的主要参数有：</p><ul><li>时钟极性（CPOL，Clock Polarity）：时钟空闲状态为高电平（1）还是低电平（0）</li><li>时钟相位（CPHA，Clock Phase）：数据在时钟的第一个边沿采样（0）还是第二个边沿采样（1）</li><li>时钟频率（SCLK，Serial Clock）：时钟信号的频率</li><li>传输顺序：MSB（高位，即左到右）优先还是 LSB（低位）优先</li></ul><h3 id="SPI-时序实例"><a href="#SPI-时序实例" class="headerlink" title="SPI 时序实例"></a>SPI 时序实例</h3><p>传输 0xC8，MSB 优先，SPI Mode 0（CPOL&#x3D;0，CPHA&#x3D;0）时钟空闲低电平，第一个边沿采样。<br><img src="/2025/08/20/SPI%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/SpiExample.png"></p><h3 id="时钟信号"><a href="#时钟信号" class="headerlink" title="时钟信号"></a>时钟信号</h3><p>SPI 时钟信号由主设备产生，从设备被动接收。时钟信号仅在传输数据时使用，空闲状态会维持在高电平或低电平（由时钟极性决定）。</p><h3 id="数据信号"><a href="#数据信号" class="headerlink" title="数据信号"></a>数据信号</h3><p>数据信号在时钟信号的边沿采样，具体第一边沿还是第二边沿由时钟相位决定。   </p><p>数据的比特序分为 MSB 优先 和 LSB 优先两种，双方需要提前约定。</p><h3 id="SPI-模式"><a href="#SPI-模式" class="headerlink" title="SPI 模式"></a>SPI 模式</h3><p>SPI 模式号是 CPOL 和 CPHA 的组合，一共有四种模式：</p><ul><li>Mode $0&#x3D;(00)_2$：CPOL&#x3D;0，CPHA&#x3D;0</li><li>Mode $1&#x3D;(01)_2$：CPOL&#x3D;0，CPHA&#x3D;1</li><li>Mode $2&#x3D;(10)_2$：CPOL&#x3D;1，CPHA&#x3D;0</li><li>Mode $3&#x3D;(11)_2$：CPOL&#x3D;1，CPHA&#x3D;1</li></ul>]]></content>
    
    
    <summary type="html">详解SPI串行外设接口协议的基础理论，包括主从式通信机制、信号线定义和通信流程</summary>
    
    
    
    <category term="嵌入式开发" scheme="https://sfxfs.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="通信协议" scheme="https://sfxfs.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="通信协议" scheme="https://sfxfs.github.io/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="嵌入式" scheme="https://sfxfs.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="理论基础" scheme="https://sfxfs.github.io/tags/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="SPI" scheme="https://sfxfs.github.io/tags/SPI/"/>
    
    <category term="串行通信" scheme="https://sfxfs.github.io/tags/%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1/"/>
    
    <category term="主从通信" scheme="https://sfxfs.github.io/tags/%E4%B8%BB%E4%BB%8E%E9%80%9A%E4%BF%A1/"/>
    
    <category term="接口" scheme="https://sfxfs.github.io/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>IIC理论基础</title>
    <link href="https://sfxfs.github.io/2025/08/19/IIC%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <id>https://sfxfs.github.io/2025/08/19/IIC%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</id>
    <published>2025-08-19T05:42:17.000Z</published>
    <updated>2025-09-24T06:28:27.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>IIC 是两线串行通信协议（serial data line (SDA) serial clock line (SCL)），支持多设备于同一总线通信，每个设备拥有唯一地址来标识。</p><h3 id="速度模式"><a href="#速度模式" class="headerlink" title="速度模式"></a>速度模式</h3><p><img src="/2025/08/19/IIC%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/1.png"></p><ul><li>标准模式：最慢的模式</li><li>快速模式：要求总线容值和设备兼容性能匹配</li><li>快速+模式：同上</li></ul><p>下面两个稍微有些特殊：</p><ul><li>高速模式：两者需协商后才能启用该模式</li><li>超快模式：该模式只能进行写操作，并且一些IIC功能也不可用</li></ul><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="两线连接"><a href="#两线连接" class="headerlink" title="两线连接"></a>两线连接</h3><p><img src="/2025/08/19/IIC%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2.png"></p><h3 id="开漏连接"><a href="#开漏连接" class="headerlink" title="开漏连接"></a>开漏连接</h3><p>SDA和SCL都要开漏连接，两者各自连接到一个NMOS，以便可以在需要的时候接地来拉低总线。开漏连接就是IIC能连接多个设备的原因。</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="开始和停止"><a href="#开始和停止" class="headerlink" title="开始和停止"></a>开始和停止</h3><p><img src="/2025/08/19/IIC%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/3.png"></p><ul><li>开始：将 SDA 和 SCL 都拉低（先拉 SDA）</li><li>结束：将 SDA 和 SCL 都释放为高电平（先放 SCL）</li></ul><h3 id="逻辑1和0"><a href="#逻辑1和0" class="headerlink" title="逻辑1和0"></a>逻辑1和0</h3><p><img src="/2025/08/19/IIC%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/4.png"></p><ul><li>SDA 释放高时为逻辑 1，下拉时为逻辑 0</li><li>SCL 上升沿和下降沿采样时 SDA 的状态必须相同，否则无效（因为会被识别为开始或结束信号）</li></ul><h3 id="通信帧"><a href="#通信帧" class="headerlink" title="通信帧"></a>通信帧</h3><p>一个帧9个bit，为了开始通信，需要发送开始信号后接设备地址（7bit or 10bit，10bit则要发两个bytes）</p><p><img src="/2025/08/19/IIC%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/5.png"></p><ul><li>若 R&#x2F;W 位为 1 则是主机要求读取从机数据，即 R，反之</li><li>第九比特为 ACK，由目标设备（即写入时是从机拉低，读取时是主机拉低）在 SCL 周期内拉低 SDA，表示收到数据；若SDA一直为高电平，则表明没有对应地址的设备收到请求</li></ul>]]></content>
    
    
    <summary type="html">深入解析IIC（I2C）总线通信协议的理论基础，包括双线通信机制、多设备管理和地址机制</summary>
    
    
    
    <category term="嵌入式开发" scheme="https://sfxfs.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="通信协议" scheme="https://sfxfs.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="通信协议" scheme="https://sfxfs.github.io/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="嵌入式" scheme="https://sfxfs.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="理论基础" scheme="https://sfxfs.github.io/tags/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="IIC" scheme="https://sfxfs.github.io/tags/IIC/"/>
    
    <category term="I2C" scheme="https://sfxfs.github.io/tags/I2C/"/>
    
    <category term="双线通信" scheme="https://sfxfs.github.io/tags/%E5%8F%8C%E7%BA%BF%E9%80%9A%E4%BF%A1/"/>
    
    <category term="总线通信" scheme="https://sfxfs.github.io/tags/%E6%80%BB%E7%BA%BF%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
</feed>
